---
title: CSRF
toc: true
date: 2017-11-25  10:35:12
tags: [前端, CSRF, js 基础]
---


# CSRF 简介

`Cross Site Request Forgery，跨站域请求伪造`

```

假设 abc 用户登录银行的网站进行操作，同时也访问了攻击者预先设置好的网站。
abc 点击了攻击者网站的某一个链接，这个链接是 http://www.bank.com/xxxx 指向银行，银行服务器会根据这个链接携带的参数会进行转账操作。
银行服务器在执行转账操作之前会进行 session 验证是否登录，但是由于 abc 已经登录了银行网站，攻击者的链接也是 www.bank.com。所以攻击的链接就会携带 session id 到银行服务器。
由于 session id 是正确的，所以银行会判断操作是由本人发起的，执行转账操作。

```

要完成一次 CSRF 攻击，受害者必须一次完成两个步骤

1. 登陆受信任网站 A，并在本地生成 cookie
2. 在不退出 A 的情况下，访问了危险网站 B

到这里，你也许会说：如果我不满足以上条件的中的任何一个，就不会受到攻击。但是你不能保证以下条件不会发生：

1. 你不能保证你登陆了一个网站后，不再打开一个 tab 页面并访问另外的网站
2. 你不能保证你关闭浏览器后，你本地的 cookie 马上过期，你上次的会话已经结束
3. 存在其他漏洞的可信任的经常被人访问的网站

# 防止 CSRF 的几种方法


## 服务器端进行 CSRF 防御


1. Cookie Hashing（所有表单都包含同一个伪随机值）：

> 可以在表单中嵌入一个随机的 token。当真正的用户提交表单的时，你就会收到表单的随机 token，这样你就可以通过之前嵌入的那个随机 token 来校验了。在 CSRF 攻击场景中，攻击者永远都不可能拿到这个值甚至在攻击者可以请求到页面的情况也无法拿到，因为同源策略（SOP）会阻止攻击者从包含 token 的响应中读取内容。这个方法在实际运用中很不错，但是它需要网站追踪每一个请求并且返回 Anti-CSRF tokens。还有一个类似的在表单中嵌入 token 的方法是给浏览器一个包含相同值的 cookie 来实现的。当网站收到真正的用户提交他们的表单时，cookie 中的值和表单中的值将会相匹配。攻击者通过没有 CSRF cookie 的浏览器发送伪造的请求将会失败。


2. One-Time Tokens（不同的表单包含一个不同的伪随机值）：

> 如果用户在一个站点上同时打开了两个不同的表单，CSRF 保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保 CSRF 保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。

> 令牌同步模式（Synchronizer token pattern，简称 STP）是在用户请求的页面中的所有表单中嵌入一个 token，在服务端验证这个 token 的技术。token 可以是任意的内容，但是一定要保证无法被攻击者猜测到或者查询到。攻击者在请求中无法使用正确的 token，因此可以判断出未授权的请求。


# 验证了 origin 和 refer 是否能完全避免?

> 根据 HTTP 协议，在 HTTP 请求头中包含一个 referer 的字段，这个字段记录了该 HTTP 请求的原地址。通常情况下，执行转账操作的 POST 请求 www.bank.com/transfer.php 应该是点击 www.bank.com 网页的按钮来触发的操作，这个时候转账请求的 referer 应该是 www.bank.com。而如果黑客要进行 CSRF 攻击，只能在自己的网站 www.hacker.com 上伪造请求。伪造请求的 referer 是 www.hacker.com。所以我们通过对比 POST 请求的 referer 是不是 www.bank.com 就可以判断请求是否合法。

`黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。`

>为了防止 CSRF 的攻击，可以浏览器在发送 POST 请求的时候加上一个 Origin 字段，这个 Origin 字段主要是用来标识出最初请求是从哪里发起的。如果浏览器不能确定源在哪里，那么在发送的请求里面 Origin 字段的值就为空。

`如果攻击者如果直接通过假页面提交 Form，则不能在 header 里设置 X-From 属性；而如果攻击者也用 Ajax 提交，则 header 里的 Origin 因为不能伪造，也不能达到攻击的目的。从而达到了预防 CSRF 的目的。`


