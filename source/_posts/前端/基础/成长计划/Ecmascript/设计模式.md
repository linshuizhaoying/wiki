---
title: 设计模式
toc: true
date: 2018-02-25  09:48:04
tags: [前端, 设计模式, 设计模式]
---

# 设计一个订阅者发布者的基类

>观察者模式（Observer）：
又叫发布-订阅者模式（Publish/Subscribe）或消息机制，
它定义了一种一对多的关系，让多个观察者对象同时监听某一个主体对象，
这个主体对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。

## 模式起源

`建立一种对象与对象之间的依赖关系`，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。

![imgn](http://haoqiao.qiniudn.com/fabudingyuemoishi.png)


## 代码

```

// 背景：评论+消息通知

/*
 * 观察者模式
 *
 * 将观察者放在闭包中，当页面加载就立即执行
 */
var Observer = (function() {
  // 防止消息队列暴漏而被篡改，故将消息容器作为静态私有变量保存。
  var __message = {};

  return {
    // 订阅
    subscribe: function(type, fn) {
      // 如果消息不存在则创建一个消息类型
      if (!__message[type]) {
        __message[type] = [fn];
      } else {
        // 将动作方法推送到消息对应的动作执行序列中
        __message[type].push(fn);
      }
    },

    // 取消订阅
    unsubscribe: function(type, fn) {
      if (!__message[type] || Object.prototype.toString.call(__message[type]) !== '[object Array]') return;

      for (var i = __message[type].length - 1; i >= 0; i--) {
        __message[type][i] === fn && __message[type].splice(i, 1);
      };
    },

    // 发布信息
    publish: function(type, args) {
      if (!__message[type]) return;

      // 定义消息信息
      var events = {
        type: type,
        args: args
      };

      // 执行注册的消息所对应的所有动作序列
      for (var i = 0; i < __message[type].length; i++) {
        __message[type][i].call(this, events);
      }
    }
  }
})();


/*
 * 拉出来溜溜
 */

// 订阅
Observer.subscribe('test', function(e) {
  console.log(e);
});

// 发布
Observer.publish('test', {msg: '传递参数'});






/*
 * 观察者模式
 *
 * 将观察者放在闭包中，当页面加载就立即执行
 */
var Observer = (function() {
  // 防止消息队列暴漏而被篡改，故将消息容器作为静态私有变量保存。
  var __message = {};

  return {
    // 注册信息接口（订阅）
    subscribe: function(type, fn) {
      // 如果消息不存在则创建一个消息类型
      if (!__message[type]) {
        __message[type] = [fn];
      } else {
        // 将动作方法推送到消息对应的动作执行序列中
        __message[type].push(fn);
      }
    },

    // 发布消息接口（取消订阅）
    unsubscribe: function(type, fn) {
      if (!__message[type] || Object.prototype.toString.call(__message[type]) !== '[object Array]') return;

      for (var i = __message[type].length - 1; i >= 0; i--) {
        __message[type][i] === fn && __message[type].splice(i, 1);
      };
    },

    // 移除信息接口（移除信息接口）
    publish: function(type, args) {
      if (!__message[type]) return;

      // 定义消息信息
      var events = {
        type: type,
        args: args
      };

      // 执行注册的消息所对应的所有动作序列
      for (var i = 0; i < __message[type].length; i++) {
        __message[type][i].call(this, events);
      }
    }
  }
})();

// 外观模式
function $(id) {
  return document.getElementById(id);
}

// 工程师A
(function() {

  // 新增一条消息
  function addMsgItem(e) {
    var text = e.args.text;
    var ul = $('msg');
    var li = document.createElement('li');
    var span = document.createElement('span');

    li.innerHTML = text;

    // 关闭按钮
    span.onclick = function() {
      ul.removeChild(li);

      Observer.publish('removeCommentMessage', {
        num: -1
      });
    };

    ul.appendChild(span);
    ul.appendChild(li);
  }

  Observer.subscribe('addCommentMessage', addMsgItem);
})();

// 工程师B
(function() {

  // 修改用户消息数目
  function changeMsgNum(e) {
    var num = e.args.num;
    $('msg_num').innerHTML = parseInt($('msg_num').innerHTML || 0) + 1;
  }

  // 注册添加评论信息
  Observer.subscribe('addCommentMessage', changeMsgNum);
  Observer.subscribe('removeCommentMessage', changeMsgNum);

})();


// 工程师C
(function() {

  // 用户点击提交按钮
  $('user_submit').onclick = function() {
    var text = $('user_input');

    if (!text.value) return;

    Observer.publish('addCommentMessage', {
      text: text.value,
      num: 1
    });

    text.value = '';
  };

})();

/*
 * 测试HTML
 *
 *  <div id="msg"></div>
 *  <input type="text" id="user_input" />
 *  <button id="user_submit">submite</button>
 *  <div id="msg_num"></div>
 */












'use strict';

/*
 * 观察者模式
 *
 * 将观察者放在闭包中，当页面加载就立即执行
 */
var Observer = (function() {
  // 防止消息队列暴漏而被篡改，故将消息容器作为静态私有变量保存。
  var __message = {};

  return {
    // 注册信息接口（订阅）
    subscribe: function(type, fn) {
      // 如果消息不存在则创建一个消息类型
      if (!__message[type]) {
        __message[type] = [fn];
      } else {
        // 将动作方法推送到消息对应的动作执行序列中
        __message[type].push(fn);
      }
    },

    // 发布消息接口（取消订阅）
    unsubscribe: function(type, fn) {
      if (!__message[type] || Object.prototype.toString.call(__message[type]) !== '[object Array]') return;

      for (var i = __message[type].length - 1; i >= 0; i--) {
        __message[type][i] === fn && __message[type].splice(i, 1);
      };
    },

    // 移除信息接口（移除信息接口）
    publish: function(type, args) {
      if (!__message[type]) return;

      // 定义消息信息
      var events = {
        type: type,
        args: args
      };

      // 执行注册的消息所对应的所有动作序列
      for (var i = 0; i < __message[type].length; i++) {
        __message[type][i].call(this, events);
      }
    }
  }
})();


// 学生类
var Student = function(result) {
  var self = this;

  // 学生回答结果
  self.result = result;

  // 学生回答问题动作
  self.say = function() {
    console.log(self.result);
  };
};

// 回答问题方法
Student.prototype.answer = function(question) {
  // 注册参数问题
  Observer.subscribe(question, this.say);
};

Student.prototype.sleep = function(question) {
  Observer.unsubscribe(question, this.say);
};


// 教师类
var Teacher = function() {};
Teacher.prototype.ask = function(question) {
  console.log('问题是：' + question);
  // 发布提问消息
  Observer.publish(question);
};


// 模拟听课的学生
var student1 = new Student('学生1回答问题');
var student2 = new Student('学生2回答问题');
var student3 = new Student('学生3回答问题');

// 注册一下哪位学生回答什么问题
student1.answer('什么是设计模式');
student1.answer('简述观察者模式');
student2.answer('什么是设计模式');
student3.answer('什么是设计模式');
student3.answer('简述观察者模式');

// 后来第三位同学睡着了。。
student3.sleep('简述观察者模式');


var teacher = new Teacher();

// 提问
teacher.ask('什么是设计模式');
teacher.ask('简述观察者模式');

// 最后，两个问题，第一个问题三名同学回答，第二个问题只有第一名同学回答。。。

```

## 优点

* 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。
* 观察者模式在观察目标和观察者之间建立一个抽象的耦合。
* 观察者模式支持广播通信。
* 观察者模式符合“开闭原则”的要求。

## 缺点

* 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
* 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
* 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

## 适用环境

在以下情况下可以使用观察者模式：

* 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
* 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
* 一个对象必须通知其他对象，而并不知道这些对象是谁。
* 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。


# 手写给出一个工厂方法实现

工厂方法其实很多种，因为其作用很大，因此变种也比较多。



## 简单工厂模式

>静态工厂方法。由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象

![imgn](http://haoqiao.qiniudn.com/jiandangongchan.png)

简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节

### 代码

```

//工厂模式

function createFactory(type,text){
    var o  = new Object()
    o.content = text
    o.show = function(){
        console.log(o.content)
    }
    if(type == 'a'){
        o.content = text + "666"
    }
    if(type == 'b'){
      o.content = text + "888"
    }    
  return o

}

var test = createFactory('a','2333')
test.show()

```

### 优点
* 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。
* 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
* 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

### 缺点

* 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
* 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
* 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
* 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

### 适用环境

在以下情况下可以使用简单工厂模式：
* 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
* 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。

## 工厂方法模式(Factory Method Pattern)

通过对产品类的抽象使其创建业务主要负责于创建多类产品的实例。不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成，我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例。

工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

![imgn](http://haoqiao.qiniudn.com/6C869292-9380-4C95-AF93-521293095D45.png)

### 代码

```


var Factory = function(type, text) {
  if (this instanceof Factory) {
    this[type](text);
  } else {
    return new Factory(type, text);
  }
};

Factory.prototype = {
  javascript: function(text) {
    console.log(text + 'javascript');
  },
  nodejs: function(text) {
    console.log(text + 'nodejs');
  }
};

Factory('javascript', '万能的');

```

### 优点

* 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。
* 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。
* 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。

### 缺点

* 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
* 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。

### 适用环境

一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。

## 抽象工厂模式(Abstract Factory)

  通过对类的工厂抽象使其业务用于对产品类簇的创建 而不负责创建某一类产品的实例。
  
  抽象类的作用：定义一个产品簇，声明一些必备的方法，如果子类中没有去重写就会抛出错误。
  
  抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。
  ![imgn](http://haoqiao.qiniudn.com/83722450-D45D-4386-BA10-9382808B841E.png)
  
### 代码

```
var VehicleFactory = function(subClass, superType) {

  // 判断抽象工厂中是否有该抽象类
  if (typeof VehicleFactory[superType] === 'function') {

    // 缓存类
    function F() {}

    // 继承父类属性和方法
    F.prototype = new VehicleFactory[superType]();

    // 将子类constructor指向子类
    F.constructor = subClass;

    // 子类原型继承”父类“
    subClass.prototype = new F();
  } else {
    throw new Error('未创建该抽象类');
  }
};

// 小汽车抽象类
VehicleFactory.Car = function() {
  this.type = 'car';
};

VehicleFactory.Car.prototype = {
  getPrice: function() {
    return new Error('抽象方法不能调用');
  },
  getSpeed: function() {
    return new Error('抽象方法不能调用');
  }
};

// 公交车抽象类
VehicleFactory.Bus = function() {
  this.type = 'bus';
};

VehicleFactory.Bus.prototype = {
  getPrice: function() {
    return new Error('抽象方法不能调用');
  },
  getSpeed: function() {
    return new Error('抽象方法不能调用');
  }
};

// 货车抽象类
VehicleFactory.Truck = function() {
  this.type = 'truck';
};

VehicleFactory.Truck.prototype = {
  getPrice: function() {
    return new Error('抽象方法不能调用');
  },
  getSpeed: function() {
    return new Error('抽象方法不能调用');
  }
};

// 宝马汽车子类
var BMW = function(price, speed) {
  this.price = price;
  this.speed = speed;
};

VehicleFactory(BMW, 'Car');

BMW.prototype.getPrice = function() {
  return this.price;
};
BMW.prototype.getSpeed = function() {
  return this.speed;
};

var a = new BMW(100, 2);

console.log(a.getPrice());
console.log(a.type);

```

### 优点

* 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。
* 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。
* 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。、

### 缺点
  
* 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。
* 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。

### 适用环境

在以下情况下可以使用抽象工厂模式：
* 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。
* 系统中有多于一个的产品族，而每次只使用其中某一产品族。
* 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。
* 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

# 手写给出一个策略模式实现

策略模式（Strategy）：将定义的一组算法封装起来，使其相互之间可以替换。
封装的算法具有一定独立性，不会随客户端变化而变化。

策略模式最主要的特色是创建一系列策略算法，每组算法处理的业务都是相同的，
只是处理的过程或者处理的结果不一样，所以它们又是可以相互替换的，
这样就解决了算法与使用者之间的耦合。在测试层面上讲，由于每组算法相互之间的独立性，
该模式更方便与对每组算法进行单元测试，保证算法的质量。

![imgn](http://haoqiao.qiniudn.com/E08C1EB7-63E9-4001-9FBE-DB7B8936ACFF.png)

## 模式动机

* 完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。
* 在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。
* 在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。
* 除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。
* 为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。

## 代码

```

// 背景：过节商品打折，一部分商品5折出售，一部分8折出售，一部分商品9折出售，等到元旦，我们要搞一个幸运反馈活动，普通用户满100返30，高级VIP用户满100返50... 

// 价格策略对象
var PriceStrategy = (function() {
  // 内部算法对象
  var stragtegy = {

    // 100返30
    return30: function(price) {
      return +price + parseInt(price / 100) * 30;
    },

    // 满100返50
    return50: function(price) {
      return +price + parseInt(price / 100) * 50;
    },

    // 九折
    percent90: function(price) {
      return 90 / 100 * +price;
    },

    // 八折
    percent80: function(price) {
      return 80 / 100 * +price;
    },

    // 五折
    percent50: function(price) {
      return 50 / 100 * +price;
    }
  };

  // 策略算法调用接口
  return function(algorithm, price) {
    // 如果算法存在，则调用算法，否则返回false
    return stragtegy[algorithm] && stragtegy[algorithm](price);
  }
})();

var price = PriceStrategy('return50', '314.67');
console.log(price); // 464.67

var InputStrategy = (function() {
  var strategy = {
    isNumber: function(value) {
      return Object.prototype.toString.call(value) === '[object Array]';
    },
    phone: function(value) {
      return /^1[3578]\d{9}$/.test(value);
    }
  };

  return {
    check: function(type, value) {
      // 去除首尾空白符
      value = value.replace(/^\s+|\s+$/g, '');

      return strategy[type] ? strategy[type](value) : '没有该类型的检测方法';
    },

    // 添加策略
    addStrategy: function(type, fn) {
      strategy[type] = fn;
    }
  }
})();

InputStrategy.addStrategy('mail', function(value) {
  return /^(\w+)(@\w+)(\.\w+)+$/.test(value);
});

var is = InputStrategy.check('mail', 'abc@gmail.com');

console.log(is);


```

## 优点

1. 策略模式封装了一组代码族，并且封装的代码相互之间独立，便于对算法的重复引用，提高了算法的复用率
2. 策略模式与继承相比，在类的继承中继承的方法是被封装在类中，因此当需求很多算法时，就不得不创建出多种类，
这样会导致算法与算法的使用者耦合在一起，不利于算法的独立演化，并且在类的外部改变类的算法难度也是极大的。
3. 同状态模式一样，策略模式也是一种优化分支判断语句的模式，采用策略模式对算法封装使得算法更利于维护。

## 缺点

由于选择哪种算法的决定权在用户，所以对用户来说就必须了解每种算法的实现。
这就增加了用户的使用成本。其次，由于每种算法间相互独立，
这样对于一些复杂的算法处理相同逻辑的部分无法实现共享，这就会造成一些资源的浪费。

## 适用环境

在以下情况下可以使用策略模式：
* 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。
* 一个系统需要动态地在几种算法中选择一种。
* 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。
* 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。


# 手写给出一个装饰者模式实现

在不改变原对象的基础上，通过对其进行封装扩展（添加属性和方法）使原有对象可以满足用户的更复杂的需求。

同样对原有对象进行扩展的还有适配器模式，所不同的是适配器进行扩展很多时候是对对象内部的重组，
因此了解其自身结构是必须的。而装饰者对对象的扩展是一种良性扩展，不用了解其具体实现，
只是在外部进行了一次封装扩展，这又是对原有功能完整性的一种保护。


![imgn](http://haoqiao.qiniudn.com/ECF534D1-2ABC-471B-9FAC-6DA7D4D38C85.png)

## 模式动机

一般有两种方式可以实现给一个类或对象增加行为：
* 继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。
* 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)
装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机。

## 代码

```


// 装饰者
var decorate = function(id, fn) {
  // 获取事件源
  var dom = document.getElementById(id);

  // 若事件源已绑定事件
  if (typeof dom.onclick === 'function') {

    // 缓存事件源原有事件
    var oldClickFn = dom.onclick;

    // 为事件源定义新的事件
    dom.onclick = function() {
      // 事件源原有回调函数
      oldClickFn();
      // 执行事件源新增回调函数
      fn();
    };

  } else {
    // 如果未绑定事件，直接为事件源添加事件
    dom.onclick = fn;
  }
};



// 电话输入框功能装饰
decorate('tel_input', function() {
  document.getElementById('tel_demo_text').style.display = 'none';
});


// 与适配器模式的区别：
// 适配器方法使对原有对象适配，添加的方法与原有方法功能上大致相似。但是装饰者提供的方法与原来的方法功能项是有一定区别的。
// 在装饰者模式中，不需要了解对象原有的功能，而且对象原有的方法照样可以原封不动的使用
// 在适配器中增加的方法要调用原有的方法，
// 需要了解原有方法实现的具体细节，
// 而在装饰者中原封不动的使用，不需要知道原有方法实现的具体细节。
//

```

## 优点

* 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。
* 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。
* 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。
* 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”

## 缺点

* 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。
* 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。


## 适用环境

* 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
* 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。
* 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）.

# 建造者模式

将一个复杂对象的构件层与其表示层相互分离，同样的构建过程可以用不同的表示。

对整体对象的拆分增加了结构的复杂性，如果对象粒度很小，或者模块间复用率很低还是直接创建整体对象比较好。

## 模式动机

复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。

建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。

![imgn](http://haoqiao.qiniudn.com/36D71B0F-1F0B-42EA-A050-9F87A40FA333.png)

## 代码

```

var Human = function(param) {

  // 技能
  this.skill = param && param.skill || '保密';

  // 兴趣爱好
  this.hobby = param && param.hobby || '保密';
};

Human.prototype = {
  getSkill: function() {
    return this.skill;
  },
  getHobby: function() {
    return this.hobby;
  }
};

// 实例化姓名类
var Named = function(name) {
  var that = this;

  // 构造器
  // 构造函数解析姓名的姓与名
  (function(name, that) {
    that.wholeName = name;

    if (name.indexOf(' ') > -1) {
      that.firstName = name.slice(0, name.indexOf(' '));
      that.secondName = name.slice(name.indexOf(' '));
    }
  })(name, that)
};

// 实例化职位类
var Work = function(work) {
  var that = this;

  // 构造器
  // 构造函数中通过传入的职位特征来设置相应职位以及描述
  (function(work, that) {
    switch(work) {
      case 'code':
        that.work = '工程师';
        that.workDescript = '每天沉醉于编程';
        break;
      case 'UI':
      case 'UE':
        that.work = '设计师';
        that.workDescript = '设计更似一种艺术';
        break;
      case 'teach':
        that.work = '教师';
        that.workDescript = '分享也是一种快乐';
        break;
      default:
        that.work = work;
        that.workDescript = '对不起，我们还不清楚您所选择职位的相关描述';
    }
  })(work, that);
};

// 更换期望的职位
Work.prototype.changeWork = function(work) {
  this.work = work;
}

// 添加对职位的描述
Work.prototype.changeDescript = function(des) {
  this.workDescript = des;
};


/**
 * 应聘者建造者
 *
 * @param name 姓名（全名）
 * @param work 期望职位
 */
var Person = function(name, work) {
  // 创建应聘者缓存对象
  var _person = new Human();

  // 创建应聘者姓名解析对象
  _person.name = new Named(name);

  // 创建应聘者期望职位
  _person.work = new Work(work);

  return _person;
};

var person = new Person('xiao ming', 'code');
console.log(person)


```

## 优点

* 在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
* 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。
* 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
* 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。

## 缺点

* 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
* 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

## 适用环境

* 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。
* 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。
* 对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。
* 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。


# 单例模式

只允许实例化一次对象类。有时也用一个对象来规划一个命名空间。井井有条管理对象上的属性和方法。

单例模式的要点有三个：

一是某个类只能有一个实例；

二是它必须自行创建这个实例；

三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。

## 模式动机

一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。

![imgn](http://haoqiao.qiniudn.com/02466658-43C2-40E1-932D-E84C9ABC41B7.png)

## 代码

```

function $(id){
    return document.getElementById(id)
}

//  单例模式（创建命名空间）
var A = {
  Util: {
    util_method1: function() {},
    util_method2: function() {}
  },
  Tool: {
    tool_method1: function() {},
    tool_method2: function() {}
  },
  Ajax: {
    get: function() {},
    post: function() {}
  },
  others: {
    // ...
  }
};

A.Util.util_method2();
A.Tool.tool_method1();
A.Ajax.get();

//静态变量（无法修改的静态变量）
var Config = (function() {
  // 私有变量
  var config = {
    MAX_NUM: 100,
    MIN_NUM: 1,
    COUNT: 1000
  };

  // 返回取值器对象
  return {
    // 取值器方法
    get: function(name) {
      return config[name] ? config[name] : null;
    }
  }
})();

var count = Config.get('COUNT');


//惰性单例（有时候对于单例对象需要延迟创建，所以在单例中还存在一种延迟创建的形式，有人也称之为‘惰性创建’）
//
// 惰性载入单例
var LazySingle = (function() {

  // 单例实例引用
  var _instance = null;

  // 单例
  function Single() {
    // 这里定义私有属性和方法
    return {
      publicMethod: function() {},
      publicProperty: '1.0'
    }
  }

  return function() {

    if (!_instance) {
      _instance = Single();
    }

    // 返回单例
    return _instance;
  }
})();


console.log( LazySingle().publicProperty ); // 1.0
console.log( LazySingle() === LazySingle() ); // true

```

## 优点

* 提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。
* 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。
* 允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。

## 缺点

* 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。
* 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。
* 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。


## 适用环境

* 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。
* 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。
* 在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式

# 适配器模式

将一个类（对象）的接口（方法或属性）转化成另外一个接口，以满足用户需求。

类（对象）之间接口的不兼容问题可以通过适配器模式解决

## 模式动机

适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。

![imgn](http://haoqiao.qiniudn.com/BEC864A6-618A-4819-A353-1E6B06C9BA59.png)

## 代码

```


// 定义框架
var A = A || {};

// 通过id获取元素
A.g = function(id) {
  return document.getElementById(id);
};

// 背景：忽然项目中想把依赖换成jQuery，但总不能所有的方法都用jQuery的语法重新写一遍，那就写个适配器吧~
A.g = function(id) {
  // 通过jQuery获取jQuery对象，然后返回第一个成员
  return $(id).get(0);
};



// 背景：如果方法需要传入很多参数，那么记住这些参数的顺序是很难的，所以我们经常是以一个参数对象方式传入的。

function a(name, title, age, color, size, prize) {}

/*
 * obj.name: name
 * obj.title: title
 * obj.age: age
 * obj.color: color
 * obj.size: size
 * obj.prize: prize
 */

function a(obj) {}

 // 但是调用它的时候不知道传递的参数是否完整，此时我们通常的做法是用适配器来适配传入的参数对象

function a(obj) {
  var _default = {
    name: '雨夜清荷',
    title: '设计模式',
    age: '20',
    color: 'pink',
    size: 100,
    prize: 50
  };

  for (var i in obj) {
    _default[i] = obj[i] || _default[i];
  }

  // code ....
}


// 数据适配,将无语义的数据构造适配成语义化的数据结构。


function arrToObj(arr) {
  return {
    name: arr[0],
    type: arr[1],
    title: arr[2],
    data: arr[3]
  };
}

var arr = ['javascript', 'book', '前端编程语言', '12月1日'];

var obj = arrToObj(arr);

console.log(obj);

```

## 优点

* 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。
* 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。
* 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。
类适配器模式还具有如下优点：
由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。
对象适配器模式还具有如下优点：
一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。

## 缺点


类适配器模式的缺点如下：
对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。
对象适配器模式的缺点如下：
与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。


## 适用环境

* 系统需要使用现有的类，而这些类的接口不符合系统的需要。
* 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

# 桥接模式

在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦

桥接模式先抽象提取公共部分，然后将实现和抽象通过桥接方法链接在一起，实现解耦的作用。

桥接模式主要的特点是将实现层(如元素绑定的事件)与抽象层(修饰页面UI逻辑)解耦分离，使两部分可以独立编号。

主要对结构之间的解耦。

在javascript更多的利用this的特效，this只接受直接调用者支配。

## 模式动机

设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：
* 第一种设计方案是为每一种形状都提供一套各种颜色的版本。
* 第二种设计方案是根据实际需要对形状和颜色进行组合
对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。

![imgn](http://haoqiao.qiniudn.com/607519CD-B44E-488D-B045-C4A340E925FA.png)


## 代码

```


var spans = document.getElementsByTagName('span');

spans[0].onmouseover = function() {
  this.style.color = 'red';
  this.style.background = '#ddd';
};
spans[0].onmouseout = function() {
  this.style.color = '#333';
  this.style.background = '#f5f5f5';
};

spans[1].onmouseover = function() {
  this.getElementsByTagName('strong')[0].style.color = 'red';
  this.getElementsByTagName('strong')[0].style.background = '#ddd';
};
spans[1].onmouseout = function() {
  this.getElementsByTagName('strong')[0].style.color = '#333';
  this.getElementsByTagName('strong')[0].style.background = '#f5f5f5';
};

// 使用桥接模式后
function changeColor(dom, color, bg) {
  dom.style.color = color;
  this.style.background = bg;
}

// 事件与业务逻辑的桥梁
spans[0].onmouseover = function() {
  changeColor(this, 'red', '#ddd');
};
spans[0].onmouseout = function() {
  changeColor(this, '#333', '#f5f5f5');
};



// 多维变量类
// 运动单元
function Speed(x, y) {
  this.x = x;
  this.y = y;
}
Speed.prototype.run = function() {
  console.log('跑起来');
};

// 着色单元
function Color(cl) {
  this.color = cl;
}
Color.prototype.draw = function() {
  console.log('绘制色彩');
};


function Ball(x, y, c) {
  // 实现运动单元
  this.speed = new Speed(x, y);
  // 实现着色单元
  this.color = new Color(c);
};
Ball.prototype.init = function() {
  // 实现运动
  this.speed.run();
  // 实现着色
  this.color.draw();
};

var a = new Ball(1,2,'red');
a.init();

```

## 优点

* 分离抽象接口及其实现部分。
* 桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。
* 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。
* 实现细节对客户透明，可以对用户隐藏实现细节。


## 缺点

* 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 
* 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。

## 适用环境

在以下情况下可以使用桥接模式：
* 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。
* 抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。
* 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。
* 虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。
* 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。


# 外观模式

为一组复杂的子系统接口提供了一个更高级的统一接口，通过这个接口对子系统接口的访问更容易。

常见是兼容事件的封装。


## 模式动机

外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。

## 代码

```

// 外观模式实现
function addEvent(dom, type, fn) {

  if (dom.addEventListener) {
    dom.addEventListener(type, fn, false);
  } else if (dom.attachEvent) {
    dom.attachEvent('on' + type, fn);
  } else {
    dom['on' + type] = fn;
  }
}

var myInput = document.getElementById('myinput');

addEvent(myInput, 'click', function() {
  console.log('绑定第一个事件');
});

addEvent(myInput, 'click', function() {
  console.log('绑定第二个事件');
});

```

## 优点

```

* 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。
* 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。
* 降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。
* 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。

```

## 缺点

```

* 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。
* 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。

```

## 适用环境

* 当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。
* 客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。
* 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。


# 享元模式

享元模式（Flyweight），运行共享技术有效地支持大量细粒度的对象，避免对象拥有相同内容造成多余的开销，
使大家共享一个类(元类)。

也是将公共属性/方法抽象出来。谁需要谁去继承。

享元模式的精髓就在于『创建对象的同时，缓存一份对象，日后直接对缓存的对象做操作』

## 模式动机

面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。
* 享元模式正是为解决这一类问题而诞生的。享元模式通过共享技术实现相同或相似对象的重用。
* 在享元模式中可以共享的相同内容称为内部状态(IntrinsicState)，而那些需要外部环境来设置的不能共享的内容称为外部状态(Extrinsic State)，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。
* 在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池(Flyweight Pool)用于存储具有相同内部状态的享元对象。
* 在享元模式中共享的是享元对象的内部状态，外部状态需要通过环境来设置。在实际使用中，能够共享的内部状态是有限的，因此享元对象一般都设计为较小的对象，它所包含的内部状态较少，这种对象也称为细粒度对象。享元模式的目的就是使用共享技术来实现大量细粒度对象的复用。

![imgn](http://haoqiao.qiniudn.com/7951087F-511E-44D1-A00C-5983FD917C7A.png)


## 代码

```

// 背景：分页新闻功能

// 享元对象
var Flyweight = (function() {
  // 已创建的元素
  var created = [];

  /*
   * 创建一个新闻包装容器
   * 根据我自己对享元模式的理解，享元模式的精髓就在于『创建对象的同时，缓存一份对象，日后直接对缓存的对象做操作』
   */
  function create() {
    var dom = document.createElement('div');
    // 讲容器插入新闻列表容器中
    document.getElementById('container').appendChild(dom);
    // 缓存新创建的元素
    created.push(dom);
    // 返回创建的新元素
    return dom;
  }

  return {
    // 获取创建新闻元素方法
    getDiv: function() {
      // 如果已创建的元素小于当前页元素总个数，则创建
      if (created.length < 5) {
        return create();
      } else {
        // 获取第一个元素并插入到最后面
        var div = created.shift();
        created.push(div);
        return div;
      }
    }
  };
})();


// 实现需求
var paper = 0;
var num = 5;
var article = ['这是第一条新闻','这是第二条新闻','这是第三条新闻','这是第四条新闻','这是第五条新闻','这是第六条新闻'];
var len = article.length;

// 添加五条新闻
for (var i = 0; i < 5; i++) {
  if (article[i]) {
    // 通过享元类获取创建的元素并写入新闻内容
    Flyweight.getDiv().innerHTML = article[i];
  }
}

// 下一页
document.getElementById('next').onclick = function() {
  // 如果新闻内容不足5条则返回
  if(article.length < 5) return;

  var n = ++paper * num % len;

  // 插入5条新闻
  for (var j = 0; j < 5; j++) {
    // 如果存在第n+j条则插入
    if (article[n + j]) {
      Flyweight.getDiv().innerHTML = article[n + j];
    } else if(article[n + j - len]) {
      // 否则插入起始位置第n + j - len 条
      Flyweight.getDiv().innerHTML = article[n + j - len];
    } else {
      // 如果都不存在则插入空字符串
      Flyweight.getDiv().innerHTML = '';
    }
  }
}

```

## 优点

* 享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。
* 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。

## 缺点

* 享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
* 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。

## 适用环境

* 一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。
* 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
* 使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。


# 代理模式

由于一个对象不能直接引用另一个对象，通过代理对象起到中介作用。

// 典型例子如： Jsonp跨域解决方案 
// 比如延迟加载一些资源。图片的懒加载。用代理方式先加载一张预览图片。等用户需要的时候替换成真实图片。


## 模式动机

在某些情况下，一个客户不想或者不能直接引用一个对 象，此时可以通过一个称之为“代理”的第三者来实现 间接引用。代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。

通过引入一个新的对象（如小图片和远程代理 对象）来实现对真实对象的操作或者将新的对 象作为真实对象的一个替身，这种实现机制即 为代理模式，通过引入代理对象来间接访问一 个对象，这就是代理模式的模式动机。

![imgn](http://haoqiao.qiniudn.com/4DE945BE-06F1-478F-B58C-2B7CAD637ACB.png)

## 代码

## 优点

* 代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。
* 远程代理使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。
* 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系 统资源的消耗，对系统进行优化并提高运行速度。
* 保护代理可以控制对真实对象的使用权限。

## 缺点

* 由于在客户端和真实主题之间增加了代理对象，因此 有些类型的代理模式可能会造成请求的处理速度变慢。
* 实现代理模式需要额外的工作，有些代理模式的实现 非常复杂。

## 适用环境

* 远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地 的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在 另一台主机中，远程代理又叫做大使(Ambassador)。
* 虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。
* Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个 开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。
* 保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。
* 缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。
* 防火墙(Firewall)代理：保护目标不让恶意用户接近。
* 同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。
* 智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。


# 命令模式

将请求与实现解耦，并封装成独立对象，从而使不同的请求对客户端的实现参数化。

命令模式是将执行的命令封装，解决命令的发起者与命令的执行者之间的耦合。

每一条命令实质上是一个操作。命令的使用者不必要了解命令的执行者（命令对象）的命令接口是如何实现的，命令式如何接收的，命令式如何执行的。所有的命令都被存储在命令对象中。

命令模式的有点自然是解决命令使用者之间的耦合。新的命令很容易加入到命令系统中，供使用者使用。

命令的使用具有一致性，多数的命令在一定程度上是简化操作方法的使用的。

命令模式是对一些操作的封装，这就造成每执行一次操作都要调用一次命令对象，增加了系统的复杂度。

## 模式动机

在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。
命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。

![imgn](http://haoqiao.qiniudn.com/914AD7AE-AD2B-42DB-899B-DF2E1BF66E30.png)

## 代码

```


/*
 * 实现模块
 */
var ViewCommand = (function() {

  // 模板
  var tpl = {
    product: [
      '<div>',
        '<img src="{#src#}" />',
        '<p>{#text#}</p>',
      '</div>'
    ].join(''),

    title: [
      '<div class="title">',
        '<div class="main">',
          '<h2>{#title#}</h2>',
          '<p>{#tips#}</p>',
        '</div>',
      '</div>'
    ].join(''),
  };

  var html = '';

  // 替换数据
  function formatString(str, obj) {
    return str.replace(/\{#(\w+)#\}/g, function(match, key) {
      return obj[key];
    });
  }

  // 方法集合
  var Action = {
    create: function(data, view) {
      // 如果是数字则把数组中的每一项加进html中
      if (Object.prototype.toString.call(data) === '[object Array]') {
        for (var i = 0; i < data.length; i++) {
          html += formatString(tpl[view], data[i]);
        }
      } else {
        html += formatString(tpl[view], data);
      }
    },
    display: function(container, data, view) {
      // 如果有数据，根据数据创建视图
      if (data) this.create(data, view);

      document.getElementById(container).innerHTML  = html;
      html = '';
    }
  };

  return function excute(command) {
    command.param = Object.prototype.toString.call(command.param) === '[object Array]' ? command.param : [command.param];
    Action[command.cd].apply(Action, command.param);
  }
})();


/*
 * 测试
 */

// 产品展示数据
var productData = [{
  src: 'command/02.jpg',
  text: '绽放的桃花'
},{
  src: 'command/03.jpg',
  text: '阳光下的温馨'
},{
  src: 'command/04.jpg',
  text: '镜头前的绿色'
}];

// 模块标题数据
var titleData = {
  title: '夏日里的一片温馨',
  tips: '暖暖的温情带给人们家的感受'
};

ViewCommand({
  cd: 'display',
  param: ['title', titleData, 'title']
});

ViewCommand({
  cd: 'create',
  param: [{
    src: 'command/01.jpg',
    text: '迎着朝阳的野菊花'
  }, 'product']
});

ViewCommand({
  cd: 'display',
  param: ['product', productData, 'product']
});


/*
 * 测试HTML
 *
 * <div id="title"></div>
 * <div id="product"></div>
 */


```

## 优点

* 降低系统的耦合度。
* 新的命令可以很容易地加入到系统中。
* 可以比较容易地设计一个命令队列和宏命令（组合命令）。
* 可以方便地实现对请求的Undo和Redo。

## 缺点

* 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。

## 适用环境

* 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。
* 系统需要在不同的时间指定请求、将请求排队和执行请求。
* 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。
* 系统需要将一组操作组合在一起，即支持宏命令

# 中介者模式

通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低它们之间的耦合。有时中介者对象也可改变对象之间的交互。

中介者是单向的，类似于执行某个事件，然后所有订阅过该事件的都会执行。

## 模式动机

* 在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：
* 系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。
* 对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。
* 系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。
* 在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。
* 对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机。

![imgn](http://haoqiao.qiniudn.com/BD7F86E3-9293-4E5E-BCE0-1C178F55AD6A.png)

## 代码

```


// 中介者对象
var Mediator = (function() {
  // 消息对象
  var _msg = {};

  return {
    subscribe: function(type, action) {
      if (_msg[type]) {
        _msg[type].push(action);
      } else {
        _msg[type] = [];
        _msg[type].push(action);
      }
    },

    send: function(type) {
      if (_msg[type]) {
        for (var i = 0; i < _msg[type].length; i++) {
          _msg[type][i] && _msg[type][i]();
        }
      }
    }
  };
})();

// 单元测试

// 订阅
Mediator.subscribe('demo', function() {
  console.log('first');
});

Mediator.subscribe('demo', function() {
  console.log('second');
});

Mediator.send('demo');






// 中介者对象
var Mediator = (function() {
  // 消息对象
  var _msg = {};

  return {
    subscribe: function(type, action) {
      if (_msg[type]) {
        _msg[type].push(action);
      } else {
        _msg[type] = [];
        _msg[type].push(action);
      }
    },

    send: function(type) {
      if (_msg[type]) {
        for (var i = 0; i < _msg[type].length; i++) {
          _msg[type][i] && _msg[type][i]();
        }
      }
    }
  };
})();

/*
 * 显示隐藏导航小组件
 *
 * mod 模块
 * tag 标签
 * showOrHide 显示还是隐藏
 */
var showHideNavWidget = function(mod, tag, showOrHide) {
  var mod = document.getElementById(mod);
  var tag = mod.getElementsByTagName(tag);
  var showOrHide = (!showOrHide || showOrHide === 'hide') ? 'hidden' : 'visible';

  // 占位隐藏这些标签
  for (var i = 0; i < tag.length; i ++) {
    tag[i].style.visibility = showOrHide;
  }
};

/*
 * 用户手册导航模块
 */
(function() {
  // 订阅 隐藏用户收藏导航信息提醒消息
  Mediator.subscribe('hideAllNavNum', function() {
    showHideNavWidget('collection_nav', 'b', false);
  });

  // 订阅 显示用户收藏导航信息提醒消息
  Mediator.subscribe('showAllNavNum', function() {
    showHideNavWidget('collection_nav', 'b', true);
  });

  // 订阅 隐藏用户收藏导航网址消息
  Mediator.subscribe('hideAllNavUrl', function() {
    showHideNavWidget('collection_nav', 'span', false);
  });

  // 订阅 显示用户收藏导航网址消息
  Mediator.subscribe('showAllNavUrl', function() {
    showHideNavWidget('collection_nav', 'span', true);
  });
})();

/*
 * 推荐用户导航
 */
(function() {
  // 订阅 隐藏推荐用户导航消息提醒消息
  Mediator.subscribe('hideAllNavNum', function() {
    showHideNavWidget('recommend_nav', 'b', false);
  });

  // 订阅 显示推荐用户导航消息提醒消息
  Mediator.subscribe('showAllNavNum', function() {
    showHideNavWidget('recommend_nav', 'b', true);
  });
})();

/*
 * 最近常用导航
 */
(function() {
  // 订阅 隐藏最近常用导航网址消息
  Mediator.subscribe('hideAllNavUrl', function() {
    showHideNavWidget('recently_nav', 'span', 'hide');
  });

  // 订阅 显示最近常用导航网址消息
  Mediator.subscribe('showAllNavUrl', function() {
    showHideNavWidget('recently_nav', 'span', 'show');
  });
})();


/*
 * 设置层模块
 */
(function() {
  // 消息提醒选框
  var hideNum = document.getElementById('hide_num');
  var hideUrl = document.getElementById('hide_url');

  // 消息提醒选框事件
  hideNum.onchange = function() {
    if (hideNum.checked) {
      Mediator.send('hideAllNavNum');
    } else {
      Mediator.send('showAllNavNum');
    }
  };

  // 网址选框事件
  hideUrl.onchange = function() {
    if (hideUrl.checked) {
      Mediator.send('hideAllNavUrl');
    } else {
      Mediator.send('showAllNavUrl');
    }
  };
})();



/*
 * 测试html
 *

网址 <input type="checkbox" id="hide_num">
url <input type="checkbox" id="hide_url">

<div id="collection_nav">
    用户手册导航模块
    <b>b</b>
    <span>span</span>
</div>

<div id="recommend_nav">
    推荐用户导航
    <b>b</b>
</div>

<div id="recently_nav">
    最近常用导航
    <span>span</span>
</div>
*/

```

## 优点

* 简化了对象之间的交互。
* 将各同事解耦。
* 减少子类生成。
* 可以简化各同事类的设计和实现。

## 缺点

在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。

## 适用环境

* 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。
* 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。
* 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象。
* 交互的公共行为，如果需要改变行为则可以增加新的中介者类。

# 状态模式

当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。

主要是将条件判断的不同结果转为状态对象的内部状态。

## 模式动机

在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。

![imgn](http://haoqiao.qiniudn.com/214C85B7-B3BA-4A22-8D03-1A53F0F4BDAC.png)


## 代码

```


'use strict';

// 超级玛丽的例子

// 创建超级玛丽状态类
var MarryState = function() {
  var _currentState = {};

  // 动作与状态方法映射
  var states = {
    jump: function() {
      // 跳跃
      console.log('jump');
    },
    move: function() {
      // 移动
      console.log('move');
    },
    shoot: function() {
      // 射击
      console.log('shoot');
    },
    squat: function() {
      // 蹲下
      console.log('squat');
    }
  };

  // 动作控制类
  var Action = {
    changeState: function() {
      var arg = arguments;

      // 重置内部状态
      _currentState = {};

      if (arg.length) {
        for (var i = 0; i < arg.length; i++) {
          _currentState[arg[i]] = true;
        }
      }

      return this;
    },

    goes: function() {
      console.log('触发一次动作');

      for (var i in _currentState) {
        states[i] && states[i]();
      }

      return this;
    }
  };

  return {
    change: Action.changeState,
    goes: Action.goes
  };
};


// 两种执行方式，可以直接执行状态类，也可以实例化状态类
// 直接执行状态类：如果直接使用实例化类就只能自己使用，如果还有另一个人使用，就可能会修改状态类内部的状态
// 实例化状态类：实例化状态类有一个好处就是 它是对状态类的复制，无论怎么使用，都不会影响我，
var marry = new MarryState();

marry.change('jump', 'shoot').goes().goes().change('shoot').goes();


```

## 优点

* 封装了转换规则。
* 枚举可能的状态，在枚举状态之前需要确定状态种类。
* 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。
* 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。
* 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。

## 缺点

* 状态模式的使用必然会增加系统类和对象的个数。
* 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。
* 状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。

## 适用环境

* 对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。
* 代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。

