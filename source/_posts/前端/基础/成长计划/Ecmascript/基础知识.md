---
title: JS基础
toc: true
date: 2017-10-16  10:35:12
tags: [前端,Javascript,JS基础]
---
## 数组

### 检测数组

```

//判断一个对象是不是数组
var arr = []

if(arr instanceof Array){} // 方法一

if(Object.prototype.toString.call(arr) == '[object Array]')}{} // 方法二

if(Array.isArray(arr)){} //方法三

if(arr.constructor == Array){} // 方法四


```

### 数组方法

>Array.from(arrayLike, mapFn, thisArg)

>该方法从一个类似数组或可迭代对象创建一个新的数组实例。参数 arrayLike 是想要转换成真实数组的类数组对象或可遍历对象。mapFn 是可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。thisArg是可选参数，为执行 mapFn 函数时 this 的值。

>所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组。
实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。


```

 
let arrayLike = {
    0: 'a',
    1: 'b',
    2: 'c',
    length: 3
}
let arrayLike2 = {length: 3}
let str = 'abcd'
 
let newArray = Array.from(arrayLike) //['a', 'b', 'c']
let newArray2 = Array.from(arrayLike, (v) => v+'1') //['a1', 'b1', 'c1']
let newArray3 = Array.from(arrayLike2) // [undefined, undefined, undefined]
let newArray4 = Array.from(str) // ['a', 'b', 'c', 'd']


```

### 数组合并

>Array.prototype.concat()方法

```

var arr = arr1.concat(arr2) //[1, 2, 3, 4]

```

>for循环和Array.prototype.push()

```

function flation(arr1, arr2) {
    for (var i = 0; i < arr2.length; i++) {
        arr1.push(arr2[i])
    }
    return arr1
}

```

>reduce()或reduceRight()方法


```


function flatten(arr1, arr2) {
    return arr2.reduce(function (prev, curr) {
        prev.push(curr)
        return prev
    }, arr1)
}

```

### 多维（复合）数组合并成一维数组

>Array.prototype.push()方法

```

function flatten(arr, result) {
    if (!result) {
        result = []
    }
    for (var i = 0; i < arr.length; i++) {
        if(arr[i].constructor == Array) {
            flatten(arr[i], r)
        } else {
            result.push(arr[i])
        }
    }
    return result
}
flatten([[1, 2], [3, 4, 5], [6, 7, 8, 9], [11,12,[12,13,[14]]], 10, 11])
//[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11]

```


>Array.prototype.concat()方法

```

//省略对二维以上数组的判断
function flatten(arr) {
    var result = []
    for (var i = 0; i < arr.length; i++) {
        result = result.concat(arr[i])
    }
    return result
}
flatten([[1, 2],[3, 4, 5], [6, 7, 8, 9]]);//[1, 2, 3, 4, 5, 6, 7, 8, 9] 
flatten([[1, 2],[3, 4, 5], [6, 7, 8, 9],10,11]);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]


```

>Function.prototype.apply()

```


//省略对二维以上数组的判断
function flatten(arr) {
    return Array.prototype.concat.apply([], arr)
}

 
//省略对二维以上数组的判断
function flatten(arr) {
    return [].concat.apply([], arr)
}
 

//省略对二维以上数组的判断
function flatten(arr) {
    return [].concat(...arr)
}

 
```

如果要处理三维或更多维数组，则需要加一些判断：

```


function flatten(arr) {
    arr = [].concat.apply([], arr)
    return arr.some(Array.isArray) ? flatten(arr) : arr
}
flatten([[1, 2], [3, 4, 5], [6, 7, 8, 9], [11,12,[12,13,[14]]], 10, 11])
//[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11]

```

>使用join()和split()

```


function flatten(arr) {
    return arr.join(',').split(',')
}
flatten([[1, 2], [3, 4, 5], [6, 7, 8, 9], [11,12,[12,13,[14]]], 10, 11])
//["1", "2", "3", "4", "5", "6", "7", "8", "9", "11", "12", "12", "13", "14", "10", "11"]
 
  这种方法的缺点在于返回的数组内全是字符串，如果不需要校验内容类型的话，可以使用这种方法。

```

### 数组去重

>双重循环去重

思路：

构建一个空数组来存放去重后的数组
对原数组做循环遍历，每次从数组中取出一个元素与结果数组做对比
如果原数组取出的元素与结果数组元素相同，则跳出循环；反之则将其存放到结果数组

```

function unique(arr) {
    var result = [arr[0]]
    for (var i = 1; i < arr.length; i++) {
        var repeat = false
        for (var j = 0; j < result.length; j++) {
            if (arr[i] == result[j]) {
                repeat = true
                break;
            }
        }
        if (!repeat) {
            result.push(arr[i])
        }
    }
    return result
}
 
unique([1, 2, 3, 4, 3, 2, 'a', 'b', 'a']);
//[1, 2, 3, 4, "a", "b"]
 
 
 ===
 
 function unique(arr) {
    var result = [arr[0]]
    arr.forEach(function(v) {
        if (result.indexOf(v) == -1) {  //这里 indexOf()也可替换为es7的includes()
            result.push(v)
        }
    })
    return result
}
unique([1, 2, 3, 4, 3, 2, 'a', 'b', 'a']);
//[1, 2, 3, 4, "a", "b"]

```

>对象键值对法

思路：

创建一个 js 对象及新数组
遍历原数组，每次取出一个元素与 js 对象的键作对比
如果不包含，将存入对象的元素的值推入到结果数组中，并将 object 对象中该属性名的值设为1

```

function unique(arr) {
    var result = []
    var object = {}
    for (var i = 0; i < arr.length; i++) {
        if (!object[typeof(arr[i]) + arr[i]]) {  //键名里加入typeof(arr[i])是为了区别不同类型的值，如1和`1`
            result.push(arr[i])
            object[typeof(arr[i]) + arr[i]] = 1
        }
    }
    return result
}
unique([1, 2, 3, 4, 3, 2, '1', 'a', 'b', 'a']);
//[1, 2, 3, 4, "a", "b"]


```

>使用 ES6 的 Set 和 Map 方法

```

//借助 Map 数据结构
function unique(arr) {
    const seen = new Map()
    return arr.filter((v)=> !seen.has(v) && seen.set(v, 1));
}
 
//借助 Set 数据结构
function unique(arr) {
    return Array.from(new Set(arr)) //或 return [...new Set(arr)]
}
 
unique([1, 2, 3, 4, 3, 2, '1', 'a', 'b', 'a']);
//[1, 2, 3, 4, "1", "a", "b"]

```

### 取数组中最大值最小值

遍历比较方法

思路：

设一个变量存放最大值，将数组中第一个值赋值给该变量
遍历数组与最大值变量比较，如果大于最大值，则将该值赋值最大值变量
遍历结束后，变量里储存的就是数组里的最大值

```

Array.prototype.max = function() {
    var max = this[0]
    this.forEach(function(v) {
        if (v > max) {max = v}
    })
    return max
}
[1,45,23,3,6,2,7,234,56].max() // 234


```


归并比较方法
思路：

使用数组实例的 reduce(function(prev, curv, index, arr)) 方法
依次比较回调函数中参数 prev 与 curv 的大小，返回大的那个

```


Array.prototype.max = function() {
    return this.reduce(function(prev, curv) {
        return prev > curv ? prev : curv
    })
}
[1,45,23,3,6,2,7,234,56].max() // 234

```

利用 Math.max() 与 Math.min() 方法

```

Array.prototype.max = function() {
    return Math.max.apply({},this) //或 return Math.max(...this)
}
[1,45,23,3,6,2,7,234,56].max() // 234

```

## 函数声明和函数定义

### 知识点

函数声明和函数定义的区别

### 函数声明背景资料

函数声明定义一个具有指定参数的函数。

你还可以使用  Function 构造函数和 一个function expression 定义函数。

一个被函数声明创建的函数是一个 `Function 对象`，具有 Function 对象的所有属性、方法和行为。查看 Function 以获取 function 的详细信息。

### 函数定义背景资料

function 关键字可以用来在一个表达式中定义一个函数。

函数表达式（function expression）非常类似于函数声明（function statement），并且拥有几乎相同的语法。函数表达式与函数声明的`最主要区别是函数名称`（function name），在函数表达式中可忽略它，从而创建匿名函数（anonymous functions）。一个函数表达式可以被用作一个IIFE（即时调用的函数表达式），它一旦定义就运行。更多信息请查看函数。

函数定义表达式和通过var声明变量一样，其函数被提前到了脚本或函数的顶部，因此它在整个脚本和或函数内都是可见的。这样的话，只有函数变量声明提前了，函数的初始化代码仍然在原来的位置。

### 两者区别

```

   test(1);

　　function test(x){

　　　　console.log(x);

　　}
　　
```
　　上述代码能正常执行，结果输出为1；因为对于`函数声明语句，函数名称和函数体均提前声明了，可以在声明之前调用它。`

　
```

　　test(1);

　　var test = function(x){

　　　　console.log(x);

　　}

```
　　上述代码不能正常执行，会报错。

　　因为对于函数定义表达式，只有函数变量声明提前了，但是函数的初始化代码仍然在原来的位置，也即相当于如下的代码

```

　　var test;   //函数变量声明提前

　　test(1);

　　var test = function(x){

　　　　console.log(x);

　　}

```


## 事件队列与定时器

### 知识点
> setTimeout与window.requestAnimationFrame相比有什么区别.JavaScript内部定时器和事件队列的原理


### setTimeout 背景资料

> setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。

```

除了前两个参数，setTimeout还允许添加更多的参数。它们将被传入推迟执行的函数（回调函数）。

setTimeout(function(a,b){
  console.log(a+b);
},1000,1,1);

上面代码中，setTimeout共有4个参数。最后那两个参数，将在1000毫秒之后回调函数执行时，作为回调函数的参数。

```

>如果被setTimeout推迟执行的回调函数是某个对象的方法，那么该方法中的this关键字将指向全局环境，而不是定义时所在的那个对象。


{% codeblock lang:js %}

var x = 1;
var o = {
  x: 2,
  y: function(){
    console.log(this.x);
  }
};
setTimeout(o.y,1000);// 1


{% endcodeblock %}

### setTimeout运行机制

>setTimeout和setInterval的运行机制是，将指定的代码移出本次执行，等到下一轮Event Loop时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮Event Loop时重新判断。这意味着，setTimeout指定的代码，必须等到本次执行的所有代码都执行完，才会执行。
每一轮Event Loop时，都会将“任务队列”中需要执行的任务，一次执行完。setTimeout和setInterval都是把任务添加到“任务队列”的尾部。因此，它们实际上要等到当前脚本的所有同步任务执行完，然后再等到本次Event Loop的“任务队列”的所有任务执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行

#### setTimeout(func,0)

`setTimeout(f,0)将第二个参数设为0，作用是让f在现有的任务（脚本的同步任务和“任务队列”中已有的事件）一结束就立刻执行。也就是说，setTimeout(f,0)的作用是，尽可能早地执行指定的任务。`

setTimeout(f,0)指定的任务，最早也要到下一次Event Loop才会执行

{% codeblock lang:js %}

setTimeout(function() {
  console.log("Timeout");
}, 0);
function a(x) {
  console.log("a() 开始运行");
  b(x);
  console.log("a() 结束运行");
}
function b(y) {
  console.log("b() 开始运行");
  console.log("传入的值为" + y);
  console.log("b() 结束运行");
}
console.log("当前任务开始");
a(42);
console.log("当前任务结束");
// 当前任务开始
// a() 开始运行
// b() 开始运行
// 传入的值为42
// b() 结束运行
// a() 结束运行
// 当前任务结束
// Timeout

{% endcodeblock %}

>上面代码说明，setTimeout(f,0)必须要等到当前脚本的所有同步任务结束后才会执行。
0毫秒实际上达不到的。根据HTML5标准，setTimeOut推迟执行的时间，最少是4毫秒。如果小于这个值，会被自动增加到4。这是为了防止多个setTimeout(f,0)语句连续执行，造成性能问题。
另一方面，浏览器内部使用32位带符号的整数，来储存推迟执行的时间。这意味着setTimeout最多只能推迟执行2147483647毫秒（24.8天），超过这个时间会发生溢出，导致回调函数将在当前任务队列结束后立即执行，即等同于setTimeout(f,0)的效果。

#### setTimeout(f,0)应用

网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，我们先让父元素的事件回调函数先发生，就要用到setTimeout(f, 0)。

{% codeblock lang:js %}

var input = document.getElementsByTagName('input[type=button]')[0];
input.onclick = function A() {
  setTimeout(function B() {
    input.value +=' input';
  }, 0)
};
document.body.onclick = function C() {
  input.value += ' body'
};

{% endcodeblock %}

{% jsfiddle xwdmpyz3 %}

用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，keypress事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。

{% codeblock lang:js %}

document.getElementById('input-box').onkeypress = function(event) {
  this.value = this.value.toUpperCase();
}

{% endcodeblock %}

{% jsfiddle 88rur1L1 %}

上面代码想在用户输入文本后，立即将字符转为大写。但是实际上，它只能将上一个字符转为大写，因为浏览器此时还没接收到文本，所以this.value取不到最新输入的那个字符。只有用setTimeout改写，上面的代码才能发挥作用。


{% codeblock lang:js %}

document.getElementById('my-ok').onkeypress = function() {
  var self = this;
  setTimeout(function() {
    self.value = self.value.toUpperCase();
  }, 0);
}
{% endcodeblock %}

{% jsfiddle 6bqLo458 %}

### requestAnimationFrame 背景资料

>window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器调用指定的函数在下一次重绘之前更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。

### setTimeout与window.requestAnimationFrame相比有什么区别

1. 首先，当相应的浏览器窗口最小化，JavaScript 计时器在背景标签仍然持续运行。因此，浏览器继续运行看不见的动画，导致不必要的 CPU 和电池寿命的消耗。在移动设备尤其严重。
2. 比如说由于某些原因，回调函数占用太多时间，比你设定的时间要长。一旦计时器时间到了，它将排队执行 “下一次” 回调函数，甚至前一个还没执行完。这一过程不断重复，很快排队了几乎无数的计时器代码，导致浏览器不堪重负。图1 说明这一情况。

![imgn](http://haoqiao.qiniudn.com/figure1.png)

3. 假如你的回调函数执行时间没比设定时间长，setTimeout 和 setInterval 仍不是最理想的.两者只能以固定的频率重绘动画，为了让动画更平滑，我们谨慎起见，选择比屏幕刷新率略高的频率。这样导致不必要的绘制，在屏幕刷新率准备绘制动画结果之前，一些帧已经画过了，因此它们被丢弃了
 
 ![imgn](http://haoqiao.qiniudn.com/figure2.png)


### 事件队列
 
 
### 参考资料

>[你所不知道的setTimeout](https://jeffjade.com/2016/01/10/2016-01-10-javacript-setTimeout/)

>[CSS3动画那么强，requestAnimationFrame还有毛线用](http://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/)

> [requestAnimationFrame 性能更好](https://jinlong.github.io/2013/06/24/better-performance-with-requestanimationframe/)


>[Better JavaScript animations with requestAnimationFrame](https://www.nczonline.net/blog/2011/05/03/better-javascript-animations-with-requestanimationframe/)

### 事件队列

#### 浏览器端的事件队列

>JS运行在浏览器中，是单线程的， 在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。 而浏览器是事件驱动的（ Event driven），浏览器中很多行为是异步（ Asynchronized）的，会创建事件并放入执行队列中。 javascript引擎是单线程处理它的任务队列， 你可以理解成就是普通函数和回调函数构成的队列。
当异步事件发生时， 如mouse click, a timer firing, or an XMLHttpRequest completing（ 鼠标点击事件发生、 定时器触发事件发生、 XMLHttpRequest完成回调触发等）， 将他们放入执行队列， 等待当前代码执行完成
Ajax请求确实是异步的， 这请求是由浏览器新开一个线程请求， 事件回调的时候是放入Event loop单线程事件队列等候处理

通常所说的 JavaScript Engine 是指负责执行一个一个 chunk 的程序，它依赖宿主环境的调度，也需要通过宿主环境与操作系统产生关联并得到支持。JavaScript Engine 是 JavaScript Runtime(Hosting Environment) 的一部分。
每个 chunk 通常是以 function 为单位，一个 chunk 执行完成后，才会执行下一个 chunk。下一个 chunk 是什么呢？取决于当前 Event Loop Queue 中的队首。Event Loop Queue 中存放的都是消息，每个消息关联着一个函数，JavaScript Engine 就按照队列中的消息顺序执行它们，也就是执行 chunk。


`Job Queue`

Job 是 ES6 中新增的概念，它与 Promise 的执行有关，可以理解为等待执行的任务；Job Queue 就是这种类型的任务的队列。JavaScript Runtime 对于 Job Queue 与 Event Loop Queue 的处理有所不同。

相同点：

都用作先进先出队列

相异点：

每个 JavaScript Runtime 可以有多个 Job Queue，但只有一个 Event Loop Queue
当 JavaScript Engine 处理完当前 chunk 后，优先执行所有的 Job Queue，然后再处理 Event Loop Queue

ES6 中，一个 Promise 就是一个 PromiseJob，一种 Job。

{% codeblock lang:js %}

console.log("A");

setTimeout(() => {
  console.log("A - setTimeout");
}, 0);

new Promise((resolve) => {
  resolve();
})
.then(() => {
  return console.log("A - Promise 1");
})
.then(() => {
  return console.log("B - Promise 1");
});

new Promise((resolve) => {
  resolve();
})
.then(() => {
  return console.log("A - Promise 2");
})
.then(() => {
  return console.log("B - Promise 2");
})
.then(() => {
  return console.log("C - Promise 2");
});

console.log("AA");

{% endcodeblock %}

```

在原生支持 Promise 的环境，输出是这样：
A
AA
A - Promise 1
A - Promise 2
B - Promise 1
B - Promise 2
C - Promise 2
A - setTimeout

```

理解这个输出：

A 与 AA 最先输出，因为它们不是异步任务，属于第一个 chunk。

Promise 1 与 Promise 2 先于 setTimeout 执行，因为 Job Queue 的执行优先于 Event Loop Queue。

Promise 1 与 Promise 2 各自的输出都是顺序的，因为 Job Queue 是先进先出队列，同一 Job Queue 中的任务顺序执行。

Promise 1 与 Promise 2 的后续任务是交错的，因为 Promise 1 与 Promise 2 都是独立的 

PromiseJob（job 的其中一种），属于不同的 Job Queue，它们之间的顺序规范中没有规定。

```
JavaScript Engine 对 JavaScript 程序的执行是单线程的，但是 JavaScript Runtime（整个宿主环境）并不是单线程的；而且，几乎所有的异步任务都是并发的，例如多个 Job Queue、Ajax、Timer、I/O(Node)等等。
上面说的是 JavaScript Runtime 层面，JavaScript 执行本身，也有一些特殊情况，例如：一个 Web Worker 或者一个跨域的 iframe，也是独立的线程，有各自的内存空间（栈、堆）以及 Event Loop Queue。要与这些不同的线程通信，只能通过 postMessage。一次 postMessage 就是在另一个线程的 Event Loop Queue 中加入一条消息。

```

JavaScript的主线程在遇到异步调用时，这些异步调用会立刻返回某个值，从而让主线程不会在此处阻塞。而真正的异步操作会由浏览器执行，主线程则会在清空当前调用栈后，按照先入先出的顺序读取任务队列里面的任务。而 JavaScript 中的任务又分为 `MacroTask` 与 `MicroTask` 两种，在 ES2015 中 MacroTask 即指 `Task`，而 MicroTask 则是指代 `Job`。典型的 MacroTask 包含了 `setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering` 等，MicroTask 包含了 `process.nextTick, Promises, Object.observe, MutationObserver` 等。 二者的关系可以图示如下：

![imgn](http://haoqiao.qiniudn.com/MicroTaskandmacrotask.jpg)


参考 whatwg 规范(参考文档已给出) 中的描述：一个事件循环(Event Loop)会有一个或多个任务队列(Task Queue，又称 Task Source)，这里的 Task Queue 就是 MacroTask Queue，而 Event Loop 仅有一个 MicroTask Queue。每个 Task Queue 都保证自己按照回调入队的顺序依次执行，所以浏览器可以从内部到JS/DOM，保证动作按序发生。而在 Task 的执行之间则会清空已有的 MicroTask 队列，在 MacroTask 或者 MicroTask 中产生的 MicroTask 同样会被压入到 MicroTask 队列中并执行。参考如下代码：


{% codeblock lang:js %}

function foo() {
  console.log("Start of queue");
  bar();
  setTimeout(function() {
    console.log("Middle of queue");
  }, 0);
  Promise.resolve().then(function() {
    console.log("Promise resolved");
    Promise.resolve().then(function() {
      console.log("Promise resolved again");
    });
  });
  console.log("End of queue");
}

function bar() {
  setTimeout(function() {
    console.log("Start of next queue");
  }, 0);
  setTimeout(function() {
    console.log("End of next queue");
  }, 0);
}

foo();

// 输出
Start of queue
End of queue
Promise resolved
Promise resolved again
Start of next queue
End of next queue
Middle of queue

{% endcodeblock %}


关于Tasks, microtasks, queues and schedules比较直观的了解可以参考资料里的链接。

> [event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)

> [JavaScript 中的异步：Event Loop 及其他](https://zhuanlan.zhihu.com/p/22710155)


>[Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)


>[ecma262官方规范](http://www.ecma-international.org/ecma-262/6.0/#sec-performpromisethen)


>[task-queue](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue)

#### Node端的事件队列

> Node.js依赖libev来提供event loop，使用线程池来提供异步I/O。

Libuv默认使用四个线程创建一个线程池来执行异步工作。今天的操作系统已经为许多I/O任务提供了异步接口（例如Linux上的AIO）。
只要有可能，libuv将使用这些异步接口，避免使用线程池。这同样适用于像数据库这样的第三方子系统。在这里，驱动程序宁愿使用异步接口，而不是使用线程池。
简而言之：只有没有其他方式，线程池将用于异步I/O。

Node.js中你的代码运行在单线程之中.单线程没法让代码并行执行。但是所有I/O操作都是事件驱动、并行的.

`Node事件循环原理图`

![imgn](http://haoqiao.qiniudn.com/Ticks%20and%20Phases%20of%20the%20Node.js%20Event%20Loop.png)

1.Timers

通过setTimeout()或setInterval()调度的所有内容将在此处处理。

2.IO Callbacks

这里将处理大部分的回调。
由于Node.js中的所有用户代码基本上都处于回调（例如，对传入http请求的回调触发级联的回调），这是用户级代码。

3.IO Polling(轮询)
  对下一次要处理的新事件进行轮询。
  
4.Set Immediate
  运行所有通过setImmediate注册的回调，也就是立刻执行。
  
5.Close

这里处理所有on（'close'）事件回调。


`事件循环就是一个典型的生产者消费者模型，由请求生产，事件循环消费，这个循环由 IOCP / 多线程创建。
`

首先我们引入请求对象的概念，JavaScript 层传入的参数和方法都被封装在请求对象中，当有可用线程时，我们就会调用对象底层对应的方法。

组装好请求对象，送入`线程池`等待执行，这就完成了我们的第一步。

执行结束后，将会将结果存储，并且调用方法通知 IOCP 将线程交还给线程池。

之后事件循环观察到执行完的请求，进行处理即可。

整个流程如图（摘自深入浅出 Node.js）：

![imgn](http://haoqiao.qiniudn.com/2773128744.jpg)




>[event-loop-timers-and-nexttick](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)

>[Process.nextTick 和 setImmediate 的区别](https://www.zhihu.com/question/23028843)


 >[你应该知道什么才能真正了解Node.js事件循环](https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c)


>[Node.js 异步原理](https://codesky.me/archives/nodejs-asynchronous-principle.wind)

## Microtask 与 Macrotask

1. 一个浏览器环境（unit of related similar-origin browsing contexts.）只能有一个事件循环（Event loop），而一个事件循环可以多个任务队列（Task queue），每个任务都有一个任务源（Task source）。例如,客户端可能实现了一个包含鼠标键盘事件的任务队列，还有其他的任务队列，而给鼠标键盘事件的任务队列更高优先级，例如75%的可能性执行它。这样就能保证流畅的交互性，而且别的任务也能执行到了。但是，同一个任务队列中的任务必须按先进先出的顺序执行。多个任务队列，是为了方便控制优先级。任务队列是一个先进先出的队列.
2. macrotask 和 microtask 是异步任务的两种分类。在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。
3. 全部代码(script)是一个macrotask,js先执行一个macrotask,执行过程中遇到(setTimeout, setInterval, setImmediate等)异步操作则创建一个macrotask,遇到(process.nextTick, Promises等)创建一个microtask,这两个queue分别被挂起.执行栈为空时开始处理macrotask,完成后处理microtask,直到该microtask全部执行完,然后继续主线程调用栈.



##  前端PV和UV统计的实现

  PV(访问量)：Page View, 即页面浏览量或点击量，用户每次刷新即被计算一次。

　UV(独立访客)：Unique Visitor,一般使用cookie标记,访问您网站的一台电脑客户端(比如一台电脑开多个浏览器访问则为多个UV)为一个访客，00:00-24:00内相同的客户端只会被计算一次。

　　IP(独立IP)：指独立IP数。00:00-24:00内相同IP地址之被计算一次(多台电脑可能共用一个ip)。

标记和采集数据。监控js被加载后就会往浏览器写入cookie标记访客，比如新访客生产一个新cookie和标记访问次数，若是老用户则，读取 cookie信息，计算访问次数和最后访问时间等，这些客户端的信息处理完后，则向指定的服务器发送数据。

## 实现bind方法，写出 polyfill

```

if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs   = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP    = function() {},
        fBound  = function() {
          return fToBind.apply(this instanceof fNOP
                 ? this
                 : oThis,
                 // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的
                 aArgs.concat(Array.prototype.slice.call(arguments)));
        };

    // 维护原型关系
    if (this.prototype) {
      // Function.prototype doesn't have a prototype property
      fNOP.prototype = this.prototype; 
    }
    fBound.prototype = new fNOP();

    return fBound;
  };
}

```

```

Function.prototype.bind2 = function (context) {

    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}

```


## 箭头函数的应用场景

使用bind()函数或者需要固定上下文的地方现在使用箭头函数会让代码更加简洁.

在写连续的Promise链式调用时，可以使代码更加优雅.



所以当this是由目标对象决定时，我们应该使用函数表达式：

在需要动态上下文的地方不能使用箭头函数，使用构造函数创建对象时不能使用箭头函数.

```

var calculate = {  
  array: [1, 2, 3],
  sum: () => {
    console.log(this === window); // => true
    return this.array.reduce((result, item) => result + item);
  }
};
console.log(this === window); // => true  
// Throws"TypeError: Cannot read property 'reduce' of undefined"
calculate.sum();

```

>calculate.sum使用箭头函数来定义，但是调用 calculate.sum() 时出现了异常。因为当执行sum的时候上下文仍然是window，这是因为箭头函数已经绑定了window做为上下文。

>执行this.array 等同于 window.array ,当然是 undefined


解决办法就是不要在对象的方法上使用箭头函数短语法，这样this关键字会在调用时决定，而不是早早绑定在闭合的上下文中

```

var calculate = {  
  array: [1, 2, 3],
  sum() {
    console.log(this === calculate); // => true
    return this.array.reduce((result, item) => result + item);
  }
};
calculate.sum(); // => 6


```


## ES6 的 Class 继承和 ES5 有什么不同？

Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承。


```

class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }

  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }
}

class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

class ColorPoint extends Point {
  constructor(x, y, color) {
    this.color = color; // ReferenceError
    super(x, y);
    this.color = color; // 正确
  }
}

在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。

```

ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。


```

function Super() {}
 
function Sub() {}
Sub.prototype = new Super();
Sub.prototype.constructor = Sub;
 
var sub = new Sub();
 
Sub.prototype.constructor === Sub; // ② true
sub.constructor === Sub; // ④ true
sub.__proto__ === Sub.prototype; // ⑤ true
Sub.prototype.__proto__ == Super.prototype; // ⑦ true

```

## ES6 的模块化解决了哪些问题？如何进行编译的？

[module](http://es6.ruanyifeng.com/#docs/module-loader)

ES6模块有以下两个最主要的优点：

它们是跨平台的，无论在浏览器还是Node.js中都可以正常执行。

import 和 export 都是静态方法，只有这么实现我们才能知道依赖载入是如何工作的。因为 runtime 会先载入文件，解析它然后我们需要在执行之前载入依赖，只有将它们实现成静态方法才能做到。意味着你不能使用import 'engine-' + browserVersion这种语法。这种方式有一个好处：工具可以静态分析代码，找出哪一部分代码确实被使用了然后按需加载这部分代码(tree shake it)。当在使用第三方库的时候这是非常有用的：你不可能使用它们提供的所有方法，所以你可以删除许多没有执行的代码。


### ES6 模块与 CommonJS 模块的差异


讨论 Node 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。

它们有两个重大差异。

CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。

ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

