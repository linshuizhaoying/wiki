---
title: 模块化
toc: true
date: 2017-07-12  10:58:50
tags: [前端,Javascript,模块化]
---


## AMD

全称”Asynchronous Module Definition”，称为异步模块加载规范


规范其实只有一个主要接口 define(id?, dependencies?, factory)，它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置

优点：

* 适合在浏览器环境中异步加载模块
* 可以并行加载多个模块
缺点：

* 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅
* 不符合通用的模块化思维方式，是一种妥协的实现
实现：

* RequireJS

一般应用在浏览器端提前执行依赖 - 尽早执行
requireJS 是它的实现

>AMD依赖前置，js可以方便知道依赖模块是谁，立即加载

>AMD 同样都是异步加载模块，AMD在加载模块完成后就会执行该模块（不是回调函数），所有模块都加载执行完后才会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。
## CMD

>全称”Common Module Definition”，称为通用模块加载规范

* 按需执行依赖 - 懒执行，seaJS 是它的实现


## AMD和CMD的区别

AMD和CMD最大的区别是对依赖模块的执行时机处理不同

>CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块

>CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的

## CommonJS

该规范的核心思想是允许模块通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口

优点：

* 服务器端模块便于重用
* NPM 中已经有将近20万个可以使用模块包
* 简单并容易使用
缺点：

* 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的
* 不能非阻塞的并行加载多个模块

## ES6 模块

>ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。

CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。

