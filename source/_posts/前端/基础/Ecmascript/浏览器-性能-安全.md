---
title: 浏览器-性能-安全
toc: true
date: 2017-07-13  12:51:28
tags: [前端,Javascript,浏览器-性能-安全]
---

# 安全

## XSS
>跨站脚本攻击是一种针对网站应用程序的安全漏洞攻击，是代码注入的一种，类似于SQL注入。XSS漏洞的存在允许作为站点合法用户将代码注入到网页上，接着浏览器渲染页面时会试行一些不被预期的脚本指令，使用该网页的用户就会受到不良影响甚至严重危害

>防范xss的关键是过滤所有的‘《’和‘》’字符，确保从后端而来的数据并不带有任何的html标签，xss的危险在于有不可预料的前端脚本


### CSRF

跨站请求伪造是一种对信任网站的恶意利用，通过伪装来自受信任用户的请求来利用信任网站进行某种用户不知道的、甚至有害的操作

>在HTTP请求中加入随机数，无法正常伪造请求


### https为什么更安全

`https = http和SSL/TLS组队`

SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
（1）如何保证公钥不被篡改？
解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。
（2）公钥加密计算量太大，如何减少耗用的时间？
解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。
因此，SSL/TLS协议的基本过程是这样的：
（1） 客户端向服务器端索要并验证公钥。
（2） 双方协商生成"对话密钥"。
（3） 双方采用"对话密钥"进行加密通信。

`SSL/TLS提供了身份验证、加密和签名等安全措施来保护用户和服务器之间的数据传输  `

`https是用来加密网络上传输的数据，不对数据内容做验证`

## 请描述一下 GET 和 POST 的区别

* get 向指定的资源请求数据,请求的数据会附在URL 之后,就是把数据放置在请求行（request line）中），以?分割URL和传输数据，多个参数用&连接；

* get 请求是安全,get 操作不会修改服务器的数据  

* get 请求发送数据更小

* get 能被缓存，post 不能被缓存

* post 向指定的资源提交要被处理的数据。get 方法，查询请求是在url中显示的，有长度限制，get 方法是安全幂等的。而post 方法请求是封装在http 消息包体中

## cookie 和 session 的区别

>cookie 和session的区别是：cookie数据保存在客户端，session数据保存在服务器端。
cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式。  
cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。
不重要的信息以cookie形式存放，重要的token以session方式存放

# 性能

## 回流和重绘

* repain(重绘)
 当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain

* 减少重绘

合适的网页分层技术以减少需要重新计算的布局和绘图
使用css 3d变形和动画技术

* reflow(回流)
 DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow
    
>减少回流、重绘其实就是需要减少对render tree的操作（合并多次多DOM和样式的修改），并减少对一些style信息的请求，尽量利用好浏览器的优化策略 
            
            
## display:none和visibility：hidden会产生回流与重绘吗？

>display：none指的是元素完全不陈列出来，不占据空间，涉及到了DOM结构，故产生reflow与repaint  

>visibility：hidden指的是元素不可见但存在，保留空间，不影响结构，故只产生repaint

## 浏览器缓存,HTTP缓存控制

 * 整体缓存策略
  * 1.先看看有没有设置expires,Cache-control
  * 2.对比缓存时间，如果过期了
  * 3.对比上次响应的Etag和本次请求的，如果没变读取缓存，变了更新
  * 4.Last-Modified 对比文件最后修改日期，如果没变，读取缓存，变了更新

>对于浏览器端的缓存来讲，这些规则是在HTTP协议头和HTML页面的Meta标签中定义的。他们分别从新鲜度和校验值两个维度来规定浏览器是否可以直接使用缓存中的副本，还是需要去源服务器获取更新的版本

### HTTP

  * Cache-control策略
  * 指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据
  * Cache-Control的max-age规定了缓存有效时间（2552s）
  * 如果max-age和Expires同时存在，前者优先级高于后者
  * ETag/If-None-Match
  * 当客户端发现和服务器约定的直接读取缓存的时间过了，就在请求中发送If-None-Match选项，值即为上次请求后响应头的ETag值，该值在服务端和服务端代表该文件唯一的字符串对比（如果服务端该文件改变了，该值就会变），如果相同，则相应HTTP304，客户端直接读取缓存，如果不相同，HTTP200，下载正确的数据，更新ETag值
   
   * 如果两者同时存在，If-None-Match优先，忽略If-Modified-Since
   
   * Last-Modified/If-Modified-Since
   
   * 将If-Modified-Since的日期和服务端该文件的最后修改日期对比，如果相同，则响应HTTP304，从缓存读数据；如果不相同文件更新了，HTTP200，返回数据，同时通过响应头更新last-Modified的值（以备下次对比）

>新鲜度（过期机制）：也就是缓存副本有效期。一个缓存副本必须满足以下条件，浏览器会认为它是有效的，足够新的： 含有完整的过期时间控制头信息（HTTP协议报头），并且仍在有效期内；浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度


###  Expires策略

  * Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。
  * Expires规定了缓存失效时间


### 浏览器可以并行下载多少个资源

1. IE6 2 个并发  
2. iE7 升级之后的 6 个并发，之后版本也是 6 个  
3. Firefox，chrome 也是6个

## 性能优化的具体思路

1. 减少请求

2. 减小传输体积

3. 尽可能利用缓存

4. 缩短关键路径

5. 合理安排请求顺序

## css等静态文件放在其他域名下的好处

比如图片CSS等静态文件放在静态资源服务器上并配置单独域名，客户端请求静态文件的时候，减少COOKIE反复传输时对主域名的影响。

## 前端性能优化的方法

（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。  

  避免链接重定向、避免错误的链接请求。建立多次链接、多次 DNS 解析，阻碍 DNS 预取技术。  

（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数  

（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。  

（4） 当需要设置的样式很多时设置className而不是直接操作style。  

（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。  

（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。  

（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。


### CDN加速的原理

>CDN加速将网站的内容缓存在网络边缘（离用户接入网络最近的地方），然后在用户访问网站内容的时候，通过调度系统将用户的请求路由或者引导到离用户接入网络最近或者访问效果最佳的缓存服务器上，有该缓存服务器为用户提供内容服务；相对于直接访问源站，这种方式缩短了用户和内容之间的网络距离，从而达到加速的效果



### 如何优化Cookie

* 减小大小
* 去除不必要的 Cookie；尽量压缩 Cookie 大小；注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；设置合适的过期时间。
* 静态资源使用无 Cookie 域名
* 把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度

### 域名收敛

域名收敛的意思就是建议将静态资源只放在一个域名下面，而非发散情况下的多个域名下。

DNS 解析其实是一个很复杂的过程，在 PC 上，我们采用域名发散策略，是因为在 PC 端上，DNS 解析通常而言只需要几十 ms ，可以接受。而移动端，2G 网络，3G网络，4G网络/wifi 强网，而且移动 4G 容易在信号不理想的地段降级成 2G ，通过大量的数据采集和真实网络抓包分析（存在DNS解析的请求），DNS的消耗相当可观

在移动网络环境下，减少非必要 DNS 请求，将相关域名收敛成一个，可以尝到缓存的红利，进而可以减少打开页面时间
移动端减少 DNS 解析时间有两种方式：

1. 减少 DNS 请求
2. 缩短 DNS 解析路径

从上面的各种网络环境下 DNS 解析时间对比，减少 DNS 请求是我们做域名收敛的主要原因


### 白屏时间计算

白屏时间是用户首次看到内容的时间，也叫做首次渲染时间，chrome 高版本有 firstPaintTime 接口来获取这个耗时，但大部分浏览器并不支持

白屏时间出现在头部外链资源加载完附近，因为浏览器只有加载并解析完头部资源才会真正渲染页面。基于此我们可以通过获取头部资源加载完的时刻来近似统计白屏时间。尽管并不精确，但却考虑了影响白屏的主要因素：

首字节时间和头部资源加载时间。

目前普遍使用的白屏时间统计方案是在html文档的head中所有的静态资源以及内嵌脚本/样式之前记录一个时间点，在head最底部记录另一个时间点，两者的差值作为白屏时间

{% codeblock lang:html %}

<html>
<head>
<meta charset="UTF-8"/>
<!--这里还有一大串meta信息-->
<script>
var start_time = new Date();//统计起点，实际为html开始解析的时间节点
</script>
<link href='a.css'></link>
<script src='a.js'></script>
<script>
var end_time = new Date();//统计起点，实际为html开始解析的时间节点
</script>
</head>
<body>
</body>
</html>

{% endcodeblock %}


### 首屏时间计算

多久首屏渲染完成(包含图片等元素加载完成)。

![imgn](http://www.alloyteam.com/wp-content/uploads/2016/01/QQ%E6%88%AA%E5%9B%BE20160109164815.png)

在每个点打上一个时间戳，首屏时间 = 点8 – 点1；

首屏线处埋点标记，然后计算标记点之前所有图片加载完成的时间，把这个时间作为首屏时间

通过统计首屏内图片的加载时间便可以获取首屏渲染完成的时间。统计流程如下：

首屏位置调用 API 开始统计 -> 绑定首屏内所有图片的 load 事件 -> 页面加载完后判断图片是否在首屏内，找出加载最慢的一张 -> 首屏时间

目前应用比较广的方案是将首屏的图片、iframe等资源添加onload事件，获取最慢的一个。

这种方案比较适合首屏元素数量固定的页面，比如移动端首屏不论屏幕大小都展示相同数量的内容，响应式得改变内容的字体、尺寸等。但是对于首屏元素不固定的页面，这种方案并不适用，最典型的就是PC端页面，不同屏幕尺寸下展示的首屏内容不同。上述方案便不适用于此场景。

# 其他

## url长度为什么受限制

>http 1.1 协议中对url的长度是不受限制

限制它长度的是浏览器和服务端的限制。

>nginx，所以强调下它的设置参数：
>`large_client_header_buffers`

>该参数对nginx服务器接受客户端请求的头信息时所分配的最大缓冲区的大小做了限制，也就是nginx服务器一次接受一个客户端请求可就收的最大头信息大小。这个头不仅包含 request-line，还包括通用信息头、请求头域、响应头域的长度总和。这也相当程度的限制了url的长度。
  
  nginx服务器默认的限制是4K或者8K，这是根据服务器的硬件配置有关的，一般为内存一页的大小，目前大部分为4K，即4096字节。


