---
title: 正则
toc: true
date: 2017-07-13  12:51:28
tags: [前端,Javascript,正则]
---


## var exp = /pattern/flags

flags
g:全局模式，应用于所有字符串，不会匹配到第一个就停，一直匹配到结束

i:不区分大小写模式

m:多行模式，到达一行文本末尾还需继续查找下一行

## 元字符: ( [ { \ ^ $ | ) ? * + . ] }

都需要转义匹配

##  特殊字符

###  \

```

 非特殊字符之前的反斜杠表示下一个字符是特殊

 模式 /a*/ 代表会匹配 0 个或者多个 a。
 相反，模式 /a\*/ 将 '*' 的特殊性移除，从而可以匹配像 "a*" 这样的字符
 
```


### ^
匹配输入的开始

/^A/ 并不会匹配 "an A" 中的 'A'，但是会匹配 "An E" 中的 'A'

### $
匹配输入的结束

/t$/ 并不会匹配 "eater" 中的 't'，但是会匹配 "eat" 中的 't'

### *
匹配前一个表达式0次或多次。等价于 {0,}

### +
匹配前面一个表达式1次或者多次。等价于 {1,}。

例如，/a+/匹配了在 "candy" 中的 'a'，和在 "caaaaaaandy" 中所有的 'a'。

### ?

```
 匹配前面一个表达式0次或者1次。等价于 {0,1}。

例如，/e?le?/ 匹配 "angel" 中的 'el'，和 "angle" 中的 'le' 以及"oslo' 中的'l'。

如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。
 
对 "123abc" 应用 /\d+/ 将会返回 "123"，如果使用 /\d+?/,那么就只会匹配到 "1"。

```

### 小数点 .
匹配除换行符之外的任何单个字符

### (x)

```

匹配 'x' 并且记住匹配项，就像下面的例子展示的那样。括号被称为 捕获括号

模式 /(foo) (bar) \1 \2/ 中的 '(foo)' 和 '(bar)' 匹配并记住字符串 "foo bar foo bar" 中前两个单词。模式中的 \1 和 \2 匹配字符串的后两个单词。注意 \1、\2、\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，'bar foo'.replace( /(...) (...)/, '$2 $1' )

```

### {n}

n是一个正整数，匹配了前面一个字符刚好发生了n次。

比如，/a{2}/不会匹配“candy”中的'a',但是会匹配“caandy”中所有的a，以及“caaandy”中的前两个'a'

### {n,m}
n 和 m 都是正整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。

例如，/a{1, 3}/ 并不匹配“cndy”中得任意字符，匹配“candy”中得a，匹配“caandy”中得前两个a，也匹配“caaaaaaandy”中得前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。

### (?:x)
匹配 'x' 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式。 来看示例表达式 /(?:foo){1,2}/。 如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。 如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。

### x(?=y)
匹配'x'仅仅当'x'后面跟着'y'.这种叫做正向肯定查找。

例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。

### x(?!y)
匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。

/\d+(?!\.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\d+(?!\.)/.exec("3.141")匹配‘141’但是不是‘3.141’

### x|y
 匹配‘x’或者‘y’。

### [xyz]
一个字符集合。匹配方括号的中任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的

[abcd] 和[a-d]是一样的。他们都匹配"brisket"中得‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\w.]+/都匹配“test.i.ng”中得所有字符

### [^xyz]
一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的

[^abc] 和 [^a-c] 是一样的。他们匹配"brisket"中得‘r’，也匹配“chop”中的‘h’。

### \b

```

匹配一个词的边界。一个词的边界就是一个词不被另外一个词跟随的位置或者不是另一个词汇字符前边的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0（不要和[\b]混淆了）

例子： /\bm/匹配“moon”中得‘m’；  

```


### [\b]
匹配一个退格(U+0008)。（不要和\b混淆了。）

### \B
匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是单词或者都不是单词。一个字符串的开始和结尾都被认为是非单词。
 
例如，/\B../匹配"noonday"中得'oo', 而/y\B./匹配"possibly yesterday"中得’ye‘

### \d
匹配一个数字。 等价于[0-9]。

/\d/或者/[0-9]/匹配"B2 is the suite number."中的'2'

### \D
匹配一个非数字字符。 等价于[^0-9]。

/\D/或者/[^0-9]/匹配"B2 is the suite number."中的'B'

### \n
匹配一个换行符 (U+000A)

### \r
`匹配一个回车符 (U+000D)`

### \s
匹配一个空白字符，包括空格、制表符、换页符和换行符。

### \S
匹配一个非空白字符 

### \W
匹配一个非单字字符

## 方法

exec

一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）

test
一个在字符串中测试是否匹配的RegExp方法，它返回true或false。

match

一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null

search

一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1

replace

一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串

split
 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法

## 正则例子

{% jsfiddle jsrhpdke %}

