---
title: 基础
toc: true
date: 2017-07-12  20:32:59
tags: [前端,Javascript,基础]
---

## 基本类型

### 基本数据类型

`Undefined、 Null、 Boolean、 Number、 String `
ES6新增`symbol`
一个复杂数据类型 `Object`

举个应用场景，比如一个人名叫“张三”，他可能拥有两个国家甚至更多国家的国籍，因此会有多个身份 Id号。此时我们直观的做法就是加 Id 属性：

var person = {
name: "zhangsan",
id: "xttblog", // 可能多个
age: 20
}
也会有人说，用数组就好，那每个国家的 id 怎么获取？
var person = {
name: "zhangsan",
id: ["xttblog.com", 'codedq.net'] // 哪个是中国人身份证的 id ？
age: 20
} 
此时若是用 Symbol 便能很好的解决问题。因为传入对象属性时，同样的Symbol不相等。看下面：
Symbol('key') === Symbol('key') // false, 因为Symbol('key')
Symbol(‘key’) 两次的返回值是不同的，且是独一无二的值。现在解决上面的问题。
var person = {
name: "zhangsan",
age: 20
};
// Symbol('key') 生成引用类型，独一无二的，所以 chinaId 与 americaId 不等。
var chinaId = Symbol('id');
var americaId = Symbol('id');
person[chinaId] = "chinaId";
person[americaId] = "americaId";

#### Symbol
 
 symbol是程序创建并且可以用作属性键的值，并且它能避免命名冲突的风险。
 
 

### null， undefined 的区别

>null 表示一个对象是“ 没有值” 的值， 也就是值为“ 空”； ；
undefined 表示一个变量没有被声明， 不存在这个值， 或者被声明了但没有被赋值
null的类型(typeof) 是object
undefined的类型(typeof) 是undefined
除了NULL和Undefined 任何值都有toString() 方法
试图把这两者转为对象会抛出TypeError


### 内置函数

`hasOwnProperty()`
用于检查给定的属性在当前对象实例中(而不是在实例的原型中) 是否存在

`getPrototypeOf()` 方便取得一个对象的原型
对象的比较并非值的比较， 即使两个对象包含同样的属性和相同的值， 他们也不是相等的， 各个索引完全相等的两个数组也不相等。 他们的比较是引用的比较。

### 基本类型和引用类型

基本类型在内在中具有固定的大小
引用类型则不同
对象可以具有任意的长度,无固定大小。 数组也是

String Object是引用类型
基本类型变量存的是数据的具体值
而引用类型变量保存的是值的引用

### 动态属性

>不能给基本类型的值添加属性， 即使添加了也会消失。 因为创建的是临时对象， 赋值之后立刻销毁。


{% codeblock lang:js %}

var a = new Object();
a.name = “2333 "
console.log(a) VM327: 3 Object { name: "2333" }
undefined
var b = "666”;
b.name = “2333 "
console.log(b) VM363: 3 666 undefined
var b = "666”;
b.name = "2333” 
console.log(b.name)

{% endcodeblock %}


### 方法

* 栈方法
`push()` 接受任意数量的参数， 逐个添加到数组末尾

`pop()` 方法从数组末尾移除最后一项， 返回移除的项

* 队列方法

`shift()` 移除数组中第一项并返回该项

`unshift()` 在数组前端添加任意个项并返回新数组的长度 配合pop() 实现队列
操作方法


`concat() `
先创建当前数组的一个副本， 然后将接收到的参数添加到这个副本的末尾， 然后返回新构建的数组

`slice() `
基于当前数组中的一或者多个项创建新数组， 接受(起始位置， 结束位置。) 只有一个参数， 则指定开始到数组末尾。 如果有两个参数， 则起始位置到结束位置（ 不包括结束位置） slice() 不会影响原数组

`splice()`
删除： 指定删除的第一项位置和要删除的数量。 splice(0, 2) 删除前两项
插入: 可以向指定位置插入任意数量的项。 只需提供三个参数: 起始位置, 0(删除数量设为0), 要插入的任意数量的项.如splice(2, 0, ’red’, ’blue’) 在数组位置2插入两项。
替换: 向指定位置插入任意数量的项目， 同时删除任意数量的项。 插入数量和删除数量不用相等。 如splice(2, 1, ’red’, ’blue’) 会删除位置2的项， 然后从位置2开始插入新的数据。
始终返回被删除的数据， 如果没有删除任何项， 则返回空数组。 会改变原数组。
位置方法


`indexOf()` 接受两个参数: 查找的项， 查找起始位置, 没找到返回 - 1

`lastIndexOf()` 接受两个参数: 查找的项， 查找起始位置 倒序找， 没找到返回 - 1
迭代方法 这些方法都不会修改数组内原始的值
every() 对数组每一项运行给定函数， 如果该函数对每一项都返回 `true`，
则返回 `true`

some() 对数组每一项运行给定函数， 如果该函数对任意一项返回 `true`
则返回 `true`

`filter()` 对数组每一项运行给定函数， 返回 `true`的项组成的数组

`forEach() `对数组每一项运行给定函数, 没有返回值

`map()` 对数组每一项运行给定函数， 返回每次函式调用的结果组成的数组
归并方法

`reduce()`

迭代数组中所有项， 然后构建一个最终返回的值。
reduce 为数组中的每一个元素依次执行回调函数， 不包括数组中被删除或从未被赋值的元素
接受四个参数： 初始值（ 或者上一次回调函数的返回值）， 当前元素值， 当前索引， 调用 reduce 的数组
回调函数第一次执行时， previousValue 和 currentValue 的取值有两种情况， 如果 initialValue 在调用 reduce 时被提供， 那么第一个 previousValue 等于 initialValue， 并且currentValue 等于数组中的第一个值； 如果initialValue 未被提供， 那么previousValue 等于数组中的第一个值， currentValue等于数组中的第二个值
[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array) {
    return previousValue + currentValue; }); //10
reduceRight() 从数组末尾往前遍历


## 内置对象

### 数据封装类对象
Object、 Array、 Boolean、 Number 和 String
String类型

var s = 'linshuizhaoying,lin'
console.log(s.charAt(0)) //第一个字符 console.log(s.charAt(s.length -1)) //最后一个字符 console.log(s.substring(1,4)) //第2~4个字符 console.log(s.slice(-3)) //最后三个字符 console.log(s.indexOf('l')) //l第一次出现的位置 console.log(s.lastIndexOf('l')) //l最后一次出现的位置 console.log(s.split(',')) //分割成两个子串 console.log(s.replace('y', 'Y')) //全文字符替换 console.log(s.toUpperCase()) //大写
其他对象
Function、 Arguments、 Math、 Date、 RegExp、 Error
Date类型
new Date();
new Date(value);
new Date(dateString);
new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);
Date.now() 返回自 1970 - 1 - 1 00: 00: 00 UTC(时间标准时间) 至今所经过的毫秒数。 Date.parse() 解析一个表示日期的字符串， 并返回从 1970 - 1 - 1 00: 00: 00 所经过的毫秒数。 Date.UTC() 接受和构造函数最长形式的参数相同的参数（ 从2到7）， 并返回从 1970 - 01 - 01 00: 00: 00 UTC 开始所经过的毫秒数。 Date.prototype.getDate() 根据本地时间返回指定日期对象的月份中的第几天（ 1 - 31）。 Date.prototype.getDay() 根据本地时间返回指定日期对象的星期中的第几天（ 0 - 6）。 Date.prototype.getFullYear() 根据本地时间返回指定日期对象的年份（ 四位数年份时返回四位数字）。 Date.prototype.getHours() 根据本地时间返回指定日期对象的小时（ 0 - 23）。 Date.prototype.getMilliseconds() 根据本地时间返回指定日期对象的微秒（ 0 - 999）。 Date.prototype.getMinutes() 根据本地时间返回指定日期对象的分钟（ 0 - 59）。 Date.prototype.getMonth() 根据本地时间返回指定日期对象的月份（ 0 - 11）。 Date.prototype.getSeconds() 根据本地时间返回指定日期对象的秒数（ 0 - 59）。 Date.prototype.getTime() 返回从1970 - 1 - 1 00: 00: 00 UTC（ 协调世界时） 到该日期经过的毫秒数， 对于1970 - 1 - 1 00: 00: 00 UTC之前的时间返回负值。
var a = new Date() //Thu Sep 22 2016 10:50:26 GMT+0800 (CST) console.log(a.toDateString())//Thu Sep 22 2016 console.log(a.toTimeString())//10:51:25 GMT+0800 (CST) console.log(a.toUTCString())//Thu, 22 Sep 2016 02:51:25 GMT
Math对象
console.log(Math.pow(2, 3)) // 2的3次幂 console.log(Math.round(.6)) // 四舍五入 console.log(Math.ceil(.6)) // 向上求整 console.log(Math.floor(.6)) // 向下求整 console.log(Math.abs(-5)) // 求绝对值 var x = 1, y = 3, z = 2 console.log(Math.max(x,y,z)) // 返回最大值 console.log(Math.min(x,y,z)) // 返回最小值 console.log(Math.random()) // 生成随机数 console.log(Math.sqrt(3)) // 3的平方根
toFixed() 根据小数位后指定位数将数字转为字符串
函数也是一种特殊的对象





## js单线程

>JS运行在浏览器中， 是单线程的， 在某个特定的时刻只有特定的代码能够被执行， 并阻塞其它的代码。 而浏览器是事件驱动的（ Event driven）， 浏览器中很多行为是异步（ Asynchronized） 的， 会创建事件并放入执行队列中。 javascript引擎是单线程处理它的任务队列， 你可以理解成就是普通函数和回调函数构成的队列。
>当异步事件发生时， 如mouse click, a timer firing, or an XMLHttpRequest completing（ 鼠标点击事件发生、 定时器触发事件发生、 XMLHttpRequest完成回调触发等）， 将他们放入执行队列， 等待当前代码执行完成
Ajax请求确实是异步的， 这请求是由浏览器新开一个线程请求， 事件回调的时候是放入Event loop单线程事件队列等候处理


## ECMAScript： JavaScript的核心， 描述了语言的基本语法

## 文档对象模型（ DOM）： DOM（ 文档对象模型） 是 HTML 和 XML 的应用程序接口（ API）

## 设置css

```

oDiv.style.width = ‘300 px’;
oDiv.className = ‘active’;
批量设置样式 
oDiv.style.cssText = ‘width: 300 px;height: 300 px’;

```

## Dom

* getAttribute()
可以取得自定义特性

* setAttribute()
可以对dom节点设定自定义特性

* querySelector()
接受一个css选择符， 返回与该模式匹配的第一个元素。 没有返回Null

* querySelectorAll()
接受一个css选择符， 返回与该模式匹配的所有元素。 没有返回Null

```

document.querySelector('.test').classList.remove("test").remove('disabled') document.querySelector('.test').classList.add(...) //只会添加一次 document.querySelector('.test').classList.toggle(...) //有class则删除，没有添加

```

* getElementsByTagName()
通过标签名称

* getElementsByName()
通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)

* getElementById()
通过元素Id，唯一性 getElementsByClassName

### DOM操作
添加
appendChild()

移除
removeChild()

移动
replaceChild()
insertBefore() //在已有的子节点前插入一个新的子节点

创建
创建新节点 
createDocumentFragment() //创建一个DOM片段
createElement() //创建一个具体的元素
createTextNode() //创建一个文本节点

## DOM操作例子

如果要插入的 li 是 300 个

(() => {
    var ndContainer = document.getElementById('js-list');
    if (!ndContainer) {
        return;
    }

    for (let i = 0; i < 300; i++) {
        const ndItem = document.createElement('li');
        ndItem.innerText = i + 1;
        ndContainer.appendChild(ndItem);
    }

    ndContainer.addEventListener('click', function (e) {
        const target = e.target;
        if (target.tagName === 'LI') {
            alert(target.innerHTML);
        }
    });
})();


如果要在 ul 中插入 30000 个 li，会有什么问题？代码需要怎么改进？几乎可以肯定，页面体验不再流畅，甚至会出现明显的卡顿感，该怎么解决？

综合上面的分析，可以从减少 DOM 操作次数、缩短循环时间两个方面减少主线程阻塞的时间。减少 DOM 操作次数的良方是 DocumentFragment；而缩短循环时间则需要考虑使用分治的思想把 30000 个 <li> 分批次插入到页面中，每次插入的时机是在页面重新渲染之前

{% codeblock lang:js %}

(() => {
    const ndContainer = document.getElementById('js-list');
    if (!ndContainer) {
        return;
    }

    const total = 30000;
    const batchSize = 4; // 每批插入的节点次数，越大越卡
    const batchCount = total / batchSize; // 需要批量处理多少次
    let batchDone = 0;  // 已经完成的批处理个数

    function appendItems() {
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < batchSize; i++) {
            const ndItem = document.createElement('li');
            ndItem.innerText = (batchDone * batchSize) + i + 1;
            fragment.appendChild(ndItem);
        }

        // 每次批处理只修改 1 次 DOM
        ndContainer.appendChild(fragment);

        batchDone += 1;
        doBatchAppend();
    }

    function doBatchAppend() {
        if (batchDone < batchCount) {
            window.requestAnimationFrame(appendItems);
        }
    }

    // kickoff
    doBatchAppend();

    ndContainer.addEventListener('click', function (e) {
        const target = e.target;
        if (target.tagName === 'LI') {
            alert(target.innerHTML);
        }
    });
})();

{% endcodeblock %}


## DOM 中 Property 和 Attribute 的区别

* property是DOM中的属性,JavaScript里的对象
每个DOM节点都是一个object对象， 它可以像其他的js Object一样具有自己的property和method， 所以property的值可以是任何数据类型，大小写敏感

* attribute是HTML标签上的特性， 它的值只能够是字符串
attribute出现在dom中， js提供了getAttribute / setAttribute等方法来获取和改变它的值， attribute的值只能是字符串且大小写不敏感， 最后作用于html中， 可以影响innerHTML获取的值。 可以通过访问dom节点的attributes属性来获取改节点的所有的attribute

>非自定义的属性(id / src / href / name / value等)， 通过setAttribute修改其特性值可以同步作用到property上， 而通过.property修改属性值有的(value) 时候不会同步到attribute上， 即不会反应到html上

## Array - like Object（ 伪数组）

>不是数组， 但是有length属性

>不可以使用数组的push、 pop、 shift、 unshift等数组原生的方法

>具体代表： NodeList， HTML Collections，
function.arguments

>slice方法可以用来将一个类数组（ Array - like） 对象 / 集合转换成一个数组
Array.prototype.slice.call(arguments)

## 判断数据类型

### typeof（ 返回字符串）

'string'
'number'
'boolean'
'object': 如果这个值是对象或者null(因为null被认为是一个空对象)
'function'：这个值是函数 
undefined 未定义
无法判断引用类型（ 除了function类）， 也就是继承自object类型的具体类型， 比如Array、 Date、 自定义类， 这些一律返回object


### instanceof操作符判断数据类型

>所有typeof值返回值为 "object"的对象(如数组) 都包含一个内部属性[class] 一般通过 Object.prototype.toString() 获得

>instanceof 检测一个对象A是不是另一个对象B的实例的原理是：查看对象B的prototype指向的对象是否在对象A的[[prototype]]链上。如果在，则返回true,如果不在则返回false

>a istanceof A: 判断a是否是A的实例， 其实是在判断a.proto === A.prototype
instanceof 只能用来判断两个对象是否属于原型链的关系， 而不能获取对象的具体类型

```
var arr = [];
arr instanceof Array // true 
arr instanceof Object 
// true 原因 
arr._proto_ === Array.prototype;
Array.prototype._proto_ === Object.prototype; 
Object.prototype._proto_ === null;

```


## Object.prototype.toString.call() 精确判断数据类型

>可以用来精确判断数据类型， 包括Boolean、 Number、 String、 Function、 Array、 Date、 RegExp、 Object、 Error等类型。 返回类似’[object type]‘ 的字符串， type指前面提到过的Boolean、 String等类型。

>缺点： 无法检测开发人员自定义的构造函数创建的实例类型。 toString是Object原型对象上的一个方法， 该方法默认返回其调用者的具体类型

```

Object.prototype.toString.call(''); // [object String] 
Object.prototype.toString.call(1) ; // [object Number] 
Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call([]) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(document) ; // [object HTMLDocument] Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用

```

## 判断一个变量是数组Array类型

Object.prototype.toString
Array.isArray()

```

if(typeof Array.isArray==="undefined")
{
  Array.isArray = function(arg){
        return Object.prototype.toString.call(arg)==="[object Array]"
    }; 
}


```

## javascript 本地对象 内置对象 宿主对象分别指什么

 * 本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。

本地对象”包含哪些内容：

Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError

简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。

* 内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了

而ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。

* 所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。

所有的BOM和DOM对象都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。其实说白了就是，ECMAScript官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过ECMAScript程序创建的对象。


## 浏览器对象模型（ BOM） 对浏览器窗口进行访问和操作

BOM
location对象
host: 返回服务器名和端口(如果有)
href: 返回完整url
protocol: 返回协议, http或https
search: 返回URL查询字符串

`outerWidth`和 `outerHeight`
返回浏览器窗口本身的尺寸

`innerWidth`和 `innerHeight`
返回该容器内页面视图区的大小（ 减去边框）(高程书上写Chrome中两者返回相同.然而这时错的， 经过测试是宽度返回相同， 然而高度却是按照本身定义所返回的。)

`navigator.userAgent`
用户代理检测

## utf8和gbk的区别

GBK的文字编码是双字节来表示的，即不论中、英文字符均使用双字节来表示，只不过为区分中文，将其最高位都定成1。

至于UTF－8编码则是用以解决国际上字符的一种多字节编码，它对英文使用8位（即一个字节），中文使用24位（三个字节）来编码。对于英文字符较多的论坛则用UTF－8节省空间。

GBK包含全部中文字符，
UTF-8则包含全世界所有国家需要用到的字符。

 对于中文较多的论坛，适宜用GBK编码节省数据库空间。
       对于英文较多的论坛，适宜用UTF-8节省数据库空间。


## offsetHeight, scrollHeight, clientHeight分别代表什么

* clientHeight

大部分浏览器对 clientHeight 都没有什么异议，认为是元素可视区域的高度，也就是说元素或窗口中可以看到内容的这个区域的高度，即然是指可看到内容的区域，滚动条不算在内。但要注意padding是算在内。其计算方式为clientHeight = topPadding + bottomPadding+ height - 水平滚动条高度。

* offsetHeight

在IE6，IE7，IE8， IE9以及最新的的FF, Chrome中，对于一般元素，都是offsetHeight = padding + height + border = clientHeight + 滚动条 + 边框。 

* scrollHeight

scrollHeight的争议比较大，有些浏览器认为scrollHeight可以小于clientHeight，有些认为scrollHeight至少应该等于clientHeight。但有一点是一样的，就是scrollHeight >= topPadding + bottomPadding + 内容margin box的高度。

果你想获取视窗可见部分的高度，应该使用documentElement.clientHeight，因为body.clientHeight是由它的内容决定的。

## 数组

### 检测数组

```

//判断一个对象是不是数组
var arr = []

if(arr instanceof Array){} // 方法一

if(Object.prototype.toString.call(arr) == '[object Array]')}{} // 方法二

if(Array.isArray(arr)){} //方法三

if(arr.constructor == Array){} // 方法四


```

### 数组方法

>Array.from(arrayLike, mapFn, thisArg)

>该方法从一个类似数组或可迭代对象创建一个新的数组实例。参数 arrayLike 是想要转换成真实数组的类数组对象或可遍历对象。mapFn 是可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。thisArg是可选参数，为执行 mapFn 函数时 this 的值。

>所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组。
实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。


```

 
let arrayLike = {
    0: 'a',
    1: 'b',
    2: 'c',
    length: 3
}
let arrayLike2 = {length: 3}
let str = 'abcd'
 
let newArray = Array.from(arrayLike) //['a', 'b', 'c']
let newArray2 = Array.from(arrayLike, (v) => v+'1') //['a1', 'b1', 'c1']
let newArray3 = Array.from(arrayLike2) // [undefined, undefined, undefined]
let newArray4 = Array.from(str) // ['a', 'b', 'c', 'd']


```

### 数组合并

>Array.prototype.concat()方法

```

var arr = arr1.concat(arr2) //[1, 2, 3, 4]

```

>for循环和Array.prototype.push()

```

function flation(arr1, arr2) {
    for (var i = 0; i < arr2.length; i++) {
        arr1.push(arr2[i])
    }
    return arr1
}

```

>reduce()或reduceRight()方法


```


function flatten(arr1, arr2) {
    return arr2.reduce(function (prev, curr) {
        prev.push(curr)
        return prev
    }, arr1)
}

```

### 多维（复合）数组合并成一维数组

>Array.prototype.push()方法

```

function flatten(arr, result) {
    if (!result) {
        result = []
    }
    for (var i = 0; i < arr.length; i++) {
        if(arr[i].constructor == Array) {
            flatten(arr[i], r)
        } else {
            result.push(arr[i])
        }
    }
    return result
}
flatten([[1, 2], [3, 4, 5], [6, 7, 8, 9], [11,12,[12,13,[14]]], 10, 11])
//[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11]

```


>Array.prototype.concat()方法

```

//省略对二维以上数组的判断
function flatten(arr) {
    var result = []
    for (var i = 0; i < arr.length; i++) {
        result = result.concat(arr[i])
    }
    return result
}
flatten([[1, 2],[3, 4, 5], [6, 7, 8, 9]]);//[1, 2, 3, 4, 5, 6, 7, 8, 9] 
flatten([[1, 2],[3, 4, 5], [6, 7, 8, 9],10,11]);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]


```

>Function.prototype.apply()

```


//省略对二维以上数组的判断
function flatten(arr) {
    return Array.prototype.concat.apply([], arr)
}

 
//省略对二维以上数组的判断
function flatten(arr) {
    return [].concat.apply([], arr)
}
 

//省略对二维以上数组的判断
function flatten(arr) {
    return [].concat(...arr)
}

 
```

如果要处理三维或更多维数组，则需要加一些判断：

```


function flatten(arr) {
    arr = [].concat.apply([], arr)
    return arr.some(Array.isArray) ? flatten(arr) : arr
}
flatten([[1, 2], [3, 4, 5], [6, 7, 8, 9], [11,12,[12,13,[14]]], 10, 11])
//[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11]

```

>使用join()和split()

```


function flatten(arr) {
    return arr.join(',').split(',')
}
flatten([[1, 2], [3, 4, 5], [6, 7, 8, 9], [11,12,[12,13,[14]]], 10, 11])
//["1", "2", "3", "4", "5", "6", "7", "8", "9", "11", "12", "12", "13", "14", "10", "11"]
 
  这种方法的缺点在于返回的数组内全是字符串，如果不需要校验内容类型的话，可以使用这种方法。

```

### 数组去重

>双重循环去重

思路：

构建一个空数组来存放去重后的数组
对原数组做循环遍历，每次从数组中取出一个元素与结果数组做对比
如果原数组取出的元素与结果数组元素相同，则跳出循环；反之则将其存放到结果数组

```

function unique(arr) {
    var result = [arr[0]]
    for (var i = 1; i < arr.length; i++) {
        var repeat = false
        for (var j = 0; j < result.length; j++) {
            if (arr[i] == result[j]) {
                repeat = true
                break;
            }
        }
        if (!repeat) {
            result.push(arr[i])
        }
    }
    return result
}
 
unique([1, 2, 3, 4, 3, 2, 'a', 'b', 'a']);
//[1, 2, 3, 4, "a", "b"]
 
 
 ===
 
 function unique(arr) {
    var result = [arr[0]]
    arr.forEach(function(v) {
        if (result.indexOf(v) == -1) {  //这里 indexOf()也可替换为es7的includes()
            result.push(v)
        }
    })
    return result
}
unique([1, 2, 3, 4, 3, 2, 'a', 'b', 'a']);
//[1, 2, 3, 4, "a", "b"]

```

>对象键值对法

思路：

创建一个 js 对象及新数组
遍历原数组，每次取出一个元素与 js 对象的键作对比
如果不包含，将存入对象的元素的值推入到结果数组中，并将 object 对象中该属性名的值设为1

```

function unique(arr) {
    var result = []
    var object = {}
    for (var i = 0; i < arr.length; i++) {
        if (!object[typeof(arr[i]) + arr[i]]) {  //键名里加入typeof(arr[i])是为了区别不同类型的值，如1和`1`
            result.push(arr[i])
            object[typeof(arr[i]) + arr[i]] = 1
        }
    }
    return result
}
unique([1, 2, 3, 4, 3, 2, '1', 'a', 'b', 'a']);
//[1, 2, 3, 4, "a", "b"]


```

>使用 ES6 的 Set 和 Map 方法

```

//借助 Map 数据结构
function unique(arr) {
    const seen = new Map()
    return arr.filter((v)=> !seen.has(v) && seen.set(v, 1));
}
 
//借助 Set 数据结构
function unique(arr) {
    return Array.from(new Set(arr)) //或 return [...new Set(arr)]
}
 
unique([1, 2, 3, 4, 3, 2, '1', 'a', 'b', 'a']);
//[1, 2, 3, 4, "1", "a", "b"]

```

### 取数组中最大值最小值

遍历比较方法

思路：

设一个变量存放最大值，将数组中第一个值赋值给该变量
遍历数组与最大值变量比较，如果大于最大值，则将该值赋值最大值变量
遍历结束后，变量里储存的就是数组里的最大值

```

Array.prototype.max = function() {
    var max = this[0]
    this.forEach(function(v) {
        if (v > max) {max = v}
    })
    return max
}
[1,45,23,3,6,2,7,234,56].max() // 234


```


归并比较方法
思路：

使用数组实例的 reduce(function(prev, curv, index, arr)) 方法
依次比较回调函数中参数 prev 与 curv 的大小，返回大的那个

```


Array.prototype.max = function() {
    return this.reduce(function(prev, curv) {
        return prev > curv ? prev : curv
    })
}
[1,45,23,3,6,2,7,234,56].max() // 234

```

利用 Math.max() 与 Math.min() 方法

```

Array.prototype.max = function() {
    return Math.max.apply({},this) //或 return Math.max(...this)
}
[1,45,23,3,6,2,7,234,56].max() // 234

```

## 函数声明和函数定义

### 知识点

函数声明和函数定义的区别

### 函数声明背景资料

函数声明定义一个具有指定参数的函数。

你还可以使用  Function 构造函数和 一个function expression 定义函数。

一个被函数声明创建的函数是一个 `Function 对象`，具有 Function 对象的所有属性、方法和行为。查看 Function 以获取 function 的详细信息。

### 函数定义背景资料

function 关键字可以用来在一个表达式中定义一个函数。

函数表达式（function expression）非常类似于函数声明（function statement），并且拥有几乎相同的语法。函数表达式与函数声明的`最主要区别是函数名称`（function name），在函数表达式中可忽略它，从而创建匿名函数（anonymous functions）。一个函数表达式可以被用作一个IIFE（即时调用的函数表达式），它一旦定义就运行。更多信息请查看函数。

函数定义表达式和通过var声明变量一样，其函数被提前到了脚本或函数的顶部，因此它在整个脚本和或函数内都是可见的。这样的话，只有函数变量声明提前了，函数的初始化代码仍然在原来的位置。

### 两者区别

```

   test(1);

　　function test(x){

　　　　console.log(x);

　　}
　　
```
　　上述代码能正常执行，结果输出为1；因为对于`函数声明语句，函数名称和函数体均提前声明了，可以在声明之前调用它。`

　
```

　　test(1);

　　var test = function(x){

　　　　console.log(x);

　　}

```
　　上述代码不能正常执行，会报错。

　　因为对于函数定义表达式，只有函数变量声明提前了，但是函数的初始化代码仍然在原来的位置，也即相当于如下的代码

```

　　var test;   //函数变量声明提前

　　test(1);

　　var test = function(x){

　　　　console.log(x);

　　}

```


## 事件队列与定时器

### 知识点
> setTimeout与window.requestAnimationFrame相比有什么区别.JavaScript内部定时器和事件队列的原理


### setTimeout 背景资料

> setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。

```

除了前两个参数，setTimeout还允许添加更多的参数。它们将被传入推迟执行的函数（回调函数）。

setTimeout(function(a,b){
  console.log(a+b);
},1000,1,1);

上面代码中，setTimeout共有4个参数。最后那两个参数，将在1000毫秒之后回调函数执行时，作为回调函数的参数。

```

>如果被setTimeout推迟执行的回调函数是某个对象的方法，那么该方法中的this关键字将指向全局环境，而不是定义时所在的那个对象。


{% codeblock lang:js %}

var x = 1;
var o = {
  x: 2,
  y: function(){
    console.log(this.x);
  }
};
setTimeout(o.y,1000);// 1


{% endcodeblock %}

### setTimeout运行机制

>setTimeout和setInterval的运行机制是，将指定的代码移出本次执行，等到下一轮Event Loop时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮Event Loop时重新判断。这意味着，setTimeout指定的代码，必须等到本次执行的所有代码都执行完，才会执行。
每一轮Event Loop时，都会将“任务队列”中需要执行的任务，一次执行完。setTimeout和setInterval都是把任务添加到“任务队列”的尾部。因此，它们实际上要等到当前脚本的所有同步任务执行完，然后再等到本次Event Loop的“任务队列”的所有任务执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行

#### setTimeout(func,0)

`setTimeout(f,0)将第二个参数设为0，作用是让f在现有的任务（脚本的同步任务和“任务队列”中已有的事件）一结束就立刻执行。也就是说，setTimeout(f,0)的作用是，尽可能早地执行指定的任务。`

setTimeout(f,0)指定的任务，最早也要到下一次Event Loop才会执行

{% codeblock lang:js %}

setTimeout(function() {
  console.log("Timeout");
}, 0);
function a(x) {
  console.log("a() 开始运行");
  b(x);
  console.log("a() 结束运行");
}
function b(y) {
  console.log("b() 开始运行");
  console.log("传入的值为" + y);
  console.log("b() 结束运行");
}
console.log("当前任务开始");
a(42);
console.log("当前任务结束");
// 当前任务开始
// a() 开始运行
// b() 开始运行
// 传入的值为42
// b() 结束运行
// a() 结束运行
// 当前任务结束
// Timeout

{% endcodeblock %}

>上面代码说明，setTimeout(f,0)必须要等到当前脚本的所有同步任务结束后才会执行。
0毫秒实际上达不到的。根据HTML5标准，setTimeOut推迟执行的时间，最少是4毫秒。如果小于这个值，会被自动增加到4。这是为了防止多个setTimeout(f,0)语句连续执行，造成性能问题。
另一方面，浏览器内部使用32位带符号的整数，来储存推迟执行的时间。这意味着setTimeout最多只能推迟执行2147483647毫秒（24.8天），超过这个时间会发生溢出，导致回调函数将在当前任务队列结束后立即执行，即等同于setTimeout(f,0)的效果。

#### setTimeout(f,0)应用

网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，我们先让父元素的事件回调函数先发生，就要用到setTimeout(f, 0)。

{% codeblock lang:js %}

var input = document.getElementsByTagName('input[type=button]')[0];
input.onclick = function A() {
  setTimeout(function B() {
    input.value +=' input';
  }, 0)
};
document.body.onclick = function C() {
  input.value += ' body'
};

{% endcodeblock %}

{% jsfiddle xwdmpyz3 %}

用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，keypress事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。

{% codeblock lang:js %}

document.getElementById('input-box').onkeypress = function(event) {
  this.value = this.value.toUpperCase();
}

{% endcodeblock %}

{% jsfiddle 88rur1L1 %}

上面代码想在用户输入文本后，立即将字符转为大写。但是实际上，它只能将上一个字符转为大写，因为浏览器此时还没接收到文本，所以this.value取不到最新输入的那个字符。只有用setTimeout改写，上面的代码才能发挥作用。


{% codeblock lang:js %}

document.getElementById('my-ok').onkeypress = function() {
  var self = this;
  setTimeout(function() {
    self.value = self.value.toUpperCase();
  }, 0);
}
{% endcodeblock %}

{% jsfiddle 6bqLo458 %}

### requestAnimationFrame 背景资料

>window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器调用指定的函数在下一次重绘之前更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。

### setTimeout与window.requestAnimationFrame相比有什么区别

1. 首先，当相应的浏览器窗口最小化，JavaScript 计时器在背景标签仍然持续运行。因此，浏览器继续运行看不见的动画，导致不必要的 CPU 和电池寿命的消耗。在移动设备尤其严重。
2. 比如说由于某些原因，回调函数占用太多时间，比你设定的时间要长。一旦计时器时间到了，它将排队执行 “下一次” 回调函数，甚至前一个还没执行完。这一过程不断重复，很快排队了几乎无数的计时器代码，导致浏览器不堪重负。图1 说明这一情况。

![imgn](http://haoqiao.qiniudn.com/figure1.png)

3. 假如你的回调函数执行时间没比设定时间长，setTimeout 和 setInterval 仍不是最理想的.两者只能以固定的频率重绘动画，为了让动画更平滑，我们谨慎起见，选择比屏幕刷新率略高的频率。这样导致不必要的绘制，在屏幕刷新率准备绘制动画结果之前，一些帧已经画过了，因此它们被丢弃了
 
 ![imgn](http://haoqiao.qiniudn.com/figure2.png)


### 事件队列
 
 
### 参考资料

>[你所不知道的setTimeout](https://jeffjade.com/2016/01/10/2016-01-10-javacript-setTimeout/)

>[CSS3动画那么强，requestAnimationFrame还有毛线用](http://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/)

> [requestAnimationFrame 性能更好](https://jinlong.github.io/2013/06/24/better-performance-with-requestanimationframe/)


>[Better JavaScript animations with requestAnimationFrame](https://www.nczonline.net/blog/2011/05/03/better-javascript-animations-with-requestanimationframe/)

### 事件队列

#### 浏览器端的事件队列

>JS运行在浏览器中，是单线程的， 在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。 而浏览器是事件驱动的（ Event driven），浏览器中很多行为是异步（ Asynchronized）的，会创建事件并放入执行队列中。 javascript引擎是单线程处理它的任务队列， 你可以理解成就是普通函数和回调函数构成的队列。
当异步事件发生时， 如mouse click, a timer firing, or an XMLHttpRequest completing（ 鼠标点击事件发生、 定时器触发事件发生、 XMLHttpRequest完成回调触发等）， 将他们放入执行队列， 等待当前代码执行完成
Ajax请求确实是异步的， 这请求是由浏览器新开一个线程请求， 事件回调的时候是放入Event loop单线程事件队列等候处理

通常所说的 JavaScript Engine 是指负责执行一个一个 chunk 的程序，它依赖宿主环境的调度，也需要通过宿主环境与操作系统产生关联并得到支持。JavaScript Engine 是 JavaScript Runtime(Hosting Environment) 的一部分。
每个 chunk 通常是以 function 为单位，一个 chunk 执行完成后，才会执行下一个 chunk。下一个 chunk 是什么呢？取决于当前 Event Loop Queue 中的队首。Event Loop Queue 中存放的都是消息，每个消息关联着一个函数，JavaScript Engine 就按照队列中的消息顺序执行它们，也就是执行 chunk。


`Job Queue`

Job 是 ES6 中新增的概念，它与 Promise 的执行有关，可以理解为等待执行的任务；Job Queue 就是这种类型的任务的队列。JavaScript Runtime 对于 Job Queue 与 Event Loop Queue 的处理有所不同。

相同点：

都用作先进先出队列

相异点：

每个 JavaScript Runtime 可以有多个 Job Queue，但只有一个 Event Loop Queue
当 JavaScript Engine 处理完当前 chunk 后，优先执行所有的 Job Queue，然后再处理 Event Loop Queue

ES6 中，一个 Promise 就是一个 PromiseJob，一种 Job。

{% codeblock lang:js %}

console.log("A");

setTimeout(() => {
  console.log("A - setTimeout");
}, 0);

new Promise((resolve) => {
  resolve();
})
.then(() => {
  return console.log("A - Promise 1");
})
.then(() => {
  return console.log("B - Promise 1");
});

new Promise((resolve) => {
  resolve();
})
.then(() => {
  return console.log("A - Promise 2");
})
.then(() => {
  return console.log("B - Promise 2");
})
.then(() => {
  return console.log("C - Promise 2");
});

console.log("AA");

{% endcodeblock %}

```

在原生支持 Promise 的环境，输出是这样：
A
AA
A - Promise 1
A - Promise 2
B - Promise 1
B - Promise 2
C - Promise 2
A - setTimeout

```

理解这个输出：

A 与 AA 最先输出，因为它们不是异步任务，属于第一个 chunk。

Promise 1 与 Promise 2 先于 setTimeout 执行，因为 Job Queue 的执行优先于 Event Loop Queue。

Promise 1 与 Promise 2 各自的输出都是顺序的，因为 Job Queue 是先进先出队列，同一 Job Queue 中的任务顺序执行。

Promise 1 与 Promise 2 的后续任务是交错的，因为 Promise 1 与 Promise 2 都是独立的 

PromiseJob（job 的其中一种），属于不同的 Job Queue，它们之间的顺序规范中没有规定。

```
JavaScript Engine 对 JavaScript 程序的执行是单线程的，但是 JavaScript Runtime（整个宿主环境）并不是单线程的；而且，几乎所有的异步任务都是并发的，例如多个 Job Queue、Ajax、Timer、I/O(Node)等等。
上面说的是 JavaScript Runtime 层面，JavaScript 执行本身，也有一些特殊情况，例如：一个 Web Worker 或者一个跨域的 iframe，也是独立的线程，有各自的内存空间（栈、堆）以及 Event Loop Queue。要与这些不同的线程通信，只能通过 postMessage。一次 postMessage 就是在另一个线程的 Event Loop Queue 中加入一条消息。

```

JavaScript的主线程在遇到异步调用时，这些异步调用会立刻返回某个值，从而让主线程不会在此处阻塞。而真正的异步操作会由浏览器执行，主线程则会在清空当前调用栈后，按照先入先出的顺序读取任务队列里面的任务。而 JavaScript 中的任务又分为 `MacroTask` 与 `MicroTask` 两种，在 ES2015 中 MacroTask 即指 `Task`，而 MicroTask 则是指代 `Job`。典型的 MacroTask 包含了 `setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering` 等，MicroTask 包含了 `process.nextTick, Promises, Object.observe, MutationObserver` 等。 二者的关系可以图示如下：

![imgn](http://haoqiao.qiniudn.com/MicroTaskandmacrotask.jpg)


参考 whatwg 规范(参考文档已给出) 中的描述：一个事件循环(Event Loop)会有一个或多个任务队列(Task Queue，又称 Task Source)，这里的 Task Queue 就是 MacroTask Queue，而 Event Loop 仅有一个 MicroTask Queue。每个 Task Queue 都保证自己按照回调入队的顺序依次执行，所以浏览器可以从内部到JS/DOM，保证动作按序发生。而在 Task 的执行之间则会清空已有的 MicroTask 队列，在 MacroTask 或者 MicroTask 中产生的 MicroTask 同样会被压入到 MicroTask 队列中并执行。参考如下代码：


{% codeblock lang:js %}

function foo() {
  console.log("Start of queue");
  bar();
  setTimeout(function() {
    console.log("Middle of queue");
  }, 0);
  Promise.resolve().then(function() {
    console.log("Promise resolved");
    Promise.resolve().then(function() {
      console.log("Promise resolved again");
    });
  });
  console.log("End of queue");
}

function bar() {
  setTimeout(function() {
    console.log("Start of next queue");
  }, 0);
  setTimeout(function() {
    console.log("End of next queue");
  }, 0);
}

foo();

// 输出
Start of queue
End of queue
Promise resolved
Promise resolved again
Start of next queue
End of next queue
Middle of queue

{% endcodeblock %}


关于Tasks, microtasks, queues and schedules比较直观的了解可以参考资料里的链接。

> [event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)

> [JavaScript 中的异步：Event Loop 及其他](https://zhuanlan.zhihu.com/p/22710155)


>[Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)


>[ecma262官方规范](http://www.ecma-international.org/ecma-262/6.0/#sec-performpromisethen)


>[task-queue](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue)

#### Node端的事件队列

> Node.js依赖libev来提供event loop，使用线程池来提供异步I/O。

Libuv默认使用四个线程创建一个线程池来执行异步工作。今天的操作系统已经为许多I/O任务提供了异步接口（例如Linux上的AIO）。
只要有可能，libuv将使用这些异步接口，避免使用线程池。这同样适用于像数据库这样的第三方子系统。在这里，驱动程序宁愿使用异步接口，而不是使用线程池。
简而言之：只有没有其他方式，线程池将用于异步I/O。

Node.js中你的代码运行在单线程之中.单线程没法让代码并行执行。但是所有I/O操作都是事件驱动、并行的.

`Node事件循环原理图`

![imgn](http://haoqiao.qiniudn.com/Ticks%20and%20Phases%20of%20the%20Node.js%20Event%20Loop.png)

1.Timers

通过setTimeout()或setInterval()调度的所有内容将在此处处理。

2.IO Callbacks

这里将处理大部分的回调。
由于Node.js中的所有用户代码基本上都处于回调（例如，对传入http请求的回调触发级联的回调），这是用户级代码。

3.IO Polling(轮询)
  对下一次要处理的新事件进行轮询。
  
4.Set Immediate
  运行所有通过setImmediate注册的回调，也就是立刻执行。
  
5.Close

这里处理所有on（'close'）事件回调。


`事件循环就是一个典型的生产者消费者模型，由请求生产，事件循环消费，这个循环由 IOCP / 多线程创建。
`

首先我们引入请求对象的概念，JavaScript 层传入的参数和方法都被封装在请求对象中，当有可用线程时，我们就会调用对象底层对应的方法。

组装好请求对象，送入`线程池`等待执行，这就完成了我们的第一步。

执行结束后，将会将结果存储，并且调用方法通知 IOCP 将线程交还给线程池。

之后事件循环观察到执行完的请求，进行处理即可。

整个流程如图（摘自深入浅出 Node.js）：

![imgn](http://haoqiao.qiniudn.com/2773128744.jpg)




>[event-loop-timers-and-nexttick](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)

>[Process.nextTick 和 setImmediate 的区别](https://www.zhihu.com/question/23028843)


 >[你应该知道什么才能真正了解Node.js事件循环](https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c)


>[Node.js 异步原理](https://codesky.me/archives/nodejs-asynchronous-principle.wind)

## Microtask 与 Macrotask

1. 一个浏览器环境（unit of related similar-origin browsing contexts.）只能有一个事件循环（Event loop），而一个事件循环可以多个任务队列（Task queue），每个任务都有一个任务源（Task source）。例如,客户端可能实现了一个包含鼠标键盘事件的任务队列，还有其他的任务队列，而给鼠标键盘事件的任务队列更高优先级，例如75%的可能性执行它。这样就能保证流畅的交互性，而且别的任务也能执行到了。但是，同一个任务队列中的任务必须按先进先出的顺序执行。多个任务队列，是为了方便控制优先级。任务队列是一个先进先出的队列.
2. macrotask 和 microtask 是异步任务的两种分类。在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。
3. 全部代码(script)是一个macrotask,js先执行一个macrotask,执行过程中遇到(setTimeout, setInterval, setImmediate等)异步操作则创建一个macrotask,遇到(process.nextTick, Promises等)创建一个microtask,这两个queue分别被挂起.执行栈为空时开始处理macrotask,完成后处理microtask,直到该microtask全部执行完,然后继续主线程调用栈.



##  前端PV和UV统计的实现

  PV(访问量)：Page View, 即页面浏览量或点击量，用户每次刷新即被计算一次。

　UV(独立访客)：Unique Visitor,一般使用cookie标记,访问您网站的一台电脑客户端(比如一台电脑开多个浏览器访问则为多个UV)为一个访客，00:00-24:00内相同的客户端只会被计算一次。

　　IP(独立IP)：指独立IP数。00:00-24:00内相同IP地址之被计算一次(多台电脑可能共用一个ip)。

标记和采集数据。监控js被加载后就会往浏览器写入cookie标记访客，比如新访客生产一个新cookie和标记访问次数，若是老用户则，读取 cookie信息，计算访问次数和最后访问时间等，这些客户端的信息处理完后，则向指定的服务器发送数据。

## 实现bind方法，写出 polyfill

```

if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs   = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP    = function() {},
        fBound  = function() {
          return fToBind.apply(this instanceof fNOP
                 ? this
                 : oThis,
                 // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的
                 aArgs.concat(Array.prototype.slice.call(arguments)));
        };

    // 维护原型关系
    if (this.prototype) {
      // Function.prototype doesn't have a prototype property
      fNOP.prototype = this.prototype; 
    }
    fBound.prototype = new fNOP();

    return fBound;
  };
}

```

```

Function.prototype.bind2 = function (context) {

    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}

```


## 箭头函数的应用场景

使用bind()函数或者需要固定上下文的地方现在使用箭头函数会让代码更加简洁.

在写连续的Promise链式调用时，可以使代码更加优雅.



所以当this是由目标对象决定时，我们应该使用函数表达式：

在需要动态上下文的地方不能使用箭头函数，使用构造函数创建对象时不能使用箭头函数.

```

var calculate = {  
  array: [1, 2, 3],
  sum: () => {
    console.log(this === window); // => true
    return this.array.reduce((result, item) => result + item);
  }
};
console.log(this === window); // => true  
// Throws"TypeError: Cannot read property 'reduce' of undefined"
calculate.sum();

```

>calculate.sum使用箭头函数来定义，但是调用 calculate.sum() 时出现了异常。因为当执行sum的时候上下文仍然是window，这是因为箭头函数已经绑定了window做为上下文。

>执行this.array 等同于 window.array ,当然是 undefined


解决办法就是不要在对象的方法上使用箭头函数短语法，这样this关键字会在调用时决定，而不是早早绑定在闭合的上下文中

```

var calculate = {  
  array: [1, 2, 3],
  sum() {
    console.log(this === calculate); // => true
    return this.array.reduce((result, item) => result + item);
  }
};
calculate.sum(); // => 6


```


## ES6 的 Class 继承和 ES5 有什么不同？

Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承。


```

class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }

  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }
}

class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

class ColorPoint extends Point {
  constructor(x, y, color) {
    this.color = color; // ReferenceError
    super(x, y);
    this.color = color; // 正确
  }
}

在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。

```

ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。


```

function Super() {}
 
function Sub() {}
Sub.prototype = new Super();
Sub.prototype.constructor = Sub;
 
var sub = new Sub();
 
Sub.prototype.constructor === Sub; // ② true
sub.constructor === Sub; // ④ true
sub.__proto__ === Sub.prototype; // ⑤ true
Sub.prototype.__proto__ == Super.prototype; // ⑦ true

```

## ES6 的模块化解决了哪些问题？如何进行编译的？

[module](http://es6.ruanyifeng.com/#docs/module-loader)

ES6模块有以下两个最主要的优点：

它们是跨平台的，无论在浏览器还是Node.js中都可以正常执行。

import 和 export 都是静态方法，只有这么实现我们才能知道依赖载入是如何工作的。因为 runtime 会先载入文件，解析它然后我们需要在执行之前载入依赖，只有将它们实现成静态方法才能做到。意味着你不能使用import 'engine-' + browserVersion这种语法。这种方式有一个好处：工具可以静态分析代码，找出哪一部分代码确实被使用了然后按需加载这部分代码(tree shake it)。当在使用第三方库的时候这是非常有用的：你不可能使用它们提供的所有方法，所以你可以删除许多没有执行的代码。


### ES6 模块与 CommonJS 模块的差异


讨论 Node 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。

它们有两个重大差异。

CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。

ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

## 说出以下代码的输出结果

console.log(null == undefined) // output 

`true`

console.log(null === undefined) // output

`false`

console.log(typeof(new Object()) == typeof(null)) // output

`true`

console.log(new Number('1') == 1) // output

`true`

console.log(new Number('1') === 1) // output

```
typeof(new Number('1'))
"object"
```

`false`


console.log(new Object('1') == 1) // output

`true`

console.log(new Object('1') === 1) // output

`false`

console.log(new Boolean() == false) // output

`true`

console.log(new Boolean() === true) // output

`false`

```

var a = 1
if (true) {
console.log(a) // output
var a = 2
var b = 3
console.log(b) // output
}
console.log(a) // output
console.log(b) // output
b = 4

```

`1323`


```

var a = 1
function a () {}
console.log(a) // output

```

`1`


```

var a = 1
function fun(a, b) {
a = 2
arguments[0] = 3
arguments[1] = 1
return a + b
}
console.log(fun(0, 0)) // output
console.log(a) // output

```

`4` `1`

## 手写代码 判断是否是浏览器环境

`exports = typeof window === 'undefined' ? global : window ;`

获取全局对象的方式
同理可得，typeof window可以用来判断是不是在浏览器环境中


## sessionid的生成规则？

创建：sessionid第一次产生是在直到某server端程序调用 HttpServletRequest.getSession(true)这样的语句时才被创建。

删除：超时；程序调用HttpSession.invalidate()；程序关闭；

session存放在哪里：服务器端的内存中。不过session可以通过特殊的方式做持久化管理（memcache，redis）。

session的id是从哪里来的，sessionID是如何使用的：当客户端第一次请求session对象时候，服务器会为客户端创建一个session，并将通过特殊算法算出一个session的ID，用来标识该session对象

session会因为浏览器的关闭而删除吗？
不会，session只会通过上面提到的方式去关闭。

## javascript实现数据双向绑定的三种方式


### 1、手动绑定

比较老的实现方式，有点像观察者编程模式，主要思路是通过在数据对象上定义get和set方法(当然还有其它方法)，调用时手动调用get或set数据，改变数据后出发UI层的渲染操作；以视图驱动数据变化的场景主要应用与input、select、textarea等元素，当UI层变化时，通过监听dom的change，keypress，keyup等事件来出发事件改变数据层的数据。整个过程均通过函数调用完成。


·```

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>data-binding-method-set</title>
</head>
<body>
    <input q-value="value" type="text" id="input">
    <div q-text="value" id="el"></div>
    <script>
        var elems = [document.getElementById('el'), document.getElementById('input')];

        var data = {
            value: 'hello!'
        };

        var command = {
            text: function(str){
                this.innerHTML = str;
            },
            value: function(str){
                this.setAttribute('value', str);
            }
        };

        var scan = function(){        
            /**
             * 扫描带指令的节点属性
             */
            for(var i = 0, len = elems.length; i < len; i++){
                var elem = elems[i];
                elem.command = [];
                for(var j = 0, len1 = elem.attributes.length; j < len1; j++){
                    var attr = elem.attributes[j];
                    if(attr.nodeName.indexOf('q-') >= 0){
                        /**
                         * 调用属性指令，这里可以使用数据改变检测
                         */
                        command[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]);
                        elem.command.push(attr.nodeName.slice(2));
                    }
                }
            }
        }

        /**
         * 设置数据后扫描
         */
        function mvSet(key, value){
            data[key] = value;
            scan();
        }
        /**
         * 数据绑定监听
         */
        elems[1].addEventListener('keyup', function(e){
            mvSet('value', e.target.value);
        }, false);

        scan();

        /**
         * 改变数据更新视图
         */
        setTimeout(function(){
            mvSet('value', 'fuck');
        },1000)

    </script>
</body>
</html>


```


### 2、脏检查机制

以典型的mvvm框架angularjs为代表，angular通过检查脏数据来进行UI层的操作更新。关于angular的脏检测，有几点需要了解些：

脏检测机制并不是使用定时检测。
脏检测的时机是在数据发生变化时进行。
angular对常用的dom事件，xhr事件等做了封装， 在里面触发进入angular的digest流程。
在digest流程里面， 会从rootscope开始遍历， 检查所有的watcher。 （关于angular的具体设计可以看其他文档，这里只讨论数据绑定），那我们看下脏检测该如何去做：主要是通过设置的数据来需找与该数据相关的所有元素，然后再比较数据变化，如果变化则进行指令操作.

```

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>data-binding-drity-check</title>
</head>

<body>
    <input q-event="value" ng-bind="value" type="text" id="input">
    <div q-event="text" ng-bind="value" id="el"></div>
    <script>

    var elems = [document.getElementById('el'), document.getElementById('input')];
    
    var data = {
        value: 'hello!'
    };

    var command = {
        text: function(str) {
            this.innerHTML = str;
        },
        value: function(str) {
            this.setAttribute('value', str);
        }
    };

    var scan = function(elems) {
        /**
         * 扫描带指令的节点属性
         */
        for (var i = 0, len = elems.length; i < len; i++) {
            var elem = elems[i];
            elem.command = {};
            for (var j = 0, len1 = elem.attributes.length; j < len1; j++) {
                var attr = elem.attributes[j];
                if (attr.nodeName.indexOf('q-event') >= 0) {
                    /**
                     * 调用属性指令
                     */
                    var dataKey = elem.getAttribute('ng-bind') || undefined;
                    /**
                     * 进行数据初始化
                     */
                    command[attr.nodeValue].call(elem, data[dataKey]);
                    elem.command[attr.nodeValue] = data[dataKey];
                }
            }
        }
    }

    /**
     * 脏循环检测
     * @param  {[type]} elems [description]
     * @return {[type]}       [description]
     */
    var digest = function(elems) {
        /**
         * 扫描带指令的节点属性
         */
        for (var i = 0, len = elems.length; i < len; i++) {
            var elem = elems[i];
            for (var j = 0, len1 = elem.attributes.length; j < len1; j++) {
                var attr = elem.attributes[j];
                if (attr.nodeName.indexOf('q-event') >= 0) {
                    /**
                     * 调用属性指令
                     */
                    var dataKey = elem.getAttribute('ng-bind') || undefined;

                    /**
                     * 进行脏数据检测，如果数据改变，则重新执行指令，否则跳过
                     */
                    if(elem.command[attr.nodeValue] !== data[dataKey]){

                        command[attr.nodeValue].call(elem, data[dataKey]);
                        elem.command[attr.nodeValue] = data[dataKey];
                    }
                }
            }
        }
    }

    /**
     * 初始化数据
     */
    scan(elems);

    /**
     * 可以理解为做数据劫持监听
     */
    function $digest(value){
        var list = document.querySelectorAll('[ng-bind='+ value + ']');
        digest(list);
    }

    /**
     * 输入框数据绑定监听
     */
    if(document.addEventListener){
        elems[1].addEventListener('keyup', function(e) {
            data.value = e.target.value;
            $digest(e.target.getAttribute('ng-bind'));
        }, false);
    }else{
        elems[1].attachEvent('onkeyup', function(e) {
            data.value = e.target.value;
            $digest(e.target.getAttribute('ng-bind'));
        }, false);
    }

    setTimeout(function() {
        data.value = 'fuck';
        /**
         * 这里问啥还要执行$digest这里关键的是需要手动调用$digest方法来启动脏检测
         */
        $digest('value');
    }, 2000)

    </script>
</body>
</html>

```

### 3、前端数据劫持(Hijacking)

。基本思路是使用Object.defineProperty对数据对象做属性get和set的监听，当有数据读取和赋值操作时则调用节点的指令，这样使用最通用的=等号赋值就可以了

```

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>data-binding-hijacking</title>
</head>

<body>
    <input q-value="value" type="text" id="input">
    <div q-text="value" id="el"></div>
    <script>


    var elems = [document.getElementById('el'), document.getElementById('input')];

    var data = {
        value: 'hello!'
    };

    var command = {
        text: function(str) {
            this.innerHTML = str;
        },
        value: function(str) {
            this.setAttribute('value', str);
        }
    };

    var scan = function() {
        /**
         * 扫描带指令的节点属性
         */
        for (var i = 0, len = elems.length; i < len; i++) {
            var elem = elems[i];
            elem.command = [];
            for (var j = 0, len1 = elem.attributes.length; j < len1; j++) {
                var attr = elem.attributes[j];
                if (attr.nodeName.indexOf('q-') >= 0) {
                    /**
                     * 调用属性指令
                     */
                    command[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]);
                    elem.command.push(attr.nodeName.slice(2));

                }
            }
        }
    }

    var bValue;
    /**
     * 定义属性设置劫持
     */
    var defineGetAndSet = function(obj, propName) {
        try {
            Object.defineProperty(obj, propName, {

                get: function() {
                    return bValue;
                },
                set: function(newValue) {
                    bValue = newValue;
                    scan();
                },

                enumerable: true,
                configurable: true
            });
        } catch (error) {
            console.log("browser not supported.");
        }
    }
    /**
     * 初始化数据
     */
    scan();

    /**
     * 可以理解为做数据劫持监听
     */
    defineGetAndSet(data, 'value');

    /**
     * 数据绑定监听
     */
    if(document.addEventListener){
        elems[1].addEventListener('keyup', function(e) {
            data.value = e.target.value;
        }, false);
    }else{
        elems[1].attachEvent('onkeyup', function(e) {
            data.value = e.target.value;
        }, false);
    }

    setTimeout(function() {
        data.value = 'fuck';
    }, 2000)
    </script>
</body>

</html>

```

但值得注意的是defineProperty支持IE8以上的浏览器，这里可以使用__defineGetter__ 和 __defineSetter__ 来做兼容但是浏览器兼容性的原因，直接用defineProperty就可以了。至于IE8浏览器仍需要使用其它方法来做hack。如下代码可以对IE8进行hack，defineProperty支持IE8。例如使用es5-shim.js就可以了。（IE8以下浏览器忽略）


## jwt-token，优点缺点

>JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。

### JWT优点
因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。
因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。
便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。
它不需要在服务端保存会话信息, 所以它易于应用的扩展。
该方案可防护CSRF攻击.

### 缺点

token泄露一般是传输层或者客户端出了问题。

传输层
HTTP容易被窃听，建议使用HTTPS，若HTTPS都被破解了，那么传统的cookie存储的sessionId也有一样的问题。

客户端
客户端的cookie或者storage被窃取，传统的cookie存储sessionId也有一样的问题。

因此，建议使用HTTPS增强安全性，其他的安全方案和传统方式一样。


