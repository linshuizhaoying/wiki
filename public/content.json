{"pages":[{"title":"About","date":"2017-07-24T02:24:00.000Z","path":"about/index.html","text":"关于我"},{"title":"Categories","date":"2017-07-08T14:56:04.000Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2017-07-08T14:56:04.000Z","path":"tags/index.html","text":""}],"posts":[{"title":"睡眠革命:如何让睡眠更高效","date":"2018-02-23T03:56:40.000Z","path":"wiki/阅读/睡眠革命:如何让睡眠更高效/","text":"前言前段时间对睡眠质量不太满意，因此在看到书的时候果断加入到阅读序列。 除去睡眠常识，这本书最重要的其实是做出了一些科学的设定。 睡眠周期了解一下书中有个设定就是R90，他将人类睡眠时间以90分钟为周期划分。 也就是你可以选择睡几个完整的睡眠周期。 如果睡眠时间不足你可以在午后，对应晚上的时间去补一个睡眠周期或者 30分钟的休息时间。 睡眠习惯了解一下常见的睡眠手段包括老生常谈的禁止玩手机： 在天黑以后，蓝光就成了一种不良光线。如果你在入夜之后使用一些电子产品，或者在夜深人静时还对着一片蓝光，就会引发各种健康问题。它将导致克里斯·艾德辛科斯基教授所称的“垃圾睡眠”——受干扰和不充足的睡眠。这是因为，我们的生活方式和各种小玩意儿的出现，妨碍了褪黑素的分泌，并推迟了我们的生物钟。 每个人根据自己情况分为早睡星人和晚睡星人。 感觉这和生活环境与习惯其实有很大关系。现代年轻人大部分都是晚睡党。 对于晚睡星人来说，如果想调整自己的生物钟，让自己能跟上早起星人的节奏，那么早晨的日光极为关键。你可以去买一台模拟日出自然唤醒灯，它能在卧室中模拟日出，从而把你从睡梦中唤醒。这点实测真的可以。晚上12点睡。早睡7点多，房间朝阳，阳光把你唤醒。同理可以想想学校的宿舍其实也是这样。 少喝咖啡： 咖啡因是一种容易让人上瘾的药物，如果每天大量摄入咖啡因，就会对咖啡因产生耐受力。你会需要越来越多的咖啡因才能达到想要的效果。一旦过量摄入咖啡因成为一种常规，那么，当你以为你在超常发挥时，实际情况往往并非如此。你会经常落后那几步，兴奋过度，变成自己的一个影子。因为，你虽然摄入了咖啡因，却只能达到你平时的水平。 也就是在不是很必要的情况下不要喝咖啡。真的困可以调整自己的作息。比如多加30分钟的休息时间。 工作状态中可能在不该困的时间犯困： 每隔90分钟一次的“大脑休息”，能让你再度回到办公桌后的表现大幅提升，并让你的压力水平大幅降低。 当然最关键的是：如果你没有睡好，你的身体会嗜恋甜食。也就是你会胖。。。","tags":[{"name":"自我提升","slug":"自我提升","permalink":"http://wiki.haoqiao.me/tags/自我提升/"},{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/tags/阅读/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://wiki.haoqiao.me/tags/读书笔记/"},{"name":"读后感","slug":"读后感","permalink":"http://wiki.haoqiao.me/tags/读后感/"}],"categories":[{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/categories/阅读/"}]},{"title":"明朝那些事儿-上","date":"2017-10-27T11:14:30.000Z","path":"wiki/阅读/明朝那些事儿-上/","text":"前言很早以前就知道《明朝那些事儿》挺火，从头火到现在，但那个时候呢，对唐朝比较感兴趣.因为有千古一帝-唐太宗。而且风云人物特别多，八卦也多~对明朝的印象好像就是以前那部穿越电视剧,对朱元璋的印象就是来人，把xxx拉出去砍了(然而历史上朱元璋还真的是和秦始皇有点像，万般难题只有一解:杀)。 《明朝那些事儿》还是很长的，一周看了大概二分之一,整体感官就是作者做到了大部分的不偏不倚,将明朝从朱元璋到朱棣再到后来者,每个人物都有血有肉，尤其是对历史上名不见传却起到重要作用的人物描述的很到位~ 基本上可以作为一本有考据的历史读物. 之所以从小说读物入手，而不去直接读史记，读正史，是因为我觉得历史需要有趣，只有当你觉得足够有趣才会去深究，这到底是不是这样。不然很容易有倦怠性。因此我给自己列的书单都是从小说到正史。 朱元璋 长期的困难生活，最能磨练一个人的意志，有很多人在遇到困难后，只能怨天尤人，得过且过，而另外一些人虽然也不得不在困难面前低头，但他们的心从未屈服，他们不断的努力，相信一定能够取得最后的胜利 对于我们很多人来说，心是最柔弱的地方，它特别容易被伤害，爱情的背叛，亲情的失去，友情的丢失，都将是重重的一击。然而对于朱重八来说，还有什么不可承受的呢？他已经失去一切，还有什么比亲眼看着父母死去而无能为力，为了活下去和狗抢饭吃、被人唾骂，鄙视更让人痛苦！我们有理由相信，就在某一个痛苦思考的夜晚，朱重八把这个最脆弱的地方变成了最强大的力量的来源。 朱元璋是从最底层出身，这非常励志。但这励志的背后是无人走过的艰辛。 从一个只想活着好好种地的农民，到只想避开战争好好活下去的和尚，再到起义的将领。 可以看到逼上梁山的无奈，水浒还可能是设计让人为贼，而朱元璋是真的硬生生被民不聊生的统治给逼迫造反。 朱重八将他的名字改成了朱元璋，所谓璋，是一种尖锐的玉器，这个朱元璋实际上就是诛元璋，朱重八把他自己比成诛灭元朝的利器，而这一利器正是元朝的统治者自己铸造出来的。在今后的二十年里，他们都将畏惧这个名字。 我觉得这个典故很有意思，改名朱元璋。灭元是朱元璋一生心愿，也是他活下去的动力。可以说元朝一手打造出来的造反皇帝。 朱元璋从小就被官府欺压，自己的悲惨遭遇很大程度上是贪官污吏造成的，这也使得他很不喜欢这些当官的，即使官员们为他干活，在他的内心中对这些人也存在着极大的不信任感。这种不信任感一旦遇到某些因素的触发，就会迅速扩大，进而蔓延到对整个群体的信心缺失。 正如俗话所说“一朝被蛇咬，十年怕草绳”，朱元璋就是这样一个被蛇咬过的人，他被官吏们欺压了几十年，怎么会信任这些人。所以如空印案、郭桓案这样的案件一发生，朱元璋就会迅速将风潮扩大，在他看来，官员都是不可信的。 童年的阴影造成不信任，这就造成朱元璋对待官员有一点点不爽都凡事都杀杀杀，杀不干净就继续杀，杀的没人了，戴罪当官。毕竟没几个人对小时候父母兄弟全饿死在自己面前而无动于衷。 可以说历史上如此强势的皇帝没几个，杀官杀的相当多，基本上自从朱元璋当上皇帝，他把功高盖主的，作死的，对后代有威胁的，全部都在他挂掉之前带走，顺便还亲自出征带走了一批不老实的元朝遗留。可以说是杀性最强的一个皇帝，这也看出开国皇帝都有一个特征，强势。一旦新朝建立，从农民翻身作为皇帝，好像就会很自然的代入这个角色，这也是一路马上打天下打出来的个性。因为性格偏软的基本都已经作为垫脚石化为白骨。 对大臣们来说，朱元璋可能不是个好君主，但是对朱元璋的子孙们来说，朱元璋是个好父亲、好祖父。其实朱元璋的这种行为反差的理由也很简单，就如同今天独生子女的家长，特别是那些当年曾经挨过饿的人，自然不忍心让孩子受自己那样的苦，他们恨不得代替子女去承担来他们将来要经受的苦难。 朱元璋确确实实是一个好父亲，他希望自己的子孙能够团结一致，共同辅佐他选定的继承人朱允炆。但就如今天的所谓“代沟”一样，子孙们有自己的打算，特别是皇族的子孙，他们是无法体会朱元璋这种深厚的父爱的，在他们看来，这个白发苍苍的老者早就应该领退休金走人了。他们关注的只是这个老者所坐的那把椅子. 朱棣在父亲把皇位传给兄长的儿子，以后要向一个小屁孩俯首称臣，朱棣就开始想搞事情了. 在皇位面前，人人平等，这个平等是指没人性，没辈分，没怜悯。 这一罕见现象的缔造者正是朱棣的死对头朱允炆，正是他的那道不能伤害朱棣性命的旨意使得朱棣数次死里逃生。而那些打仗的士兵们并不是傻瓜，他们十分了解其中的利害关系。 朱棣和朱允炆是叔侄俩，虽然现在刀兵相见，属于敌我矛盾，但万一哪天两人决定不打了，来一场认亲大会，再来个和解，转化为了人民内部矛盾，那可就大大的不妙了。朱棣没准还能当个王爷，闲来无事的时候写本回忆录，记忆起某年某月某日，某某人在某场战役中砍我一刀或者射我一箭，虽然那时朱棣可能仕途上并不得意，但要整个把小兵还是很容易的。 正是出于士兵们的这种考虑，朱棣才得以在乱军之中得以幸免，朱允炆的这道指令最厉害的地方并不在于所谓不得伤害朱棣的命令本身，而是在于无数的南军的将领和士兵们从此命令中看到了两人和解的可能性，面前的这个敌人将来有一天甚至可能会成为自己的主人，所以动手杀朱棣这种费力不讨好的事情实在是没有多少人会去做的。 朱允炆不是一个合格的皇帝就在于他面对其它藩王都下得去手，而面对朱棣却乌龙频繁，一个只许活捉不可伤害犹如给朱棣反向奶了一口，而且还加了无敌buff，最终朱棣这个大流氓就靠这个敌人加的正向Buff在敌军中身先士卒多进多出毫发无损。朱棣的成功就告诉我们，人不要脸真的能无敌~ 这里还要提到一个人就是姚广孝,明朝的风风雨雨都逃不过和尚，作为一个不合格的和尚姚广孝一心想搞事情来证明自己，后面的历史也说明了，当一个和尚真心想搞事情的时候谁也拦不住。 而且在朱棣后来开始清洗周围人的时候，姚广孝是不多能善终的。(主要不要钱，不要赏赐，不要房子，一心搞事，搞完就跑。)这也可见其智慧。 之所以对其印象深刻还是因为以前看的《雪中悍刀行》里有个杨太岁角色就是以他为原型。 “世上怎么会有你这样奇异的和尚！长得一双三角眼，就像生病的老虎，你这样的人天性嗜好杀戮，将来你一定会成为刘秉忠那样的人！” 历史中有很多看相然后使其出名的，当然不乏一些想搞事情的先自己造假，但是也说明了，历史中想搞点事情，你必须先搞定舆论(封建迷信)，当你把大部分人糊弄住了，你才有搞事情的基础。 而且就有现成的例子: 张信的母亲帮助他做出了抉择，她老人家一听说要逮捕燕王，立刻制止了张信，并说道：“千万不可以这样做（逮捕燕王），我经常听人说，燕王将来必定会取得天下，他这样的人是不会死的，也不是你能够抓住的。” 我们可能会觉得纳闷，这位老太太平日大门不出，二门不入，她怎么知道这样的“天机”？综合各种情况分析，这位老太太很可能是受到那些散布街头和菜市场的算命先生们传播的谣言影响，得出了这样一个结论。 如此重大的决策，竟然受一个如此可笑的理由和论据影响并最终做出，实在让人觉得啼笑皆非。 在上帝视角我们可以觉得这很戏剧性，觉得历史很多都是巧合造成的。虽然巧合有，但是这些算命的也是朱棣自己放出去的。这说明想成做成一件事情，你不光需要运气，你还需要自己去制造运气。 太子的悲哀也就在此，无数太子就是这样被自己的父亲玩残的，自古以来，一把手和二把手的关系始终是处理不好的，在封建社会，皇帝就是一把手，太子就是二把手，自然逃脱不了这个规则的制约。 你积极肯干，说你有野心，你消极怠工，说你没前途。 干多了也不行，干少了也不行，其实只是要告诉你，不服我是不行的。 让你干，你就不得休息，不让你干，你就不得好死。 这似乎是很难理解的，到底是什么使得这一滑稽现象反复发生呢？ 答案很简单：权力。 谁分我的权，我就要谁的命！（儿子也不例外）朱棣很明白，他最终是要将权力交给太子的，而在此之前，太子必须有一定的办事能力，为了帝国的未来，无能的废物是不能成为继承人的，所以必须给太子权力和锻炼的机会，但他更明白，要想得一个善终，权利必须在自己手上。 儿子是不能相信的，老婆是不能相信的，天下人都是不能相信的。 这就是皇帝的悲哀 每一个皇帝做上那个位置都开始朝着另一个生物进化，而且只有一个人能进化。当种族不同了，以前的同伴，信任的谋士。甚至是亲人。都成了不同种族的。想要培养下一个能进化的人，一边要防着他背叛，一边还要防止他无能.这是一个自相矛盾却又无解的问题。在皇权没有那么集中的年代，种族划分还没有那么明显，当一个统治者是件辛苦的事情。但是到了后来，权利越大，当统治者变成了一件可以将欲望无限放大的事情。进化的机会就一个，培养继承人如同炼蛊。活下来那个最强，也最残暴。 郑和 在经过一番整顿后，逐渐稳住阵脚，开始与北军作战，几十万人奋死拼命厮杀，打得天昏地暗，血流成河。战局陷入僵持状态对朱棣是不利的，因为他并不适合打消耗战，为了能够尽快解决战斗，他向身边的人征求作战意见。 此时一个叫马三保的人明确指出，南军的要害就在于李景隆的中军，只要李景隆移动位置，便可趁其立足未稳之机以奇兵左右夹击，定可获胜。朱棣经过思考，采纳了马三保的意见，并任命马三保为部将，一同参加战斗。此时已经天黑，李景隆果然按捺不住，亲自带领中军前来作战，朱棣立刻派出奇兵从其两翼发动猛烈攻击，李景隆果然抵挡不住，败下阵来 马三保的人也因在此战中的优秀表现为朱棣所重用，并引为心腹，此人出生时父母为世道平和，平安成长之意，曾给他取名为和，又由于他在郑村立下大功，被朱棣赐姓“郑”，此后他便改名为郑和。 郑和是一名虔诚的伊斯兰教徒，他的祖父和父亲都信奉伊斯兰教，而所有的伊斯兰教徒心底都有着一个最大的愿望——去圣城麦加朝圣 这是觉得有意思的地方，以前觉得郑和下西洋就是奉旨。没想到人家是一个有信仰的人~ 他一生最后一次下西洋终于完成他的人生目标，去圣城麦加朝圣，虽然回程一半年老衰死。但是他用一生告诉我们一个人，只要倾尽其一生精力，即使是在那个封建的年代，人也可以完成自己的梦想。 结尾只简单的记了几个人物，但是从他们的经历中，提炼出来的是坚持。每一个完成自己目标的人，期间可能想过放弃，但是他们没有其他选择，放弃就是死亡。在这种只有一条路的选择中，他们选择了坚持。我们现在能看到的是历史记载一瞥而过的文字，而对他们是几年几十年如一日的浓缩。 我们可以从明朝这些历史中看到非常值得敬佩的人，力挽狂澜的于谦，送人头送经验的李景隆。有品德高尚入圣人，也有无耻刷新人底线的。 我们可以看到不同性格不同样的人在不同的相同的环境下做的不同选择，从而一步步演化成历史上的一幕幕。 这很有意思。","tags":[{"name":"自我提升","slug":"自我提升","permalink":"http://wiki.haoqiao.me/tags/自我提升/"},{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/tags/阅读/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://wiki.haoqiao.me/tags/读书笔记/"},{"name":"读后感","slug":"读后感","permalink":"http://wiki.haoqiao.me/tags/读后感/"}],"categories":[{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/categories/阅读/"}]},{"title":"Lodash源码阅读","date":"2017-10-14T14:27:13.000Z","path":"wiki/前端/框架/Lodash/源码阅读/","text":"前言以前读源码都虎头蛇尾，一心想着用什么工具提高效率啊，用什么方式读更容易啊，要不要先去看看别人的源码注解啊什么的。但是发现源码,Just read it. 正如每日坚持锻炼，去做就好了。先用最”笨”的方法去做。等以后读多了，找到规律了，效率自然上来了。 这次打算读Lodash，和以前的underscore类似，但是这是公司部门有一直使用的基础库，以前没用过，因此在我的计划中排队了好久，现在抽出时间，打算一点点啃完。 Go~ Array_.chunk _.chunk(array, [size=1]) 数组中的块函数，通过第二个参数传递将数组分割成指定数量的块，如果数组不够分，那么最后的块就打包剩余的元素。 在看源码之前用以前历史公开课学到的方法来思辨一下。就是代入自己，如果我说作者我需要怎么做，我需要考虑哪些。 像这种成熟的库，一般都会类型检查。因此第一件事情我觉得是isArray(arg1) 然后是具体功能的解析，那就是如何将数组拆分。那么想到的就是原生的slice函数。 接下来去看源码 123456789101112131415161718function chunk(array, size) &#123; size = Math.max(size, 0) // 判断了第二个参数非负数 const length = array == null ? 0 : array.length // 判断非空 if (!length || size &lt; 1) &#123; return [] // 如果输入非法返回空 &#125; let index = 0 let resIndex = 0 const result = new Array(Math.ceil(length / size)) // 创建最大数量的数组，ceil是向上求整数 while (index &lt; length) &#123; // 将字符按照size填充填充 result[resIndex++] = slice(array, index, (index += size)) &#125; return result&#125; 其中还引用了slice方法. 这之前我就试过把字符串传进去，依旧被当做数组处理。 12345678910111213141516171819202122232425262728function slice(array, start, end) &#123; let length = array == null ? 0 : array.length // 先判断是否为空,字符串会通过检测 if (!length) &#123; return [] &#125; start = start == null ? 0 : start end = end === undefined ? length : end // 判断越界情况 if (start &lt; 0) &#123; start = -start &gt; length ? 0 : (length + start) &#125; end = end &gt; length ? length : end if (end &lt; 0) &#123; end += length &#125; length = start &gt; end ? 0 : ((end - start) &gt;&gt;&gt; 0) start &gt;&gt;&gt;= 0 //把num变成一个无符号的32位的整数,JavaScript的数组的最大长度是2^32-1，所以这样做也避免了数组的索引超出界限。 let index = -1 const result = new Array(length) // 重新生成一个数组 while (++index &lt; length) &#123; result[index] = array[index + start] &#125; return result&#125; 这里可以看到lodash自己封装了一个slice.网上查了下说是比原生快。顺便我做了个最新版本和原生的对比的例子slice-vs-slice测试后发现比原生的快60% 有兴趣可以去看下原生slice的实现方法 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice _.compact _.compact(array) 返回一个新数组，移除原先数组中无效的值：false, null, 0, &quot;&quot;, undefined, and NaN 我想的是直接一个循环过滤掉无效值。 123456789101112131415161718function compact(array) &#123; let resIndex = 0 const result = [] if (array == null) &#123; return result &#125; for (const value of array) &#123; if (value) &#123; result[resIndex++] = value &#125; &#125; return result&#125;export default compact 看源码是用for of取值，那么我想了下换成for循环会怎么样？ 12345678910111213141516function compact2(array) &#123; let resIndex = 0 const result = [] if (array == null) &#123; return result &#125; for (var i=0 , len &lt; array.length; i&lt; len;i++) &#123; if (array[i]) &#123; result[resIndex++] = array[i] &#125; &#125; return result&#125; 是一样的结果。 至于效率，看网上文章说居然还是 for 循环比较高… 数组遍历效率对比 但是在这个例子中经过测试，却是_.compact更快，当然这肯定有chrome更新后对es6的优化有一定影响。 forof-vs-for _.concat _.concat(array, [values]) 创建一个新数组，来连接旧数组和新数组或者新值。 在实际例子中 123456789var array = [1];var other = _.concat(array, 2, [3], [[4]]); console.log(other);// =&gt; [1, 2, 3, [4]] console.log(array);// =&gt; [1] 可以看到它是不限制后面有多少个数据，如果是数组包含数组，它当做值处理。而且不改变传入的数组。 这肯定需要做一个拷贝。而且需要对传入参数做一个遍历。 123456789101112131415function concat() &#123; var length = arguments.length; if (!length) &#123; return []; &#125; var args = Array(length - 1), //去掉第一个参数 array = arguments[0], index = length; while (index--) &#123; args[index - 1] = arguments[index]; &#125; return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1)); &#125; 返回的时候有两个函数我们需要进一步看一下 copyArray 1234567891011function copyArray(source, array) &#123; var index = -1, length = source.length; array || (array = Array(length)); while (++index &lt; length) &#123; array[index] = source[index]; &#125; return array; &#125; 是做了一个浅拷贝。 baseFlatten(args, 1)) 1234567891011121314151617181920212223function baseFlatten(array, depth, predicate, isStrict, result) &#123; var index = -1, length = array.length; predicate || (predicate = isFlattenable);//如果没有传入判断方法，这判断方法为isFlattenable(只有可以执行扁平化就执行) result || (result = []); while (++index &lt; length) &#123; var value = array[index]; if (depth &gt; 0 &amp;&amp; predicate(value)) &#123; if (depth &gt; 1) &#123;//如果深度大于1（还需要扁平化），递归调用自身，并且depth-1,否则将这个元素值添加到结果数组 // Recursively flatten arrays (susceptible to call stack limits). baseFlatten(value, depth - 1, predicate, isStrict, result); &#125; else &#123; arrayPush(result, value); &#125; &#125; else if (!isStrict) &#123; result[result.length] = value; &#125; &#125; return result; &#125; 这就是数组包含数组扁平化的秘密。 _.difference _.difference(array, [values]) 创建并返回一个不包含在其他给定数组中的数组值的数组，以进行相似性比较。返回数组的顺序和值的引用都由第一个数组决定。 example: 123_.difference([2, 1], [2, 3]);// =&gt; [1] 感觉是取交集，然后从第一个数组中剔除。 肯定会用两个循环，但是应该不是N^2的复杂度，不然会慢死。 看源码的注释：* @see union, unionBy, unionWith, without, xor, xorBy, xorWith, 计算方式应该是类似的。 通过源码，发现还是要看另一个base引用。 123456function difference(array, ...values) &#123; return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : []&#125; isArrayLikeObject Returns true if value is an array-like object. 返回判断类数组对象。 在这个函数的源码中可以看到非常直接的判断方式: 1234function isArrayLikeObject(value) &#123; return isObjectLike(value) &amp;&amp; isArrayLike(value)&#125; 突然领悟到了颗粒化函数的优势，在命名非常直白的情况下，阅读源码和阅读注释都相差不大。 判读对象 1234function isObjectLike(value) &#123; return typeof value == &apos;object&apos; &amp;&amp; value !== null&#125; 判断数组 1234function isArrayLike(value) &#123; return value != null &amp;&amp; typeof value != &apos;function&apos; &amp;&amp; isLength(value.length)&#125; 数组的特性是length字段。判断length是否存在的函数也挺有学习意义： 12345function isLength(value) &#123; return typeof value == &apos;number&apos; &amp;&amp; value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= MAX_SAFE_INTEGER&#125; 然后我们再回过头来看baseDifference 这才是真正的处理函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function baseDifference(array, values, iteratee, comparator) &#123; // arrayIncludes 是es6de includes的polyfill let includes = arrayIncludes let isCommon = true const result = [] const valuesLength = values.length if (!array.length) &#123; //如果数组为空 return result &#125; // 迭代，传进来的参数是 baseFlatten(values, 1, isArrayLikeObject, true)，扁平化后的数组 // 如果有遍历器，先对过滤数组进行遍历操作 if (iteratee) &#123; values = map(values, (value) =&gt; iteratee(value)) &#125; // 如果有比较器，includes就引用arrayIncludesWith，并且不正常过滤 if (comparator) &#123; includes = arrayIncludesWith isCommon = false &#125; else if (values.length &gt;= LARGE_ARRAY_SIZE) &#123; includes = cacheHas isCommon = false values = new SetCache(values) //过滤数组等于缓存之后的数组 &#125; // 处理内容 outer: // 每次遍历的原数组中的元素 for (let value of array) &#123; //如果有遍历器，对该元素调用一次，得到计算后的cumputed，否则computed和value一样 const computed = iteratee == null ? value : iteratee(value) value = (comparator || value !== 0) ? value : 0 // 正常过滤并且computed不为NaN if (isCommon &amp;&amp; computed === computed) &#123; let valuesIndex = valuesLength while (valuesIndex--) &#123; // 如果这个元素在过滤数组中存在，跳过 if (values[valuesIndex] === computed) &#123; continue outer &#125; &#125; // 如果不存在，添加添加进结果数组中 result.push(value) &#125; // 非正常过滤，调用includes方法，如果通过比较器的规则不包含，将该元素添加进结果数组 else if (!includes(values, computed, comparator)) &#123; result.push(value) &#125; &#125; // 返回结果 return result&#125; 中间对outer:关键词有点疑问，查了一下，可使用一个标签来唯一标记一个循环，然后使用 break 或 continue 语句来指示程序是否中断循环或继续执行。在这里是 continue 之后跳回到上一层，继续下一步循环. 请问大家是如何在实践中使用label语句的 label _.drop _.drop(array, [n=1]) 创建一个数组，返回从头开始丢弃n个元素。 123456_.drop([1, 2, 3]);// =&gt; [2, 3] _.drop([1, 2, 3], 2);// =&gt; [3] 这个常规想法也是splice。 但是splice会改变原数组，如果用还需要做个拷贝。 所以直接看源码是 1234567function drop(array, n=1) &#123; const length = array == null ? 0 : array.length return length ? slice(array, n &lt; 0 ? 0 : n, length) : []&#125; 源码里调用了库自带的slice _.dropRight _.dropRight(array, [n=1]) 创建一个数组，返回从右边起开始丢弃n个元素。 123456_.dropRight([1, 2, 3]);// =&gt; [1, 2] _.dropRight([1, 2, 3], 2);// =&gt; [1] 现在很多数组处理函数都配了从右开始处理数据，这种处理肯定不可能进行逆置后再处理，应该就是根据整个数组长度，然后从最后一位开始，根据Array.length 减去你要处理的长度。 对区间进行修剪。 一般来说如果是纯粹的循环，可以直接从末尾开始处理。 我们来看下源码是怎么处理的: 12345function dropRight(array, n=1) &#123; const length = array == null ? 0 : array.length; return length ? slice(array, 0, n &lt; 0 ? 0 : -n) : [];&#125; 看到依旧还是引用了内置的slice 只是传了一个-n 我们有必要来复习一下这个slice函数 12345678910111213141516171819202122232425262728function slice(array, start, end) &#123; let length = array == null ? 0 : array.length // 先判断是否为空,字符串会通过检测 if (!length) &#123; return [] &#125; start = start == null ? 0 : start end = end === undefined ? length : end // 判断越界情况 if (start &lt; 0) &#123; start = -start &gt; length ? 0 : (length + start) &#125; end = end &gt; length ? length : end if (end &lt; 0) &#123; end += length &#125; length = start &gt; end ? 0 : ((end - start) &gt;&gt;&gt; 0) start &gt;&gt;&gt;= 0 //把num变成一个无符号的32位的整数,JavaScript的数组的最大长度是2^32-1，所以这样做也避免了数组的索引超出界限。 let index = -1 const result = new Array(length) // 重新生成一个数组 while (++index &lt; length) &#123; result[index] = array[index + start] &#125; return result&#125; 可以看到 1234if (end &lt; 0) &#123; end += length&#125; 和预料的处理一致。 _.dropRightWhile .dropRightWhile(array, [predicate=.identity]) 从末尾对数组进行截取，从第一个不满足predicate 条件的元素开始截取数组。predicate接受三个参数（value,index,array） 1234567891011121314151617181920var users = [ &#123; &apos;user&apos;: &apos;barney&apos;, &apos;active&apos;: true &#125;, &#123; &apos;user&apos;: &apos;fred&apos;, &apos;active&apos;: false &#125;, &#123; &apos;user&apos;: &apos;pebbles&apos;, &apos;active&apos;: false &#125;]; _.dropRightWhile(users, function(o) &#123; return !o.active; &#125;);// =&gt; objects for [&apos;barney&apos;] // The `_.matches` iteratee shorthand._.dropRightWhile(users, &#123; &apos;user&apos;: &apos;pebbles&apos;, &apos;active&apos;: false &#125;);// =&gt; objects for [&apos;barney&apos;, &apos;fred&apos;] // The `_.matchesProperty` iteratee shorthand._.dropRightWhile(users, [&apos;active&apos;, false]);// =&gt; objects for [&apos;barney&apos;] // The `_.property` iteratee shorthand._.dropRightWhile(users, &apos;active&apos;);// =&gt; objects for [&apos;barney&apos;, &apos;fred&apos;, &apos;pebbles&apos;] 根据后置条件进行过滤剔除。 而且很明显可以进行function判断和对象判断。 因此肯定会先有一个类似 for in的循环对传进来的数组进行遍历。然后再分情况进行判断。 找到源码， 123456function dropRightWhile(array, predicate) &#123; return (array != null &amp;&amp; array.length) ? baseWhile(array, predicate, true, true) : []&#125; 对数组是否靠谱进行了验证之后就传到了 baseWhile这个函数进行处理。而且可以看到predicate将我们不定数的参数都包含了。 来看看baseWhile的源码 12345678910111213141516171819202122function baseWhile(array, predicate, isDrop, fromRight) &#123; const &#123; length &#125; = array // 如果是从右开始删除，下标指向数组末尾，不然指向-1 let index = fromRight ? length : -1 // 根据drop的方向决定下标是增还是减.并且同时进行迭代条件判断。 while ((fromRight ? index-- : ++index &lt; length) &amp;&amp; predicate(array[index], index, array)) &#123;&#125;//如果是删除元素，如果从末尾开始，调用Slice(0,index+1),否则调用Slice(index,length) //如果是获取元素，如果从末尾开始，调用 Slice(index+1,length),否则调用Slice(0,index) //最后返回切好的数组 return isDrop ? slice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length)) : slice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index))&#125; _.dropWhile .dropWhile(array, [predicate=.identity]) 从开始对数组进行截取，从第一个不满足predicate 条件的元素开始截取数组。predicate接受三个参数（value,index,array） 123456function dropWhile(array, predicate) &#123; return (array != null &amp;&amp; array.length) ? baseWhile(array, predicate, true) : []&#125; 没有传递dropRight参数，因此直接从左到右。还是基于baseWhile就不重复了。 _.fill _.fill(array, value, [start=0], [end=array.length]) 使用 value 值来填充（也就是替换） array，从start位置开始, 到end位置结束（但不包含end位置） 123456789101112var array = [1, 2, 3]; _.fill(array, &apos;a&apos;);console.log(array);// =&gt; [&apos;a&apos;, &apos;a&apos;, &apos;a&apos;] _.fill(Array(3), 2);// =&gt; [2, 2, 2] _.fill([4, 6, 8, 10], &apos;*&apos;, 1, 3);// =&gt; [4, &apos;*&apos;, &apos;*&apos;, 10] 填充函数，一看是对原数组进行改变。那么就需要先判断数组边界和开始结束的位置。然后遍历到指定位置就填充。 来看下源码： 123456789101112function fill(array, value, start, end) &#123; var length = array == null ? 0 : array.length; if (!length) &#123; return []; &#125; if (start &amp;&amp; typeof start != &apos;number&apos; &amp;&amp; isIterateeCall(array, value, start)) &#123; start = 0; end = length; &#125; return baseFill(array, value, start, end); &#125; 这里我们看到判断start是否存在还有start是不是number，但后面还有一个isIterateeCall，这个看字面意思好像是判断迭代参数。我们来看下源码： 1234567891011121314function isIterateeCall(value, index, object) &#123; if (!isObject(object)) &#123; return false; &#125; var type = typeof index; if (type == &apos;number&apos; ? (isArrayLike(object) &amp;&amp; isIndex(index, object.length)) : (type == &apos;string&apos; &amp;&amp; index in object) ) &#123; return eq(object[index], value); &#125; return false; &#125; 它的作用是判断start是否为遍历器的参数。 最后是用baseFill函数来完成功能 123456789101112131415161718192021222324function baseFill(array, value, start, end) &#123; var length = array.length; start = toInteger(start); // 转为整数 // 如果start小于0 当 -start的长度都大于数组长度，那么，就默认从数组第一个元素开始。不然就length + start if (start &lt; 0) &#123; start = -start &gt; length ? 0 : (length + start); &#125; // 如果没有指定end参数 或者end大于数组长度，就默认end为数组长度。不然的话就把end转成整型 end = (end === undefined || end &gt; length) ? length : toInteger(end); if (end &lt; 0) &#123; end += length; &#125; end = start &gt; end ? 0 : toLength(end); // 用一个循环来搞定 while (start &lt; end) &#123; array[start++] = value; &#125; return array; &#125; 我们可以看到，一个比较简单填充方法，为了健壮性需要做很多事情。 _.findIndex .findIndex(array, [predicate=.identity], [fromIndex=0]) 这个方法就像_.find，对数组从开始进行查找，该方法返回符合判断条件的第一个元素的索引 123456789101112131415161718192021var users = [ &#123; &apos;user&apos;: &apos;barney&apos;, &apos;active&apos;: false &#125;, &#123; &apos;user&apos;: &apos;fred&apos;, &apos;active&apos;: false &#125;, &#123; &apos;user&apos;: &apos;pebbles&apos;, &apos;active&apos;: true &#125;]; _.findIndex(users, function(o) &#123; return o.user == &apos;barney&apos;; &#125;);// =&gt; 0 // The `_.matches` iteratee shorthand._.findIndex(users, &#123; &apos;user&apos;: &apos;fred&apos;, &apos;active&apos;: false &#125;);// =&gt; 1 // The `_.matchesProperty` iteratee shorthand._.findIndex(users, [&apos;active&apos;, false]);// =&gt; 0 // The `_.property` iteratee shorthand._.findIndex(users, &apos;active&apos;);// =&gt; 2 一般来说，对数组查下标我们都是直接IndexOf，但是对对象进行查找。我们需要考虑是否是对象，需要做一些判断。对于对象的属性遍历用 for in。 接下来看下源码是怎么实现的: 12345678910111213function findIndex(array, predicate, fromIndex) &#123; var length = array == null ? 0 : array.length; // 数组不存在就返回-1 if (!length) &#123; return -1; &#125; var index = fromIndex == null ? 0 : toInteger(fromIndex); if (index &lt; 0) &#123; index = nativeMax(length + index, 0); &#125; return baseFindIndex(array, getIteratee(predicate, 3), index);&#125; 经过一系列判断，最终还是调用基础函数来实习功能，我们从最中心的getIteratee读起， 123456function getIteratee() &#123; var result = lodash.iteratee || iteratee; result = result === iteratee ? baseIteratee : result; return arguments.length ? result(arguments[0], arguments[1]) : result;&#125; 如果lodash.iteratee被重新定义,则使用用户定义的iteratee，否则就用官方定义的baseIteratee。需要强调的是，result(arguments[0],arguments[1])是柯里化的函数返回，返回的仍旧是一个函数 我们需要看看官方定义的baseIteratee的实现： 123456789101112131415function baseIteratee(value) &#123; if (typeof value == &apos;function&apos;) &#123; return value; &#125; if (value == null) &#123; return identity; &#125; if (typeof value == &apos;object&apos;) &#123; return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value); &#125; return property(value); &#125; getIteratee(iteratee, 3)，给了两个参数，按照逻辑，最终返回的是一个baseIteratee，baseIteratee的第一个参数value就是iteratee,这是一个函数，所以，baseIteratee函数在第一个判断就返回了。 这个判断到不是很理解，先放着。我们来看baseFindIndex 123456789101112function baseFindIndex(array, predicate, fromIndex, fromRight) &#123; var length = array.length, index = fromIndex + (fromRight ? 1 : -1); while ((fromRight ? index-- : ++index &lt; length)) &#123; if (predicate(array[index], index, array)) &#123; return index; &#125; &#125; return -1;&#125; 核心判断是(predicate(array[index], index, array) 而这里的predicate函数是之前传入的getIteratee(predicate, 3) 然后调用的是baseIteratee来判断。baseIteratee是封装好的遍历器（让遍历器不仅可以是函数，还可以是属性或者对象）。 这样大体是了解了，对细节感兴趣需要跟踪仔细推敲。 _.flatten _.flatten(array) 对数组执行扁平化一级操作 123_.flatten([1, [2, [3, [4]], 5]]);// =&gt; [1, 2, [3, [4]], 5] 对扁平化还是直接看核心函数baseFlatten源码： 1234567891011121314151617181920212223242526272829303132 * @param &#123;Array&#125; array 需要处理的数组. * @param &#123;number&#125; depth 扁平化的深度. * @param &#123;boolean&#125; [predicate=isFlattenable] 判断是否执行扁平化操作，对每个元素进行调用. * @param &#123;boolean&#125; [isStrict] 是否遵守predicate的检查. * @param &#123;Array&#125; [result=[]] 初始化结果值. * @returns &#123;Array&#125; 返回扁平化之后的数组. function baseFlatten(array, depth, predicate, isStrict, result) &#123;// 初始化下标从源头开始 var index = -1, length = array.length; predicate || (predicate = isFlattenable); //如果没有传入判断方法，这判断方法为isFlattenable(只有可以执行扁平化就执行) result || (result = []); // 如果没有传入的初始的结果数组，则结果为空数组 ////遍历数组中的每个元素 while (++index &lt; length) &#123; var value = array[index]; if (depth &gt; 0 &amp;&amp; predicate(value)) &#123; // //如果深度大于0并且通过了检查 if (depth &gt; 1) &#123; // //如果深度大于1（还需要扁平化），递归调用自身，并且depth-1,否则将这个元素值添加到结果数组 baseFlatten(value, depth - 1, predicate, isStrict, result); &#125; else &#123; arrayPush(result, value); &#125; // //如果不需要遵守判断规则，直接将value添加到结果中 &#125; else if (!isStrict) &#123; result[result.length] = value; &#125; &#125; return result; &#125; _.fromPairs() _.fromPairs(pairs) 此方法返回由键值对组成的对象。 123_.fromPairs([[&apos;a&apos;, 1], [&apos;b&apos;, 2]]);// =&gt; &#123; &apos;a&apos;: 1, &apos;b&apos;: 2 &#125; 这个看例子是直接生成一个对象，把参数迭代加进去。 来看源码: 123456789101112function fromPairs(pairs) &#123; var index = -1, length = pairs == null ? 0 : pairs.length, result = &#123;&#125;; while (++index &lt; length) &#123; var pair = pairs[index]; result[pair[0]] = pair[1]; &#125; return result; &#125; 和预计一样。 _.head() _.head(array) 返回数组第一个元素 这个没啥好说，直接取第一个。 1234function head(array) &#123; return (array &amp;&amp; array.length) ? array[0] : undefined; &#125; _.indexOf() _.indexOf(array, value, [fromIndex=0]) 1234567_.indexOf([1, 2, 1, 2], 2);// =&gt; 1 // Search from the `fromIndex`._.indexOf([1, 2, 1, 2], 2, 2);// =&gt; 3 在数组中找到第一次出现值的索引，用于等式比较。如果fromIndex为负数，则将其用作从数组结尾的偏移量。 功能很简单，主要是这个偏移量fromIndex 从示例中可以看到，不仅是从偏移量开始找，而且最终结果也是计算了偏移量。 1234567891011121314function indexOf(array, value, fromIndex) &#123; var length = array == null ? 0 : array.length; if (!length) &#123; return -1; &#125; var index = fromIndex == null ? 0 : toInteger(fromIndex); if (index &lt; 0) &#123; // 如果偏移量小于0 // 如果在length以内，则右偏移，不然从0开始 index = nativeMax(length + index, 0); &#125; return baseIndexOf(array, value, index); &#125; 查看baseIndexOf 123456function baseIndexOf(array, value, fromIndex) &#123; return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex); &#125; 跟着发现最后实习功能是baseFindIndex 调用baseFindIndex(array, baseIsNaN, fromIndex) 12345678910111213function baseFindIndex(array, predicate, fromIndex, fromRight) &#123; var length = array.length, index = fromIndex + (fromRight ? 1 : -1); // 循环，对每个元素调用判断方法，如果结果为true,返回对应的index while ((fromRight ? index-- : ++index &lt; length)) &#123; // if (predicate(array[index], index, array)) &#123; return index; &#125; &#125; return -1; &#125; _.initial() _.initial(array) 获取数组的最后一个元素。 12345function initial(array) &#123; var length = array == null ? 0 : array.length; return length ? baseSlice(array, 0, -1) : []; &#125; 直接切了最后一个元素然后返回切割后的数组。 _.intersection() _.intersection([arrays]) 创建包含在所有给定数组中的唯一值数组，以进行相似性比较。结果值的顺序和引用由第一个数组决定。 取出各数组中都有的元素，使用 SameValueZero方式比较（===） 123_.intersection([2, 1], [2, 3]);// =&gt; [2] 这把两个数组的交集求了出来。如果是我可能两重循环解决。 来看源码 12345678// 创建具备rest参数的方法 var intersection = baseRest(function(arrays) &#123; var mapped = arrayMap(arrays, castArrayLikeObject); // 将所有数组转化为类似数组的对象 return (mapped.length &amp;&amp; mapped[0] === arrays[0]) // //如果传入的数组个数不为0,并且第一个参数为数组，调用baseIntersection方法传入mapped，并将结果作为返回值返回，否则返回空数组 ? baseIntersection(mapped) : []; &#125;); 这个baseIntersection看上去就比较复杂了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 /** * _.intersection的基本实现, 不支持遍历器的简写. * * @private * @param &#123;Array&#125; arrays 需要处理的数组. * @param &#123;Function&#125; [iteratee] 遍历器,作用于每个元素. * @param &#123;Function&#125; [comparator] 比较器，作用于每个元素. * @returns &#123;Array&#125; 返回一个数组包含给定所有数组中共有的元素. */function baseIntersection(arrays, iteratee, comparator) &#123; var includes = comparator ? arrayIncludesWith : arrayIncludes,//如果有比较器，为arrayIncludesWith,否则为arrayIncludes length = arrays[0].length,//第一个数组的长度 othLength = arrays.length,//给定的所有数组的长度 othIndex = othLength,//给定所有数组的索引 caches = Array(othLength),//创建一个缓存给定数组个数的数组 maxLength = Infinity,//最大长度 result = [];//返回结果 //遍历给定的数组 while (othIndex--) &#123; var array = arrays[othIndex];//当前数组 if (othIndex &amp;&amp; iteratee) &#123;//如果不是第一个数组，并且有遍历器，对当前数组调用遍历器遍历每个元素 array = arrayMap(array, baseUnary(iteratee));//当前数组为调用之后的数组 &#125; maxLength = nativeMin(array.length, maxLength);//数组的最大长度 //如果该数组长度超过120就创建Set缓存数组中并添加到caches中（用于优化） caches[othIndex] = !comparator &amp;&amp; (iteratee || (length &gt;= 120 &amp;&amp; array.length &gt;= 120)) ? new SetCache(othIndex &amp;&amp; array) : undefined; &#125; array = arrays[0];//给定所有数组中的第一个 var index = -1,//数组索引 seen = caches[0];//第一个缓存数组，初始为undefined或者new SetCache(0) outer: //遍历第一个数组 while (++index &lt; length &amp;&amp; result.length &lt; maxLength) &#123; var value = array[index],//数组元素 computed = iteratee ? iteratee(value) : value;//如果有遍历器，对改元素调用,得到计算后的值 value = (comparator || value !== 0) ? value : 0;//如果有比较器或者value不为0，value为value，否则为0 if (!(seen//如果seen有值了，判断是否含有computed，否则判断结果中是否含有computed，如果都没有computed ? cacheHas(seen, computed) : includes(result, computed, comparator) )) &#123; othIndex = othLength;//其他数组的索引，初始为给定数组的长度 //遍历给定的数组，除了第一个 while (--othIndex) &#123; var cache = caches[othIndex];//缓存数组中的值 //太长的数组就是cache,短的就是arrays[index],判断是否含有computed，如果没有，跳过此次循环 if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator)) ) &#123; continue outer; &#125; &#125; if (seen) &#123;//如果缓存存在，将computed添加到缓存中 seen.push(computed); &#125; result.push(value);//将value添加到结果数组中 &#125; &#125; return result;//返回结果数组&#125; _.join() _.join(array, [separator=’,’]) 将数组中的所有元素转换为由分隔符分隔的字符串。 123_.join([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], &apos;~&apos;);// =&gt; &apos;a~b~c&apos; 讲道理这种插入式的我觉得遍历加入就挺直接的。 1234function join(array, separator) &#123; return array == null ? &apos;&apos; : nativeJoin.call(array, separator); &#125; 然后这个直接用的原生join… 是[Native Code] 有兴趣可以看看实现方式 _.nth() _.nth(array, [n=0]) 获取数组的索引n处的元素。如果n为负，则返回从结尾处的第n个元素。 12345678var array = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]; _.nth(array, 1);// =&gt; &apos;b&apos; _.nth(array, -2);// =&gt; &apos;c&apos;; 感觉只需要判断一下索引正负，然后根据判断是否加上数组长度。然后直接按下标取值就行了。 来看源码 1234567function nthArg(n) &#123; n = toInteger(n); return baseRest(function(args) &#123; return baseNth(args, n); &#125;); &#125; 123456789function baseNth(array, n) &#123; var length = array.length; if (!length) &#123; return; &#125; n += n &lt; 0 ? length : 0; return isIndex(n, length) ? array[n] : undefined; &#125; 1234567function isIndex(value, length) &#123; length = length == null ? MAX_SAFE_INTEGER : length; return !!length &amp;&amp; (typeof value == &apos;number&apos; || reIsUint.test(value)) &amp;&amp; (value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt; length); &#125; 可以看到思路是一样的，不过做了两个处理一个是对参数进行处理转为数组。一个是对下标进行验证。 _.pull() _.pull(array, [values]) 使用SameValueZero（===）从数组中删除所有给定的值以进行相等的比较。 123456var array = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]; _.pull(array, &apos;a&apos;, &apos;c&apos;);console.log(array);// =&gt; [&apos;b&apos;, &apos;b&apos;] 这个和filter类似，不过可以传入多个值。如果是filter来做，应该是做连续判断。 123456function pullAll(array, values) &#123; return (array &amp;&amp; array.length &amp;&amp; values &amp;&amp; values.length) ? basePullAll(array, values) : array; &#125; 12345678910111213141516171819202122232425262728function basePullAll(array, values, iteratee, comparator) &#123; var indexOf = comparator ? baseIndexOfWith : baseIndexOf, // //选择indexOf方法，如果传入比较器为baseIndexOfWith,否则为baseIndexOf index = -1, length = values.length, seen = array; if (array === values) &#123; //如果需要移除的元素和需要修改的数组一样，拷贝一份values values = copyArray(values); &#125; if (iteratee) &#123; // 如果存在遍历器，对数组进行遍历操作 seen = arrayMap(array, baseUnary(iteratee)); &#125; while (++index &lt; length) &#123; var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;//如果有遍历器对value进行调用，得到 计算后的value(也就是computed) //循环执行indexOf方法，如果seen中，直到找不到computed为止 while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) &gt; -1) &#123; if (seen !== array) &#123; splice.call(seen, fromIndex, 1); ///seen和array不相等即存在遍历器,对seen执行splice方法移除fromIndex的元素 &#125; splice.call(array, fromIndex, 1); &#125; &#125; return array; &#125; 也是在循环里剔除。 _.remove() .remove(array, [predicate=.identity]) 从数组中删除谓词返回真值的所有元素，并返回已删除元素的数组。谓词被调用三个参数：（value，index，array）。 1234567891011var array = [1, 2, 3, 4];var evens = _.remove(array, function(n) &#123; return n % 2 == 0;&#125;); console.log(array);// =&gt; [1, 3] console.log(evens);// =&gt; [2, 4] 直接对原数组做操作。感觉用Map可以做到。 1234567891011121314151617181920212223function remove(array, predicate) &#123; // 判断合法数组 var result = []; if (!(array &amp;&amp; array.length)) &#123; return result; &#125; var index = -1, indexes = [], length = array.length; // 将判断条件封装，支持简写 predicate = getIteratee(predicate, 3); while (++index &lt; length) &#123; var value = array[index]; // //调用判断方法返回true,将这个元素加入到结果中，将当前索引值加到indexes中 if (predicate(value, index, array)) &#123; result.push(value); indexes.push(index); &#125; &#125; basePullAt(array, indexes); ////调用basePullAt方法移除indexes中的元素 return result; &#125; _.reverse() _.reverse(array) 反转阵列，使第一个元素成为最后一个元素，第二个元素成为第二个元素，等等。 12345678var array = [1, 2, 3]; _.reverse(array);// =&gt; [3, 2, 1] console.log(array);// =&gt; [3, 2, 1] 用逆置数组算法完成是第一个想到的解决方法。 看源码是怎么解决的。 1234function reverse(array) &#123; return array == null ? array : nativeReverse.call(array); &#125; 12nativeReverse = arrayProto.reverse; 用原生，差点忘记原生还有这种操作。 _.sortedUniq() _.sortedUniq(array) 这个方法就像_.uniq，除了它为排序的数组设计和优化。 123_.sortedUniq([1, 1, 2]);// =&gt; [1, 2] 排序的同时还进行了排重 1234567891011121314151617181920function baseSortedUniq(array, iteratee) &#123; var index = -1, length = array.length, resIndex = 0, result = []; while (++index &lt; length) &#123; var value = array[index], // 计算遍历器后的值 computed = iteratee ? iteratee(value) : value; //如果index为0或者computed和seen不相等 if (!index || !eq(computed, seen)) &#123; var seen = computed; result[resIndex++] = value === 0 ? 0 : value; &#125; &#125; return result; &#125; _.union() _.union([arrays]) 使用SameValueZero从所有给定的数组中按顺序创建一组唯一的值，以进行相似性比较。 创建一个数组，包含给出的所有数组的值的唯一值. 123_.union([2], [1, 2]);// =&gt; [2, 1] 直接看源码 12345var union = baseRest(function(arrays) &#123; //先将给出的数组扁平化一级之后再调用baseUniq方法，并将结果作为返回值返回。 return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));&#125;); 再来看 baseUniq做了什么 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function baseUniq(array, iteratee, comparator) &#123; var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result; // //返回结果的引用（保存被遍历器调用过的值） if (comparator) &#123; //如果有比较器,不是常规比较，并且比较方法为arrayIncludesWith isCommon = false; includes = arrayIncludesWith; &#125; else if (length &gt;= LARGE_ARRAY_SIZE) &#123; //如果数组过长 var set = iteratee ? null : createSet(array); if (set) &#123; //如果没有传遍历器,只用转为Set对象，再转为数组,并将这个数组返回 return setToArray(set); &#125; isCommon = false; includes = cacheHas; seen = new SetCache; &#125; else &#123; seen = iteratee ? [] : result;//如果有遍历器，seen为空数组，否则为result的引用 &#125; outer: //遍历数组 while (++index &lt; length) &#123; var value = array[index], computed = iteratee ? iteratee(value) : value; value = (comparator || value !== 0) ? value : 0; if (isCommon &amp;&amp; computed === computed) &#123; var seenIndex = seen.length; while (seenIndex--) &#123; if (seen[seenIndex] === computed) &#123; continue outer; &#125; &#125; if (iteratee) &#123; seen.push(computed); &#125; result.push(value); &#125; else if (!includes(seen, computed, comparator)) &#123; if (seen !== result) &#123; seen.push(computed); &#125; result.push(value); &#125; &#125; return result; &#125; 我们可以看到没有遍历器的情况下，是创建了set对象来去重，不然要计算遍历结果然后再遍历剔除。 _.uniq() _.uniq(array) 创建一个无重复的数组版本，使用SameValueZero进行相等的比较，其中只保留每个元素的第一次出现。结果值的顺序由它们在数组中出现的顺序决定。 123_.uniq([2, 1, 2]);// =&gt; [2, 1] 去重。按照之前读的源码尿性，应该是做了一个缓存组，然后判断有没有迭代器，然后再循环判断有么有重复。 来看核心实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function baseUniq(array, iteratee, comparator) &#123; let index = -1 let includes = arrayIncludes let isCommon = true const &#123; length &#125; = array const result = [] let seen = result // 返回结果的引用（保存被遍历器调用过的值 if (comparator) &#123; isCommon = false includes = arrayIncludesWith &#125; else if (length &gt;= LARGE_ARRAY_SIZE) &#123; const set = iteratee ? null : createSet(array) if (set) &#123; return setToArray(set) &#125; isCommon = false includes = cacheHas seen = new SetCache //创建一个缓存数组 &#125; else &#123; seen = iteratee ? [] : result //如果有遍历器，seen为空数组，否则为result的引用 &#125; outer: // 遍历数组 while (++index &lt; length) &#123; let value = array[index] const computed = iteratee ? iteratee(value) : value value = (comparator || value !== 0) ? value : 0 if (isCommon &amp;&amp; computed === computed) &#123; let seenIndex = seen.length while (seenIndex--) &#123; if (seen[seenIndex] === computed) &#123; continue outer &#125; &#125; if (iteratee) &#123; seen.push(computed) &#125; result.push(value) &#125; else if (!includes(seen, computed, comparator)) &#123; if (seen !== result) &#123; seen.push(computed) &#125; result.push(value) &#125; &#125; return result&#125; 和之前的看到的很类似。 _.unzip() _.unzip(array) 该方法类似于_.zip，除了它接受一个分组元素的数组，并创建一个将元素重新分组到其预压缩配置的数组。 123456var zipped = _.zip([&apos;a&apos;, &apos;b&apos;], [1, 2], [true, false]);// =&gt; [[&apos;a&apos;, 1, true], [&apos;b&apos;, 2, false]] _.unzip(zipped);// =&gt; [[&apos;a&apos;, &apos;b&apos;], [1, 2], [true, false]] 我们来看实现代码: 123456789101112131415161718192021function unzip(array) &#123; if (!(array != null &amp;&amp; array.length)) &#123; return [] &#125; let length = 0 // 返回array中，所有是数组的元素，并且取得length为最大的数组的长度 array = filter(array, (group) =&gt; &#123; if (isArrayLikeObject(group)) &#123; length = Math.max(group.length, length) return true &#125; &#125;) let index = -1 const result = new Array(length) while (++index &lt; length) &#123; // //调用length次方法，每次再调用map获得array中每个元素对应index位置的值得数组，然后将包含这些这些数组的数组返回。 result[index] = map(array, baseProperty(index)) &#125; return result&#125; _.without() _.without(array, [values]) 使用SameValueZero创建一个排除所有给定值的数组，以进行相等比较。注意：与_.pull不同，此方法返回一个新数组。 123_.without([2, 1, 2, 3], 1, 2);// =&gt; [3] 排除元素。优先遍历。 1234function without(array, ...values) &#123; return isArrayLikeObject(array) ? baseDifference(array, values) : []&#125; 之前的Difference来完成。 _.xor() _.xor([arrays]) 创建一个唯一值的数组，它是给定数组的对称差异。结果值的顺序由它们在数组中出现的顺序决定。 123_.xor([2, 1], [2, 3]);// =&gt; [1, 3] 取交集。之前也找过类似的功能。它的写法是做双重遍历。但那很明显很低效。 来看核心实现: 123456789101112131415161718192021function baseXor(arrays, iteratee, comparator) &#123; const length = arrays.length if (length &lt; 2) &#123; return length ? baseUniq(arrays[0]) : [] &#125; let index = -1 const result = new Array(length) while (++index &lt; length) &#123; const array = arrays[index] let othIndex = -1 while (++othIndex &lt; length) &#123; if (othIndex != index) &#123; ////如果比较的数组和当前数组不是同一个数组，调用baseDifference方法取得array中不同于当前用于比较的数组的值 result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator) &#125; &#125; &#125; return baseUniq(baseFlatten(result, 1), iteratee, comparator)&#125; 很明显，还是需要双重遍历~","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"基础","slug":"基础","permalink":"http://wiki.haoqiao.me/tags/基础/"},{"name":"Lodash","slug":"Lodash","permalink":"http://wiki.haoqiao.me/tags/Lodash/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"框架","slug":"前端/框架","permalink":"http://wiki.haoqiao.me/categories/前端/框架/"},{"name":"Lodash","slug":"前端/框架/Lodash","permalink":"http://wiki.haoqiao.me/categories/前端/框架/Lodash/"}]},{"title":"《小狗钱钱》  《自我激励的100种方法》《活出生命的意义》","date":"2017-10-14T01:41:50.000Z","path":"wiki/阅读/《小狗钱钱》  《自我激励的100种方法》《活出生命的意义/","text":"前言原本应该是周五晚上固定时间写，但是昨晚遇到一个不可抗的bug，整整连续debug了5个小时。造成延后。今天还要补上昨天的体能训练QAQ，讲道理，玄学问题真的很难定位。。。 《小狗钱钱》 《自我激励的100种方法》 《活出生命的意义》简评过去一周在晚上每天花一小时读了几本书，一本是教人理财类的《小狗钱钱》，很像童话的故事书。我觉得挺适合全年龄阶段的人去阅读。 一本书心灵鸡汤《自我激励的100种方法》。我个人是觉得人嘛偶尔还是要给自己一些激励，免得在重复一天又一天的日子里慢慢消沉。虽然一直有做计划，规划，时间管理。但是情绪的调动后的执行力真的是完全不一样的。因此从《自我激励的100种方法》中还是能从中找到自己可以用的一些方法。 《活出生命的意义》是讲集中营生存者的一些感悟。嗯，个人是很难有共鸣，大概是以前看美丽人生和辛德勒的名单留下更多的痕迹。不过这种书的意义就是让你领略不一样的风景。 《小狗钱钱》 天下难事必做于易，天下大事必做于细。 发现很多国外的名言和引用的格言都是我们自己古代先贤的一些令人发省的短句。国学有必要去好好读一读。 好奇是好的，但是你绝对不能因为好奇而阻碍你去做一件事情，太多的人都是犹豫不决，就是他们觉得没有弄懂一样东西。而真正付诸实施要比纯粹的思考要聪明多了。 不是试试看，而是去行动！如果你只是带着试试看的心态，那么你最好只会以失败而告终，你会一事无成。尝试纯粹是一个借口，你还没有做，就已经给自己想好了后路。不能试验，你只有两个选择，做或不做。 我们必须确定我们想做一件事情，就是立刻着手做一些简单的，不要拖延等所谓的时机，做好做坏都是次要，关键是你着手开始做一些简单的起步，这样你就能慢慢将其完成。也会有更多机会去完善。你不做，什么都不会发生。 讲道理，看到上面这段的时候我联系了下自身之前学习的状态。感觉挺有道理。我很早以前刚入门学习的时候，初生牛犊不怕虎，想做什么，想学什么我都直接去学，去看书。然而到了后来，我有一个想法，在脑子里思考了很久，但是我觉得当时技术不够成熟，我就只是在ominifocus里面写下想法之类的。真正让我去做的想法只是其中的三分之一。近期我关注了一个知乎话题，发现别人的执行力远超自己。半个月到一个月他们就可以完成一个自己的小项目。发现差距再进行对比，我觉得自身还可以更加具有主动性，真正局限自己的不是想象力，不是技术积累，而是去立刻执行的冲动。即使是一开始做一些小的铺垫，也比在计划中夭折来的靠谱。 学习就是认识新观念和新想法的过程，假如人们始终以同一种思维方式来思考问题，那么始终会得到同样的结果。在自己还没有做成之前，不要轻易下结论。我们一生中投入精力越多的事情。其成功性越大。大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西。 这和debug是一样的，如果用同一种思维去解决问题，大部分问题会很容易解决，但是遇到玄学问题的时候，你必须脱离原来的思维，用另外一些方式，去思考，不然很容易陷入僵局。精力不是能量守恒，每天你其实可以做的事情比你想象的要多，把不必要的时间节省下来(比如弃游2333),你能在一些事情上有更多的时间去思考。有更多的事情去反思。把精力集中在喜欢的事情上挺重要，因为这意味着你很容易调动自己的积极的情绪去做事情，提升效率。 你必须设想自己已经拥有了这些东西，这样你的愿望就变成了一种渴望，你想象的越多，你的愿望就越强烈，那么你就会开始寻找机会实现自己的梦想。 这点我觉得在自己的经历中得到了证实。不过在一次次实现后发现自己渐渐减少了渴望，随遇而安，知足常乐的心态在这些方面造成了阻力。因此我也在逐步的去反转心态，继续去幻想去渴望。这样才有源源不断的学习动力。 你的自信程度决定了你是否相信自己的能力，你是否相信自己，假如你根本不相信自己能做到的话，你就根本不会动手去做。假如你不开始去坐，那么你就什么也得不到。 我觉得了解自己是一件非常重要的事情，很多人过于狂热的去了解他人，去理解他人。但是没有静下心来真正的去评审自己，去挖掘内心的自己。你想要什么，你的能力局限在哪里，你是否能调动你的大部分积极情绪去做事情，如何顺利的去完成一些你觉得很困难的事情，如果去调整你突变的情绪。你的自信源于你对自身的认知。你越了解自己，越自信。 尝试为别人解决一个难题，你就能赚很多钱。把精力集中在你知道的，你会的和你拥有的事情上。 这是本书理财核心。其实很多工作就是给别人解决问题。而现在服务性产业的蓬勃发展，也给了更多人更多的机会。比如公众号，比如外包等等。 一个人想要更幸福，更满意的生活，就得对自身进行改变。这和金钱无关，金钱本身既不会使人幸福也不会带来不幸，钱要么被用于好的用途或者坏的用途。一个幸福的人拥有更多钱会更幸福，一个悲观忧虑的人，钱越多，越烦恼。 德行需要匹配，只有驾驭住自身欲望的人，才能驾驭住生活，驾驭住金钱。 《自我激励的100种方法》 要生活在自我激励的状态中，关键就是但你每天早晨醒来，都要有所“求”。你尚未达到的目标，正是你对它的“饥渴感”使你不断进步。 心有所求,才会去行动。 就在当时当地把事情解决掉，不要把任何不必要的事情留给你的未来。现在就做，那么未来就永远是广阔而开放的。 具体场景需要具体分析，但大概率来讲，在不是非常紧急的状况下，随手完成一些只占用几分钟的事情会让你生活更加有条理。 自我激励往往受挫于我们选择怎样的方式理解人生的各种境遇。这是因为我们理解人生各种境遇的出发点不是环境本身，而是我们本身。实际上在任何环境中，我们都能找到黄金或者糟粕，我们找的是什么，我们就能找到什么。 心态决定你的处境。 好好想一想，你所看过的电视节目能够挖掘潜力，能否带给你灵感？然后再想一想，一个月读的书，甚至一周前读的电子期刊。什么给你留下了更有价值、更持久的印象？哪一种娱乐能够带给你更多自强不息的动力？ 把时间用在更有意义的事情上，现在online还是很有意思的。 很多人错误的认为过真实的生活就意味着很幸运找到一个合适的职位。有一个赏识自己的老板。后来明白了，你可以在任何地方、任何职位上和任务一个老板一起过你的真实生活。首先要找到什么让你快乐，接下来就去做。 当你说我不认为我能做到。那么就不要成为你自己，如果你做不到，那么就成为其他的人。成为那些可以做到的人。成为李小龙，成为你所崇拜的任何人。现实并不在意你是谁，只要你能够做到。 不知道生活目标的原因只有两个：1.你不与自己交谈。2.你不知道目标来源于何处（你认为目标来自外界而非自身） 如果你真的想得到一些新鲜的活力，那么试一试加倍你的目标，让它高到令你恐惧。然后把它当做你必须达到的目标来对待。这是一个自我承诺的游戏。你只有当真才能体会它产生的积极的作用。 在渐渐消沉的执行目标的时间中，突破自己的极限，带来新的活力。 如果你不知道你想要的是什么，那么就写一张你人生中最不想去做的事情，并且列出原因，列出每一个主要的难题和你不想去做的原因，你的烦恼和你所有能耐想到的负面的消极的东西。甚至包括那些还未发生成现实的东西，以及那些你不想让其发生为未来的东西。 这个方法简直强大。适合没有目标的人群。你越不想要什么，你越恐惧什么，那么能制约这些东西的目标，其实就是你需要达到的，你需要拼尽全力去争取的东西。 《活出生命的意义》摘录没什么意思。不过我从中看到的是，每个人都需要独处，将自身置于一个完全脱离人群的环境，当你被幽静环绕，你就容易沉下心去和内心对话。当然现在的前提是你需要放下手机2333. 每个人都有向往人群的渴望，就像羊拼命挤向羊群，因为羊群意味着安全感。 真正重要的不是我们对人生有什么指望，而是人生对我们有什么指望。我们不该继续追问生命有何意义，而是认清自己无时无刻不在接受生命的追问。我们不能以说话和沉思来答复，而应该以正确的行为作为答复。 我们终将明白,生命的意义在于探索人生问题的正确答案，完成生命不断安排给每个人的使命。 结尾因为几本书调节了自身的情绪，对于以前一些我懒得做的事情，比如组织社群一起做一件事情。我都尝试着有了一个开头，我觉得能改变自身以往的观念，然后再慢慢对自己提高要求，不断进行自我的追逐，可以让我每天迸发出更多的精力。","tags":[{"name":"自我提升","slug":"自我提升","permalink":"http://wiki.haoqiao.me/tags/自我提升/"},{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/tags/阅读/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://wiki.haoqiao.me/tags/读书笔记/"},{"name":"读后感","slug":"读后感","permalink":"http://wiki.haoqiao.me/tags/读后感/"}],"categories":[{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/categories/阅读/"}]},{"title":"《大秦帝国》  《千面英雄》","date":"2017-10-14T01:41:50.000Z","path":"wiki/阅读/《大秦帝国》《千面英雄》/","text":"前言这周读的东西挺散，也有书比较厚的原因，《大秦帝国》大概7000多页。后来读了400多页停了。《千面英雄》读了一半。 《大秦帝国》一开始我以为是正史，没想到是小说。然后作者是一个崇拜秦朝的狂热粉丝。一般来说偏执狂都会有不同人的观点。本着了解的态度继续跟踪读下去。开头非常吸引人，六国谋秦，国耻昭昭，求贤令，商鞅变法。大气磅礴的战国，性格各异的国君，尔虞我诈的计策，以及作者脑补的各种心理描述，都很吸引人。但后来为什么停止了呢，还是偏执的锅。作者太狂热秦朝了，然而历史应该是客观的，太主观将秦孝公描述的各种高大上，尤其是后面五马分尸商鞅，写的太戏剧性，个人受不了于是赶紧悬崖勒马，准备后面找正史来校正。不过如果说按照小说来评分，这本书已经算非常不错了，作者的私货也不少。 下面举几个例子 “帝国”是一个历史概念。它一般包含三个基本标准：其一，统一辽阔的国土（小国家没有帝国）；其二，专制统治（民主制没有帝国）；其三，强大的军事扩张（无扩张不成帝国） 魏赵韩三国，原是老牌诸侯晋国的三家大臣，势力坐大后，三家共同瓜分了晋国。周威烈王于魏文侯四十三年不得不正式册封魏赵韩三家为诸侯国，迄今不过四十余年。这就是说，七大战国中，有四个是坐大夺权建立的–齐魏赵韩；一个是山高水远先自立而后被王室认可的–楚；只有燕秦两国是正式册封立国而一脉相延的诸侯国。燕国是西周的开国诸侯，秦国是东周的开国诸侯，燕国比秦国恰恰老了整整一个时代。 这段话就建立了一个详细的鄙视链，正统鄙视篡位的，篡位鄙视落后地区的。 庞涓根本不在乎那些纨绔膏粱者如何蔑视他，也不在意将士们对他简朴起居的赞颂，他深深懂得，在连绵刀兵你死我活的战国时代，立足的根本点是功业，是胜利。作为三军统帅的上将军，若果丧师失地，将士们的拥戴赞颂会在一夜之间变为咒骂或叛乱。若果能破国拔城，那些纨绔膏粱们也会在一夜之间跪拜在他的脚下。成者王侯败者贼，在刀兵铁血的年月，这是一条永远的铁则。 成王败寇皆是如此。 在七大战国中，惟有秦国没有确定宣示自己的德性，但却是举国尚黑，令列国百般嘲笑，说秦国蛮荒之地不懂王化。秦国却是不理不睬，依旧黑色不改，在战国眼里成了一个乖戾怪诞充满神秘的西部邦国。 读这段的时候我觉得历代秦朝国军都有很大的野心啊，德行为黑，黑纳七色。有气吞天下的野心。 由于落后，由于穷困，由于稳定，由于战争，秦国世族和乡野庶民的种种差距，远远不象东方世族与庶民那样有天壤之别。秦国世族在战争中的伤亡丝毫不比庶民少，生活上想奢侈排场也没有条件。一旦兵连祸结，世族庶民一般艰苦一般流血。所有的世族子弟，都是少年从军，浴血奋战，任何一个家族都可以数出历代成百上千的战死者。这种不大的差别，使秦国世族在山野庶民中有着很深的根基，某种意义上说他们溶为一体也不为过。正是这种相安无事的稳定和谐，使秦国世族和乡野庶民都没有改变现状的强烈愿望。世族中没有分化出东方那样的新地主，也没有产生东方那样的士人阶层；庶民虽有怨言和不满，但却从来没有发生过几乎同样落后的楚国那样的群盗暴动，或周室洛阳那样的百工起义。三百多年中，秦国朝野没有改变这种”一体穷困，同甘共苦”的愿望。平民如此，世族更如此。 这段很有触动，当一个群体习惯了贫穷，如果有人想要改革，第一个面对的就是昔日的伙伴。 读后感读这本书的时候，最让人感触深刻的应该是”赳赳老秦，共赴国难”吧。多代国君的积累，隐忍，秦人在那么艰苦的环境下，秦孝公作为一个国君能忍常人不能，为了让秦国复兴所做的努力和尝试。当秦人不仅拥有冷水无法浇灭的热血，也懂得了卧薪尝胆的隐忍，强大只是时间的问题。 可惜原本挺好的设定，后面写的尬死我了QAQ… 《千面英雄》看这本书是因为它的简介很吸引人，《星球大战》的导演乔治-卢卡斯从中吸取了很多，并将其作为蓝本。它给很多艺术家提供了素材和灵感(因此这本学术性很强的书非常抽象) 这本书看了一半，大概是将人类心理学和神话故事结合，并梳理了大量的寓言，民间神话来印证自身的观点。 正如我们很快将会看到的，无论是在东方神话广阔的、几乎无边无际的形象中，还是在希腊神话充满力量的叙述中，或是在《圣经》壮美的传奇中，英雄的冒险经历通常遵循以上描述的核心模式：离开凡人的世界，进入某种力量之源，然后返回凡人的世界，生命得到了提升 最后作者将其梳理成一个英雄成长路线，这和美国很多大片的套路是一样一样的，这也是为什么这本书那么有名的原因之一吧0-0，美国英雄主义大片都从中得到了套路的精髓。。。 用一句话来概述这本书，神话是梦的本质，或者梦是精神动力学的征兆 结尾草草结束了本周的总结，主要是读的这两本没啥好讲的。而且还木有全部读完。本周花了挺多时间去读框架源码…大概这个借口找的比较好~下周继续","tags":[{"name":"自我提升","slug":"自我提升","permalink":"http://wiki.haoqiao.me/tags/自我提升/"},{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/tags/阅读/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://wiki.haoqiao.me/tags/读书笔记/"},{"name":"读后感","slug":"读后感","permalink":"http://wiki.haoqiao.me/tags/读后感/"}],"categories":[{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/categories/阅读/"}]},{"title":"国王 武士 祭司 诗人","date":"2017-10-06T14:17:17.000Z","path":"wiki/阅读/国王 武士 祭司 诗人/","text":"前言 最近把很多精力投入到了对一个运行3年的Web应用进行版本迭代和功能添加。国庆也一直投入时间进去,于是日常除了体能训练就是coding,后来想想还是得找个其它事情做做，于是给自己列了一份书单，定了一个长期规划。《国王 武士 祭司 诗人》是偶然发现的一本书，中译本看完发现只有55页,比英文版浓缩好多，但是都能反复咀嚼。之前是被简介吸引的 它很好的把社会上表象的男人问题，清晰的投射到了荣格原型中，用一个易懂又毫不乏深度的系统来向我们阐述了“成熟”需要什么样的外部条件，和我们每个男人需要如何去认识自己的内在心智 因此我列的阅读理由是 更深层次的去审视自己。类似的书之前没遇见过。觉得值得一读。 后来花了两个晚上读完觉得还是挺有收获。因此在每周五的读书笔记整理中将这本书进行整理。 正文《国王 武士 祭司 诗人》这本书主要是根基于荣格心理学通过心理学模型一步步发展来解释男人如何变得更成熟。 整本书阅读完后我想到了很久以前看到的一句话: 人的一生会经历三个阶段 一 发现自己不是世界中心的时候。 二 发现自己再怎么努力，有些事情也是无能为力的时候。 三 在明知有些事情可能无能无力的时候，还尽力去争取的时候。 这也恰好对应了这本书的心理模型的几个阶段。 本书分为2个层次，男孩和男人。 男孩阶段的四个原型分别是神圣男孩(The Divine Child)，早熟男孩 (The Precocious Child)和恋母男孩(The Oedipal Child)，以及最后一 个，英雄男孩(The Hero) 男人阶段的四个原型是诗人，祭司，武士，国王 不论是男孩还是男人的内心，都由这些原型组成。每个原型主宰着我们 每一部分的心智，对待世界和他人的方式。在依赖机制原型(男孩心理)和责 任机制原型(男人心理)中间，存在一条清晰的界限。从男孩心理出发，在模 型中清晰的划定了一条进化的道路，引领男孩看到更开阔的生命景致，同时 打下男人心理的根基。此外，在每个原型的坐标轴上，不仅分为不成熟和成 熟两个阶段，在男孩和男人的阶段内还各有一个金字塔，在塔的顶点可以找 到原型的中心位置，在塔的左右角分别是正负阴影位置。当我们不能激发一 个原型的中心位置的时候，我们会自动的被这种原型的两极的阴影所控制。 当我们意识到一种原型在我们的人格和心理中占有过分强大的统治地 位，必须用其它原型的力量来平衡它时,或者当我们意识到我们依照阴影面 中的积极或消极来行动(而不是完整而成熟的一面)的时候，心理的治愈和整 合就会发生。 男孩是他自我中心(ego)的奴隶书中比较明显的就是译者个人的私货。比如对男孩和男人的区别： 男孩式的年轻漂亮和朝气取代了成熟的男性魅力成为当下 文化推崇和赞扬的主流。这种现象在各式各样的文化领域中随处可见，就好 像当红的男子组合里的花样美男、运动场上雄性荷尔蒙爆发的运动员们、广 告里铺天盖地的宣扬的“随心所欲，为所欲为”的不负责任的人生观，潮流音 乐追捧的“唯我独尊，挡路者死”的风潮，股市和房市里经纪人们金钱至上,自私自利的生活方式，影视剧里帅哥的大行其道，观众对英雄角色的追捧， 人们对神童的盲目崇拜等等，这一切无不是当今世界男孩泛滥，男人不再的 真实写照。 现在在舞台上、影视里、书本里，乃至生活中 被塑造的成功男人的形象无不根植于对性、名声、金钱和权力的追求，他们 的价值所在都来源于这些不安定的外在因素。人们被误导，被迷惑，变得越 来越看重身外物的价值，在乎别人眼中的自己，追寻名利，而真正重要的东 西则被丢弃在一旁无人问津。 这让我想起了一些美剧中父亲的角色，他们总是沉稳，容易给他人安全和可靠感。 男孩是自我中心的奴隶，而男人则是自我中心的主人 男人的特质可以如此描述: 他们沉稳，处事不惊。能够在危险中保持镇定。他们不容易被冒犯，却很容易能给人带来安全和可靠感。他们从不寻求关注和爱护。他们生活的趋势是给于他人认同，给于爱。他们习惯于慷慨的给于他人帮助。他们深知，助人强者无不自强。他们的生活有确定的使命，行动和思维从不混乱。他们能够忍耐痛苦，但依旧敞开心活着。他们不怕被骗，被看不起。他们从来不为自己辩解，因为他们知道自己是谁。 男性启动仪式。 在古老的部落中，当男孩子长到14岁左右，会突然被部落的男人们集 体从他母亲那里把他抓走，对男孩的殴打，恐吓，各种催眠与暗示，让他认 为已经不能够再依赖成人，不再是孩子了。在角色转换完成之后，他会像其他成人一样承担成人应该承担的站岗，打猎，抵御侵略等社会责任。启动仪式的严密性非常重要。在不同的部落有不同的仪式形式和长度,在美洲某些印第安人部落，一个仪式甚至会长达3天之久。我们上面的例子 取自上个世纪的新几内亚岛:如果孩子在无意间发现了是村民装扮的怪兽， 或者在其中一些恐吓的过程中孩子没有遵守规则，例如“呆在原地不动” - 而 是被吓跑了，村民们会宣告这次启动仪式的失败。接下来，他们会把这个孩 子杀死，并吃掉。 这样就可以确保，所有的男孩在成长到这一部都要成功的变成男人，不成功的就杀掉。他们不能够依靠成群结队的小男孩们打猎站岗，保卫家园。 这是保证部落存活的必然性处理。 简单的来讲就是从依赖别人到负责的过程。而且部落文化更加直接不成功就是死翘翘。。。 神圣男孩 The Divine Child 神圣男孩代表了生命的源泉，代表了创造力的原始动力。你在看到孩子的时候的那种说不上来的欣喜感。是这个神圣孩子能量的最初表现形式。 神圣男孩最大的敌人，是他自己的影子。他的影子分为正负两级： 正极:暴君 他是整个宇宙的中心，所有人存在的原因都是去为了满足他的需求。他 狂妄自大，对他人和自己不负责任。心理学家会把这个叫做Pathological Nar- cissism (病态自恋)。暴君的问题在于，他意识不到他并不是整个宇宙的中心.一个男人很容易会变成他内心的这个小暴君的奴隶，他必须取得别人都有的物质财富，车，房，手表，只要是世界上存在的，他都想要。暴君想要的，是什么都不用做，好东西都来找他.他想象自己是最重要的人，于是他经常贬低他人。 负极:懦弱的王子 他会显得毫无性格，没有生活的激情。他看起来虚弱，无助，他需要被抱着，被安抚，被裹得严严实实的抱来抱去，轻拿轻放。但实际上，他的这种懦弱是伪装的。他装成一个无助的受害者，去欺骗他的父母，这样他可以得到他想得到的.通过他人同情来得到自己想要的。 懦夫在关键的时候爆发，会立即转向暴君极，变的异常暴力。一个在学校经常被欺负的懦弱孩子，会突然带刀到学校捅死他所有的室友。 早熟男孩 The Precocious Child 早熟男孩是我们好奇心的源泉，他代表了我们探索与猎奇的本能。他带领着我们去尝试新鲜事物，对未知世界探索。他不仅让我们对外部世界，还有对人的内心世界都充满了好奇:为什么有些人会做有些事?为什么有些人会有某些感觉? 他可能会是内向的，喜欢反思的。他可以看到一些别人看不到的事物之间的联系;他也可能会有外向的脾气，迫不及待的给周围的人展示它的洞察力与才华。 如此的好奇心，探索的精神与源动力，继续推动的这个男孩的智力，直到他成年后成为一个成熟的祭司(The Magician)。 早熟男孩也携带着正负两级阴影. 正极:博学的骗子 The Know it all Trickster 博学的骗子最大的特点是:自作聪明.他们是创造表面假象的专家，通过欺骗的手法得到自己想要的博学的骗子喜 欢争夺餐桌上的话语权，和别人争论，证明自己是更正确的。它贬低，藐视 那些和他观点不一致的人，不知道他知道的东西的人，因为他“什么都知 道”。他不愿意去付出努力，不愿意诚实的依靠劳动得到某些东西。它只想什么都不用做，去得到更多，得到本不属于他的。他不愿意承担任何责任，但他想得到承担责任所得到的报酬。他深深得嫉妒别人的才华，别人的好奇和学习的能力。每当他看到别人也可以很优秀，他会想尽办法阻拦别人比他变得更聪明。 负极:天真的蠢货 The Naive Dummy 他显得很笨，经常听不懂一些笑话，学习成绩不好，身体失衡。在学校的运动场上经常因为笨拙被人取笑。别人都学会了乘法表，代数公式。而他总是最后一个，他显得比别人慢很多。 但是这是一种假象。他知道的要比他表现出来的更多他想让你看到他愚笨的假象，让你根本就不会想到是他。 恋母男孩 The Oedipal Child 恋母男孩是温暖的，和别人相处融洽的，富有情感的。是我们的博爱的精神境界的源泉。 正极 妈妈的宝贝 The Mama’s Boy 他在交往中什么都不愿付出，不想担负责任。因为现实中的男女关系有很多复杂的感情，麻烦，和不尽如人意的地方。现实中是没有女神的。 负极:梦幻宝贝 The Dreamer 他什么都不想做，也什么都做不成。他对生活，和现实中的人没 有真实的感情。看起来有种淡淡的忧伤和抑郁。他的幻想会非常的脱离现 实。当别人都一步步踏入生活，了解人的真实情感,了解这个真实的世界的时候，会躲在他自己的梦幻世界中。“真实”对他来讲，太丑陋，太冷酷. 英雄男孩 The Hero 他所向无敌，不管是什么敌人，他都能击败，不管是什么困难，他都能摆平。它是我们幻想中男性气概的顶峰。 英雄的阴影可以被总结成一句成语:欺软怕硬 英雄原型不仅不会退化掉，而且他的出现预示着男人成长的重要一步:激活男孩强烈自我认知，让其具备和母体剥离的初步条件。 英雄原型调用了男孩所有的雄性能量储备，去推进到他心理的边缘地带，帮他暂时切断他体内存储的大量的雌性能量，去成为一个独立的，在心理上能够自生自灭的雄性个体。只有当这样的个体形成后，他才会被激发出来他个人的使命，去给这个世界带来新的创造。 英雄原型的出现，是为了预备男孩的依赖机制的死亡，而进一步迎接男人的诞生。 正极:恶霸 The Bully 恶霸总想去通过他的力量来显示自己，他喜欢在周围的人中争夺霸主的地位。如果他的地位被挑战了，他一定暴怒，立即出手打击敢于挑战他地位的人。 他不喜欢团队工作，他总是喜欢一个人。他对自己的实际能力有一种自我膨胀的意识。他认为自己可以打败最不可能的敌人，完成最不能完成的任务。然而恶霸的最终结局，是他会被自己的傲慢击败。 负极:懦夫 The Coward 当面临冲突的时候，懦夫最希望的，是找借口逃脱。在平时，他习惯于让自己被其他人欺负:无论身体上或者心智上。他也和恶霸一样不合群，因为他秘密地认为，其实他还是最强的。当他面对比自己个头小的孩子的时候，他恶霸的一面就展现出来了。 从男孩到男人 心理上男孩仍旧是需要死亡的，在这之后才能迎来心智独立的男人的重生。而男孩死亡的条件，就是英雄原型(The Hero)的彻底战败:死亡。 当这个认为自己无所不能的英雄，遇到生命中最重要的，却又是真正的 难题的时候，- 我们拿一条巨龙来比喻 - 他勇敢的冲上前去，天真的认 为，“屠龙”是理所当然的时候，他被巨龙一口活吞了。 男人会经历一段匪夷所思的变化:他的傲气被削弱，每一步，仿佛都是拖着虚弱的身体走出一个沉睡已久的洞穴。他看看周围的世界，发现一切都还没变，但一切又都不一样了。 他开始认识到:自己的能力其实非常有限，人生中的问题远远要比他想象得大得多。他开始明白，为什么很多成年的男人都那么低调和谦虚。每当他回想起过去的自己，都会含着羞愧的苦，一笑而过。 此时此刻，男人重生了。 男性启动仪式结束后，一个生活在依赖心理机制的男孩，开始走向了以责任机制为主的男人。 武士 The Warrior 武士是一直清醒的，警惕的。他知道如何专注他的心智和身体，知道他想要什么，而且知道怎么得到他想要的。同时，武士也是一个战术家，他能够适应变化作出最好的判断和战术。他知道自己占上风还是下风，是否能击败敌人，完成任务，是否应该临时隐退，是否需要独辟蹊径。 武士非常清楚自己的能力范围。英雄从来不知道 天高地厚，他对自己的能力抱有一种浪漫主义的幻想。而武士了解现实，没 有丝毫的妄自尊大。他对自己的能力和要完成的任务，有脚踏实地的作风。 他的行动从来不“过头”，从来不显摆自己。武士从来不用过分的行为来试图 证明给别人或者自己，他具备有他所希望的能力。 武士是死过后重生的英雄. 武士能够感觉到死亡随 时都有可能降临，因此，一个被武士能量引导的男人知道他生命的短暂.这并不让他感到悲伤，反而让他充满了生命力。而这种强烈的内心体验只有他自己知道，而且从不外露。 他用这种对生命的激情，引导他做每一个选择，一个武士把每一件事做的程度，就像是他活在这个世界上最后一天一样。“犹豫”这个词在武士的词典里不存在。因为犹豫会产生怀疑，怀疑会产生麻痹。麻痹就会导致最终的失败。他100%得投入到生活中，从不犹豫不决，从不麻痹。 当一个男人去为了一个国家，一个民族，一场运动，一个大于他自己的事物而活着的时候，他成为了一个拥有成熟武士原型的男人。在这个阶段里，他的全部生命围绕着这样一个超越自我的使命，个人的得失则是完全次要的。 正极:虐待狂 (The Saddist) 虐待狂把自己驱赶到生命的边缘。我们知道这样的人:医生，律师，创业家，政客，经常工作到很晚的经理，施加压力给自己的员工，强迫自己的员工加班。所有的工作狂人格，都是一种指向自己的暴力倾向。这些男人能忍受痛苦完成很多工作，然而他们付出的代价是自己的健康。最终以工作劳累而心脏病发作的男人比比皆是。 武士驱使自虐的能量，来自于深深的焦虑和不安和找不 到自我价值。当一个武士没有国王(The King)的命令去服从的时候，他生 命变得毫无方向，能量无从释放，于是会开始到处施展他们的战斗能力，攻 击他人，攻击自我。 负极:受虐狂(The Masochist) 他倾向于自我的暴力，让他不仅自己自虐，而且还喜欢受虐. 你会发现他们什么工作强度都能忍受，上司说什么都说答应，允许别人持续得冒犯，侵犯自己的权利。他感到自己没有能力，抑郁，没有目 标，得过且过。活在别人的虐待中似乎是唯一的让他能感到“还活着”的方 式。 受虐狂实际上是一个面具。如果权利落在他的手中，他很有可能会突然爆发，自己突然变成一个经常压迫员工，以摧残别人生命为乐的虐待狂。 祭司 The Magician 祭司用他人生的智慧，去引导年轻人思考，去构建一个不仅是物质上，而且精神上丰富的世界。 正极:残酷的专家 The Manipulator 残酷的专家求知的目的并不引导别人，帮助别人。他希望通过了解别人不了解的知识而强大起来，用来攻击别人。他藏匿信息，摆布他人，阻止他们拥有更强健的心智。他经常主动误导他人，污蔑，嘲笑他人，并从中取乐。他这样对别人的伤害，同时也在伤害自己。因为，当他不去帮助别人的时候，他用知识让自己更了不起，让别人崇拜他的同时，他的思想会因此固化，让他也不能正常的，积极向前生活。最终，他自己也不能得到提高。 负极:无辜的阴谋家 The Innocent One 阴谋家想得到祭司的身份地位，但不想去付出祭司所要付出的努力。他认为，求知不需要很多，能超过别人就足够。 他相当的懒惰，没看过几本书，真正钻研过，却喜欢吹嘘自己的知识成就。而实际上他所知道的东西只是皮毛。于是，不想付出努力，又要去标榜自己的聪明才智，他不得不攻击别人。其他的有见地的学说，学者的著作，他都喜欢批判一下。尽管他自己还不明白那里面在说什么。他认为那些都是值得怀疑的，都没有他聪明。 他也因此嫉妒，害怕那些真正努力成长的人，他期望去阻止其他人的成 长。在他“足够”的努力之间，如果能够绊别人一脚，减缓别人的成长速度， 就更完美了。他会因为别人的失败而偷乐。 诗人 The Lover 诗人能量的基础，来自于对万物的感知，和爱的能力。他具有多彩缤纷生活的激情，他充满了生命力，对食物，性爱，情绪的渴望。当他面临生活的艰难时拥有无限的创造力，让他能够毫无障碍的进行情感的联结与表达。诗人的存在，是去满足我们对情感的饥饿。 诗人对生命的热情不是通过认知的，而是通过感受。诗人渴望，身体上的和心灵上的触摸和被触摸。在诗人的世界里，没有规则，没有道德伦理，没有任何边界和约束，他强烈的生活在万物皆一体的感受中。诗人是我们能够博爱的基础。 诗人是我们每个男人最陌生的，却又都拥有的原型。不管平时的工作和生活中你有多么忽略他，在某些人生感动的时刻，他的作用在你身上是不可忽略的。 比如，仅仅因为你喜欢某个女人，你就会为她做很多你平时不会做的事情。即便是你知道你们没有什么结果，她一旦开口，你就感到无比的动力。在现实中，男人的生命在大多数时候是被捆绑起来的。在闲暇之余，他会用自己的方式寻找自己的诗人:在游戏中，在小说中，在故事中，在爱情中。 诗人会让武士和祭司更具有情感，具有人文精神，而不是一味的追求目标和知识。反过他来也需要他们的帮助，他需要武士的果断来铲除无控制的享乐，他需要祭司的才智来让自己从情感的纠缠中脱身，对待人生更客观，更长远。 瘾君子 The Addicted Lover 当诗人缺乏国王引导的时候，他的第一个问题是:为什么我需要约束我的这些无尽美妙的体验? 于是，一个缺乏自我约束的诗人，也具备了成瘾性的人格。他很容易会落入毒品，香烟，酒精的魔掌中。 麻木情人 The Impotent Lover 麻木情人精神萎靡，生活没有激情。他对周围环境中的颜色一点都不敏感，仿佛世界是黑白的一样。他经常失眠，或者早上起不来，说话无精打采，吃饭没有味道。 国王 对大多数男人来讲，国王往往是最后一个上线的原型。 当国王原型上线的时候，我们看到了神圣男孩从降生之日的惹人注目，发展到了具备成熟能量和能力来去改变世界的现有格局。他有强烈的方向感和勇气去带领武士作战，过人的智慧去和祭司一起治理臣民，和一颗向善的心和诗人一起让他的领土充满爱。 国王拥有主权去界定他国度的边界。在国界之内是祝福与繁荣，在国界之外是无秩序与混乱。他坐在大地的中心，将他的能量释放到国界内的各个角落，保护臣民免受外来侵袭，并且，如果有必要的话，支配武士来到边疆，进入战斗状态。 国王的男人的使命感的最终载体，他是一个从神圣世界 带给现实世界中男人能量的大动脉。在国王原型的上线之前，一个男人不会知道他的使命究竟使什么。而当它出现在一个男人的心智中时，他就会像是一个有威望的父亲，他在给女人带来一个令人向往的世界的同时，让她们感到权威，稳重，与信赖。 对于还走在成熟道路上年轻人来讲，得到国王的祝福显得非常重要。 当一个年轻人被成熟的国王祝福的时候，他的内部结构会发生奇妙的变化。杂乱的思绪会突然被平伏，怀疑和焦虑会在那一刻烟消云散。因为，国王的远景为他拨开了云雾，用祝福的力量送他上路。 国王的阴影，其实就是由早期神圣男孩的阴影携带过来的。每个人，每个原型都有阴影，区别是，有些人大部分时间生活在中心位置，有些人则生活在阴影中。那么，是什么导致了一个年过不惑的男人，仍旧迟迟不能够唤醒他中心位置的国王? 早年家庭对一个男孩的过度溺爱或过度严厉，歪曲的母爱，和父亲不加 以引导(缺乏祭司能量)或者施暴，那么孩子就会从幼年期开始经历扭曲的 心理:他要么感到自己就是世界的中心，衣来伸手饭来张口;要么，他就一 无是处，来到这个世界完全是多余的。这为孩子的未来埋下了暴君/庸君的 种子。甚至，懦弱的他，会连越过男孩英雄阶段的机会都没有。 正极:暴君 The Tyrant 和处在中心能量位置的国王不同，暴君不希望去祝福，不愿意创造，而且，由于惧怕新生力量(其他神圣男孩)威胁他的国度，他必定要扼杀新生。 我们每个人内心中的一个暴君。如果我们处在权威位置上，当我们面临 压力，被强烈挑战的时候，暴君会随时跳出来，帮你“解决问题”。而他对你 臣民的伤害，则需要你更加努力去补救。 负极:庸君 The Weakling 一个庸君会觉得自己什么都不是。他只知道享乐，任其国度混乱，民不聊生。他平时看起来没有什么威胁，而一旦被挑衅，他的暴君本质会突然跳出来，做出毁灭性的决定。 认知性距离 Cognitive Distance 认知性距离是指原型能量和自我之间的距离。即，你可以展现这些精神品质，但你本身不是这些能量。这些天赐的精神品质只存在于每一刻的你的疏通当中，而你永远都不能成为这些能量本身。你只能通过每时每刻行为的选择，来让这些能量通过你散发到这个世界中来。 你的才华，勇气，纪律，爱心，祝福，都是天赐之物，并不 是你作为一个凡人可以拥有的。而是他依靠你不懈的努力，让自己的肉体成为这些能量的通道才能达成的。 真实的伟大，并不是因为你做一个令人敬仰的人，而是你此时此刻选择去做令人敬仰的事情。 不管你在人生中的任何位置，你取得了任何成就，都应该把自己看做一个动脉而不是心脏。国王是一个传送王权的渠道，而不是王权本身。做一个国王，并不是为了当国王所带来的利益，而是为了你的土地，臣民的繁荣。 读后感我读这本书的时候在很多原型上都能看到自己的影子。其实并不是当你从一个阶段过渡到另一个阶段，上一个阶段的影响就没有了。 我更觉得每一个原型它一直存在你的身体内部，只是当你逐渐成熟时，成熟的人格会把那些原型的平衡点更好的展现出来。 从男孩到男人，每个男孩都是在逐步成为掌控自己的国王。 我们曾经听过很多名言，比如林肯曾说: 父母给了一个男人前半生的长相，而后半生的长相是自己给 的。其实，林肯说得并不是长相本身。在中国的传统文化中，我们相信“面由心生”，林肯的这番话实际上指向的是男人的内在修养，即你后半生的内 在修养完全靠你自己创造。长相是一个人的内在气质的一个外在表现形式. 这和我以前小学听到的：腹有诗书气自华。 后来网上看到的，你现在的气质里藏着你读过的书，跑过的步，爱过的人。 这都是由内而外的表现。 这本书值得多次反复去阅读，因为每一个阶段都能看到自己过去做过的事情在阴影部分是否对应。 吾日三省吾身。 大概这就是阅读所带来的收益，成为更好的自己。","tags":[{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/tags/阅读/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://wiki.haoqiao.me/tags/读书笔记/"},{"name":"读后感","slug":"读后感","permalink":"http://wiki.haoqiao.me/tags/读后感/"},{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"}],"categories":[{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/categories/阅读/"}]},{"title":"javascript框架设计第一版","date":"2017-09-20T11:18:20.000Z","path":"wiki/阅读/javascript框架设计第一版/","text":"","tags":[{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/tags/阅读/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://wiki.haoqiao.me/tags/读书笔记/"},{"name":"读后感","slug":"读后感","permalink":"http://wiki.haoqiao.me/tags/读后感/"},{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"}],"categories":[{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/categories/阅读/"}]},{"title":"聊聊架构","date":"2017-09-18T02:36:00.000Z","path":"wiki/阅读/聊聊架构/","text":"生命周期 生命周期的主体，比如用户的一次购买活动 生命周期可拆分，确定核心生命周期。 空间上连续的限制可以通过拆分生命周期突破，形成空间上并行和时间上串行执行的状况。 非核心生命周期一旦拆分出来，往往形成一个通用的服务。不再局限于原有的大的生命周期。 大生命周期也因此变得更加精简，可以专注自己的核心生命周期活动，节省更多时间。 什么是架构什么是架构 必须由人执行的工作 每个人的时间有限 对目标系统有更高的要求 目标系统的复杂性使得单个人完成系统时会受限于时间 架构的思考来源于对生命周期的识别，以及拆分。 架构是什么 对目标系统的边界进行界定。问题的主题确定一般就能确定边界，问题的确定可以明确核心生命周期 围绕目标系统核心生命周期进行切分。首先进行空间上的拆分，只有空间上并行才能减少每个人的执行时间。最终使得空间上管理可以并行，时间执行上串行。 对切分出来的部分，各种确定生命周期和主体，以及负责的角色。切出来的生命周期活动的结果都累计在改生命周期的主题上，这就是内聚。 在非核心生命周期和核心生命周期之间建立沟通机制，使非核心围绕核心建立树状结构. 架构的生命周期 架构设计生命周期（非核心） 主要工作是研究业务本身的生命周期,根据业务面对的问题，发现瓶颈，进行架构的拆分。进架构的拆分。拆分的原则是把非核心生命周期拆分出来，由不同角色负责，让人们可以并行工作。每个角色达到权责的对等,并形成不同的角色各种的激励机制。目的是让业务成长更加强大，服务于更多人 架构实施生命周期（核心） 为了把架构的拆分落实到组织架构上，让每个人能够按照架构的职责拆分，并行工作。执行各自的生命周期。这些角色按照树状架构协调互相之间的协调，使得每个拆分出非核心生命周期的增长，都贡献给核心生命周期。同时自己也受益。 识别问题切分原则 架构的切分导火索是人的负载太重，也就是时间不够。 架构的切分实际是对利益相关人的利益进行切分或合并，使得每个利益相关人的权责对等。每个利益相关人可以对自己的利益负责。 架构切分的最终结果体现在组织架构上，这样能让架构落地并推进。 架构切分一定是树状，分层越少，尽可能平衡，让整个系统效率最大化。 什么是软件架构软件开发周期，软件工程师需要完成以下： 学习业务知识，认识业务的生命周期，以及生命周期中所涉及的利益相关人的核心利益诉求。业务是如何拆分生命周期，拆分出来的核心生命周期。","tags":[{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/tags/阅读/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://wiki.haoqiao.me/tags/读书笔记/"},{"name":"读后感","slug":"读后感","permalink":"http://wiki.haoqiao.me/tags/读后感/"},{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"}],"categories":[{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/categories/阅读/"}]},{"title":"深入React技术栈","date":"2017-09-17T05:36:18.000Z","path":"wiki/阅读/深入React技术栈/","text":"事件系统React基于Virtual DOM实现了一个SyntheticEvent(事件层) 我们所定义的事件处理器会接收到一个SyntheticEvent对象的实例。 事件处理程序通过 合成事件（SyntheticEvent）的实例传递，SyntheticEvent 是浏览器原生事件跨浏览器的封装。SyntheticEvent 和浏览器原生事件一样有 stopPropagation()、preventDefault() 接口，而且这些接口所有浏览器兼容。 所有事件绑定到最外层。 访问原生事件对象通过 nativeEvent 必须用驼峰形式写事件的属性名 比如 onClick={...} 合成事件的实现机制事件委派 事件代理机制: 并不会直接绑定到真实节点。所有事件绑定到结构最外层。 使用统一的事件监听器。 事件监听器维护了一个映射来保存所有的组件内部的事件监听和处理函数。 组件挂载或卸载时，只是在事件监听器上插入和删除一些对象。 当事件发生时，统一的事件监听器去处理。在映射中找到对应处理。简化了事件处理和回收机制，效率提升。 自动绑定 在React组件，每个方法的上下文自动绑定该组件实例。自动绑定this到当前组件。 当使用ES6 classes或者纯函数。这种自动绑定消失，我们需要自己去绑定。 bind方法 可以传递参数 1onClick=&#123;this.handleClick.bind(this,&apos;arg&apos;)&#125; 双冒号语法 不传递参数 1onClick=&#123;::this.handleClick&#125; 构造器内声明 1234567handleClick(e)&#123; this.handleClick=this.handleClick.bind(this)&#125;onClick=&#123;this.handleClick&#125; 箭头函数 123456const handleClick = (e) &#123; ...&#125;onClick=&#123;this.handleClick&#125; CSS Modules用 compose 来组合样式 1234567891011121314.base&#123;&#125;.normal &#123; compose:base;&#125;import styles from &apos;./Button.css&apos;&lt;button class=&#123;styles.normal&#125;&gt; click &lt;/button&gt;=&gt;&lt;button class=&quot;button--base--abc123 button--normal--sss&quot;&gt; click &lt;/button&gt; 解读React源码React应用架构React MiddleWareRedux 借鉴了Koa的MiddleWare思想。 Redux 中的组件 展示型组件 容器型组件 目的 长什么样子(标签，样式) 干什么用(获取数据，更新状态) 是否感知redux 否 是 获取数据 从this.props 从redux状态树中获取 要改变数据 调用从props中传入的action creator 直接分发action 实际创建于 开发者自身 由React Redux创建","tags":[{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/tags/阅读/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://wiki.haoqiao.me/tags/读书笔记/"},{"name":"读后感","slug":"读后感","permalink":"http://wiki.haoqiao.me/tags/读后感/"},{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"}],"categories":[{"name":"阅读","slug":"阅读","permalink":"http://wiki.haoqiao.me/categories/阅读/"}]},{"title":"开发配置","date":"2017-09-16T03:23:22.000Z","path":"wiki/前端/开发标准/开发配置/","text":"Mongodb配置1234567891011121314151617181920211. 切换数据库到 use admin2. 指定了数据库 testDb ,拥有权限: userAdmin db.createUser( &#123; user: &quot;test&quot;, pwd: &quot;test666&quot;, roles: [ &#123; role: &quot;userAdmin&quot;, db: &quot;testDb&quot; &#125; ] &#125; ) 3. 验证下上面创建的账号 cvte db.auth(&apos;test&apos;,&apos;test666&apos;) =&gt; 1 4.用 mongoose 指定用户连接数据库 var mongoose = require(&apos;mongoose&apos;);module.exports = function (done) &#123; mongoose.connect(&quot;mongodb://test:test666@127.0.0.1:27017/admin&quot;, &#123;auto_reconnect: true&#125;, done);&#125;;","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"开发配置","slug":"开发配置","permalink":"http://wiki.haoqiao.me/tags/开发配置/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"开发标准","slug":"前端/开发标准","permalink":"http://wiki.haoqiao.me/categories/前端/开发标准/"}]},{"title":"typescript 基础开发","date":"2017-09-05T09:49:39.000Z","path":"wiki/前端/开发标准/TypeScript开发/","text":"资料官方英文文档 官方中文文档 非官方文档 写d.ts参考 typescript-handbook 原始类型 1234567891011121314151617181920212223242526272829// 原始值const isDone: boolean = false;const amount: number = 6;const address: string = &apos;beijing&apos;;const greeting: string = `Hello World`;// 数组const list: number[] = [1, 2, 3];const list: Array&lt;number&gt; = [1, 2, 3];// 元组const name: [string, string] = [&apos;Sean&apos;, &apos;Sun&apos;];// 枚举enum Color &#123; Red, Green, Blue&#125;;const c: Color = Color.Green;// 任意值：可以调用任意方法let anyTypes: any = 4;anyTypes = &apos;any&apos;;anyTypes = false// 空值function doSomething (): void &#123; return undefined;&#125;// 类型断言let someValue: any = &quot;this is a string&quot;;let strLength: number = (someValue as string).length; 联合类型1234let myFavoriteNumber: string | number;myFavoriteNumber = &apos;seven&apos;;myFavoriteNumber = 7; 接口 接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152interface Person &#123; name: string; age: number;&#125;let xcatliu: Person = &#123; name: &apos;Xcat Liu&apos;, age: 25,&#125;;// 可选属性,可选属性的含义是该属性可以不存在。interface Person &#123; name: string; age?: number;&#125;let xcatliu: Person = &#123; name: &apos;Xcat Liu&apos;,&#125;;// 任意属性 确定属性和可选属性都必须是它的子属性：interface Person &#123; name: string; age?: number; [propName: string]: any;&#125;let xcatliu: Person = &#123; name: &apos;Xcat Liu&apos;, website: &apos;http://xcatliu.com&apos;,&#125;;// 只读属性 readonly 定义只读属性interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let xcatliu: Person = &#123; id: 89757, name: &apos;Xcat Liu&apos;, website: &apos;http://xcatliu.com&apos;,&#125;;xcatliu.id = 9527; // error 数组的类型12345678910let fibonacci: number[] = [1, 1, 2, 3, 5];interface NumberArray &#123; [index: number]: number;&#125;let fibonacci: NumberArray = [1, 1, 2, 3, 5];let list: any[] = [&apos;Xcat Liu&apos;, 25, &#123; website: &apos;http://xcatliu.com&apos; &#125;]; 函数123456789101112131415161718192021222324252627282930313233343536373839function sum(x: number, y: number): number &#123; return x + y;&#125;sum(1, 2, 3); //输入多余的（或者少于要求的）参数，是不被允许的：let mySum = function (x: number, y: number): number &#123; return x + y;&#125;;//接口中函数的定义interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125;// 可选参数function buildName(firstName: string, lastName?: string) &#123; // 可选参数后面不允许再出现必须参数 if (lastName) &#123; return firstName + &apos; &apos; + lastName; &#125; else &#123; return firstName; &#125;&#125;let xcatliu = buildName(&apos;Xcat&apos;, &apos;Liu&apos;);let xcat = buildName(&apos;Xcat&apos;);// 参数默认值function buildName(firstName: string, lastName: string = &apos;Liu&apos;) &#123; return firstName + &apos; &apos; + lastName;&#125; 类型断言&lt;类型&gt;值 // 或 值 as 类型 12345678function getLength(something: string | number): number &#123; if ((&lt;string&gt;something).length) &#123; return (&lt;string&gt;something).length; &#125; else &#123; return something.toString().length; &#125;&#125; 声明文件通常我们会把类型声明放到一个单独的文件中，这就是声明文件： // jQuery.d.ts declare var jQuery: (string) =&gt; any;我们约定声明文件以 .d.ts 为后缀。 然后在使用到的文件的开头，用「三斜线指令」表示引用了声明文件： /// jQuery(‘#foo’); 类型别名 类型别名用来给一个类型起个新名字。 123456789101112type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === &apos;string&apos;) &#123; return n; &#125; else &#123; return n(); &#125;&#125; 字符串字面量类型 字符串字面量类型用来约束取值只能是某几个字符串中的一个。 12345678type EventNames = &apos;click&apos; | &apos;scroll&apos; | &apos;mousemove&apos;;function handleEvent(ele: Element, event: EventNames) &#123; // do something&#125;handleEvent(document.getElementById(&apos;hello&apos;), &apos;scroll&apos;); // 没问题handleEvent(document.getElementById(&apos;world&apos;), &apos;dbclick&apos;); // 报错，event 不能为 &apos;dbclick&apos; 元组 数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。 12345678910111213141516let xcatliu: [string, number] = [&apos;Xcat Liu&apos;, 25];let xcatliu: [string, number];xcatliu[0] = &apos;Xcat Liu&apos;;xcatliu[1] = 25;xcatliu[0].slice(1);xcatliu[1].toFixed(2);// Declare a tuple typelet x: [string, number];// Initialize itx = [&apos;hello&apos;, 10]; // OK// Initialize it incorrectlyx = [10, &apos;hello&apos;]; // Error 类 类(Class)：定义了一件事物的抽象特点，包含它的属性和方法对象（Object）：类的实例，通过 new 生成面向对象（OOP）的三大特性：封装、继承、多态 封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat存取器（getter &amp; setter）：用以改变属性的读取和赋值行为 修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口 12345678910111213141516使用 class 定义类，使用 constructor 定义构造函数。通过 new 生成新实例的时候，会自动调用构造函数。class Animal &#123; constructor(name) &#123; this.name = name; &#125; sayHi() &#123; return `My name is $&#123;this.name&#125;`; &#125;&#125;let a = new Animal(&apos;Jack&apos;);console.log(a.sayHi()); // My name is Jack 1234567891011121314151617类的继承使用 extends 关键字实现继承，子类中使用 super 关键字来调用父类的构造函数和方法。class Cat extends Animal &#123; constructor(name) &#123; super(name); // 调用父类的 constructor(name) console.log(this.name); &#125; sayHi() &#123; return &apos;Meow, &apos; + super.sayHi(); // 调用父类的 sayHi() &#125;&#125;let c = new Cat(&apos;Tom&apos;); // Tomconsole.log(c.sayHi()); // Meow, My name is Tom 1234567891011121314151617181920212223242526272829303132333435存取器使用 getter 和 setter 可以改变属性的赋值和读取行为：class Animal &#123; constructor(name) &#123; this.name = name; &#125; get name() &#123; return &apos;Jack&apos;; &#125; set name(value) &#123; console.log(&apos;setter: &apos; + value); &#125;&#125;let a = new Animal(&apos;Kitty&apos;); // setter: Kittya.name = &apos;Tom&apos;; // setter: Tomconsole.log(a.name); // Jack静态方法使用 static 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用：class Animal &#123; static isAnimal(a) &#123; return a instanceof Animal; &#125;&#125;let a = new Animal(&apos;Jack&apos;);Animal.isAnimal(a); // truea.isAnimal(a); // TypeError: a.isAnimal is not a function TypeScript 中类的用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的private 修饰的属性或方法是私有的，不能在声明它的类的外部访问protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的下面举一些例子：class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125;&#125;let a = new Animal(&apos;Jack&apos;);console.log(a.name); // Jacka.name = &apos;Tom&apos;;console.log(a.name); // Tom上面的例子中，name 被设置为了 public，所以直接访问实例的 name 属性是允许的。很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 private 了：class Animal &#123; private name; public constructor(name) &#123; this.name = name; &#125;&#125;let a = new Animal(&apos;Jack&apos;);console.log(a.name); // Jacka.name = &apos;Tom&apos;;// index.ts(9,13): error TS2341: Property &apos;name&apos; is private and only accessible within class &apos;Animal&apos;.// index.ts(10,1): error TS2341: Property &apos;name&apos; is private and only accessible within class &apos;Animal&apos;.需要注意的是，TypeScript 编译之后的代码中，并没有限制 private 属性在外部的可访问性。上面的例子编译后的代码是：var Animal = (function () &#123; function Animal(name) &#123; this.name = name; &#125; return Animal;&#125;());var a = new Animal(&apos;Jack&apos;);console.log(a.name);a.name = &apos;Tom&apos;;使用 private 修饰的属性或方法，在子类中也是不允许访问的：class Animal &#123; private name; public constructor(name) &#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; constructor(name) &#123; super(name); console.log(this.name); &#125;&#125;// index.ts(11,17): error TS2341: Property &apos;name&apos; is private and only accessible within class &apos;Animal&apos;.而如果是用 protected 修饰，则允许在子类中访问：class Animal &#123; protected name; public constructor(name) &#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; constructor(name) &#123; super(name); console.log(this.name); &#125;&#125; 抽象类 12345678910111213141516abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;class Cat extends Animal &#123; public sayHi() &#123; console.log(`Meow, My name is $&#123;this.name&#125;`); &#125;&#125;let cat = new Cat(&apos;Tom&apos;); 一个类可以实现多个接口： 一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。 123456789101112131415161718192021interface Alarm &#123; alert();&#125;interface Light &#123; lightOn(); lightOff();&#125;class Car implements Alarm, Light &#123; alert() &#123; console.log(&apos;Car alert&apos;); &#125; lightOn() &#123; console.log(&apos;Car light on&apos;); &#125; lightOff() &#123; console.log(&apos;Car light off&apos;); &#125;&#125; 泛型 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 123456789101112131415实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray&lt;string&gt;(3, &apos;x&apos;); // [&apos;x&apos;, &apos;x&apos;, &apos;x&apos;]在函数名后添加了 &lt;T&gt;，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array&lt;T&gt; 中即可使用了 多个类型参数 123456789定义泛型的时候，可以一次定义多个类型参数：function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123; return [tuple[1], tuple[0]];&#125;swap([7, &apos;seven&apos;]); // [&apos;seven&apos;, 7]上例中，我们定义了一个 swap 函数，用来交换输入的元组。 泛型约束 12345678910111213141516171819202122232425我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是泛型约束：interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125;多个类型参数之间也可以互相约束：function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123; for (let id in source) &#123; target[id] = (&lt;T&gt;source)[id]; &#125; return target;&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;copyFields(x, &#123; b: 10, d: 20 &#125;);上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。 泛型接口 123456789101112131415interface CreateArrayFunc &#123; &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, &apos;x&apos;); // [&apos;x&apos;, &apos;x&apos;, &apos;x&apos;] 泛型类 123456789class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;; 提升学习接口学习常用的接口定义一般是这么写的: 12345678910111213interface Project&#123; _id : String, projectName?: String, projectUrl?: String, projectDesc?: String, version?: String, transferUrl?: String, status?: String, type?: String, teamMember?: Array&lt;any&gt;, interfaceList?: Array&lt;any&gt;,&#125; 这在约定好接口字段的时候很管用，但是有时候字段没约定好，比如有时候可能会传入多余的数据，这个时候编译前会自动报错提醒。 此时可以考虑这么写 12345678interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125;SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。 泛型学习经过学习，除去经常用的接口定义 Interface, 以及常用的基本类型定义。想要更优写法肯定需要应用上泛型。 泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 泛型就是指定一个表示类型的变量，用它来代替某个实际的类型用于编程，而后通过实际调用时传入或推导的类型来对其进行替换，以达到一段使用泛型程序可以实际适应不同类型的目的。 HandBook 上有几个例子，比如当需要一种方法使返回值的类型与传入参数的类型是相同的情况下。 123456function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。 还有就是泛型类的应用。 泛型类其实多数时候是应用于容器类。假设我们需要实现一个 FilteredList，我们可以向其中 add()(添加) 任意数据，但是它在添加的时候会自动过滤掉不符合条件的一些，最终通过 get all() 输出所有符合条件的数据(数组)。而过滤条件在构造对象的时候，以函数或 Lambda 表达式提供。 123456789101112131415161718192021222324252627// 声明泛型类，类型变量为 Tclass FilteredList&lt;T&gt; &#123; // 声明过滤器是以 T 为参数类型，返回 boolean 的函数表达式 filter: (v: T) =&gt; boolean; // 声明数据是 T 数组类型 data: T[]; constructor(filter: (v: T) =&gt; boolean) &#123; this.filter = filter; &#125; add(value: T) &#123; if (this.filter(value)) &#123; this.data.push(value); &#125; &#125; get all(): T[] &#123; return this.data; &#125;&#125;// 处理 string 类型的 FilteredListconst validStrings = new FilteredList&lt;string&gt;(s =&gt; !s);// 处理 number 类型的 FilteredListconst positiveNumber = new FilteredList&lt;number&gt;(n =&gt; n &gt; 0); 这个可以应用于维护本地数据的地方，以及ajax提交数据的一些地方。主要是用于筛选数据。我们完全可以基于这个思想做一些多条件的过滤。在很多对数据需要处理的地方这个还是很有用的。 命名空间与模块 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”。 常用的 helper函数，封装的 until 系列都是习惯用 export 导出模块然后引用的。但是一些验证函数如果也这么使用就不稳妥了。 随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们类型的同时还不用担心与其它对象产生命名冲突。 因此，我们把验证器包裹到一个命名空间内，而不是把它们放在模块下。 我们来看一个例子。在之前我们是这么写的: 1234567891011121314151617181920212223242526272829303132333435 interface StringValidator &#123; isAcceptable(s: string): boolean;&#125;let lettersRegexp = /^[A-Za-z]+$/;let numberRegexp = /^[0-9]+$/;class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return lettersRegexp.test(s); &#125;&#125;class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;// Some samples to trylet strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];// Validators to uselet validators: &#123; [s: string]: StringValidator; &#125; = &#123;&#125;;validators[&quot;ZIP code&quot;] = new ZipCodeValidator();validators[&quot;Letters only&quot;] = new LettersOnlyValidator();// Show whether each string passed each validatorfor (let s of strings) &#123; for (let name in validators) &#123; let isMatch = validators[name].isAcceptable(s); console.log(`&apos;$&#123; s &#125;&apos; $&#123; isMatch ? &quot;matches&quot; : &quot;does not match&quot; &#125; &apos;$&#123; name &#125;&apos;.`); &#125;&#125; 然后改成命名空间的写法： 123456789101112131415161718192021222324252627282930313233343536namespace Validation &#123; export interface StringValidator &#123; isAcceptable(s: string): boolean; &#125; const lettersRegexp = /^[A-Za-z]+$/; const numberRegexp = /^[0-9]+$/; export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return lettersRegexp.test(s); &#125; &#125; export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125; &#125;&#125;// Some samples to trylet strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];// Validators to uselet validators: &#123; [s: string]: Validation.StringValidator; &#125; = &#123;&#125;;validators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator();validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();// Show whether each string passed each validatorfor (let s of strings) &#123; for (let name in validators) &#123; console.log(`&quot;$&#123; s &#125;&quot; - $&#123; validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; &#125; $&#123; name &#125;`); &#125;&#125; 很明显这个组织格式差别不大，但是在一个命名空间内可以避免一些不必要的冲突。 然后我们可以将一些不同逻辑的代码进行物理分割，但是在逻辑上，在同一个命名空间内，即使它们分离两地但是还是心连心。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Validation.tsnamespace Validation &#123; export interface StringValidator &#123; isAcceptable(s: string): boolean; &#125;&#125;LettersOnlyValidator.ts/// &lt;reference path=&quot;Validation.ts&quot; /&gt;namespace Validation &#123; const lettersRegexp = /^[A-Za-z]+$/; export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return lettersRegexp.test(s); &#125; &#125;&#125;ZipCodeValidator.ts/// &lt;reference path=&quot;Validation.ts&quot; /&gt;namespace Validation &#123; const numberRegexp = /^[0-9]+$/; export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125; &#125;&#125;Test.ts/// &lt;reference path=&quot;Validation.ts&quot; /&gt;/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;// Some samples to trylet strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];// Validators to uselet validators: &#123; [s: string]: Validation.StringValidator; &#125; = &#123;&#125;;validators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator();validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();// Show whether each string passed each validatorfor (let s of strings) &#123; for (let name in validators) &#123; console.log(`&quot;$&#123; s &#125;&quot; - $&#123; validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; &#125; $&#123; name &#125;`); &#125;&#125; 模块的基本都了解，在 Typescirpt 中，我们可以用更好的方式组织模块。 比如我们常常引用自己的模块是通过相对导入。 比如 import { DefaultHeaders } from &quot;../constants/http&quot;; 我们引用的一些外部模块是非相对的. 比如 import * as $ from &quot;jQuery&quot;; 对于一些比较成熟的依赖库我们可以通过将其作为外部模块载入。 可以使用顶级的 export 声明来为每个模块都定义一个 .d.ts 文件，但最好还是写在一个大的 .d.ts 文件里。 我们使用与构造一个外部命名空间相似的方法，但是这里使用 module 关键字并且把名字用引号括起来，方便之后 import. 1234567891011121314151617node.d.ts (simplified excerpt)declare module &quot;url&quot; &#123; export interface Url &#123; protocol?: string; hostname?: string; pathname?: string; &#125; export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;&#125;declare module &quot;path&quot; &#123; export function normalize(p: string): string; export function join(...paths: any[]): string; export let sep: string;&#125; 我们可以 /// &lt;reference&gt; node.d.ts 并且使用 import url = require(&quot;url&quot;); 或 import * as URL from &quot;url&quot; 加载模块 1234/// &lt;reference path=&quot;node.d.ts&quot;/&gt;import * as URL from &quot;url&quot;;let myUrl = URL.parse(&quot;http://www.typescriptlang.org&quot;); 书写声明文件针对模块有三种可用的模块， module.d.ts, module-class.d.ts 和 module-function.d.ts. 如果模块不能被调用或构造，使用module.d.ts文件。 module.d.ts里一般这么写: 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module template file. You should rename it to index.d.ts *~ and place it in a folder with the same name as the module. *~ For example, if you were writing a file for &quot;super-greeter&quot;, this *~ file should be &apos;super-greeter/index.d.ts&apos; *//*~ If this module is a UMD module that exposes a global variable &apos;myLib&apos; when *~ loaded outside a module loader environment, declare that global here. *~ Otherwise, delete this declaration. */export as namespace myLib;/*~ If this module has methods, declare them as functions like so. */export function myMethod(a: string): string;export function myOtherMethod(a: number): number;/*~ You can declare types that are available via importing the module */export interface someType &#123; name: string; length: number; extras?: string[];&#125;/*~ You can declare properties of the module using const, let, or var */export const myField: number;/*~ If there are types, properties, or methods inside dotted names *~ of the module, declare them inside a &apos;namespace&apos;. */export namespace subProp &#123; /*~ For example, given this definition, someone could write: *~ import &#123; subProp &#125; from &apos;yourModule&apos;; *~ subProp.foo(); *~ or *~ import * as yourMod from &apos;yourModule&apos;; *~ yourMod.subProp.foo(); */ export function foo(): void;&#125; 12345使用 module-class.d.ts 如果模块能够使用new来构造：var x = require(&quot;bar&quot;);// Note: using &apos;new&apos; operator on the imported variablevar y = new x(&quot;hello&quot;); module-class.d.ts 的模板写法如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module template file for function modules. *~ You should rename it to index.d.ts and place it in a folder with the same name as the module. *~ For example, if you were writing a file for &quot;super-greeter&quot;, this *~ file should be &apos;super-greeter/index.d.ts&apos; *//*~ Note that ES6 modules cannot directly export callable functions. *~ This file should be imported using the CommonJS-style: *~ import x = require(&apos;someLibrary&apos;); *~ *~ Refer to the documentation to understand common *~ workarounds for this limitation of ES6 modules. *//*~ If this module is a UMD module that exposes a global variable &apos;myFuncLib&apos; when *~ loaded outside a module loader environment, declare that global here. *~ Otherwise, delete this declaration. */export as namespace myFuncLib;/*~ This declaration specifies that the function *~ is the exported object from the file */export = MyFunction;/*~ This example shows how to have multiple overloads for your function */declare function MyFunction(name: string): MyFunction.NamedReturnType;declare function MyFunction(length: number): MyFunction.LengthReturnType;/*~ If you want to expose types from your module as well, you can *~ place them in this block. Often you will want to describe the *~ shape of the return type of the function; that type should *~ be declared in here, as this example shows. */declare namespace MyFunction &#123; export interface LengthReturnType &#123; width: number; height: number; &#125; export interface NamedReturnType &#123; firstName: string; lastName: string; &#125; /*~ If the module also has properties, declare them here. For example, *~ this declaration says that this code is legal: *~ import f = require(&apos;myFuncLibrary&apos;); *~ console.log(f.defaultName); */ export const defaultName: string; export let defaultLength: number;&#125; 12345使用 module-function.d.ts，如果模块能够作为函数调用。var x = require(&quot;foo&quot;);// Note: calling &apos;x&apos; as a functionvar y = x(42); module-function.d.ts 的模板写法如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module template file for class modules. *~ You should rename it to index.d.ts and place it in a folder with the same name as the module. *~ For example, if you were writing a file for &quot;super-greeter&quot;, this *~ file should be &apos;super-greeter/index.d.ts&apos; *//*~ Note that ES6 modules cannot directly export class objects. *~ This file should be imported using the CommonJS-style: *~ import x = require(&apos;someLibrary&apos;); *~ *~ Refer to the documentation to understand common *~ workarounds for this limitation of ES6 modules. *//*~ If this module is a UMD module that exposes a global variable &apos;myClassLib&apos; when *~ loaded outside a module loader environment, declare that global here. *~ Otherwise, delete this declaration. */export as namespace myClassLib;/*~ This declaration specifies that the class constructor function *~ is the exported object from the file */export = MyClass;/*~ Write your module&apos;s methods and properties in this class */declare class MyClass &#123; constructor(someParam?: string); someProperty: string[]; myMethod(opts: MyClass.MyClassMethodOptions): number;&#125;/*~ If you want to expose types from your module as well, you can *~ place them in this block. */declare namespace MyClass &#123; export interface MyClassMethodOptions &#123; width?: number; height?: number; &#125;&#125; 一些规范之前没有注意，在项目需要重新审视。 不要使用如下类型Number，String，Boolean或Object。 这些类型指的是非原始的装盒对象，它们几乎没在JavaScript代码里正确地使用过。 123456/* 错误 */function reverse(s: String): String;/* OK */function reverse(s: string): string; 一些例子: 全局变量 : declare var foo: number; 全局变量 : declare function greet(greeting: string): void; 带属性的对象 : 12345678910111213141516全局变量myLib包含一个makeGreeting函数， 还有一个属性numberOfGreetings指示目前为止欢迎数量。代码let result = myLib.makeGreeting(&quot;hello, world&quot;);console.log(&quot;The computed greeting is:&quot; + result);let count = myLib.numberOfGreetings;声明使用declare namespace描述用点表示法访问的类型或值。declare namespace myLib &#123; function makeGreeting(s: string): string; let numberOfGreetings: number;&#125; 函数重载 : 123456789101112getWidget函数接收一个数字，返回一个组件，或接收一个字符串并返回一个组件数组。代码let x: Widget = getWidget(43);let arr: Widget[] = getWidget(&quot;all of them&quot;);声明declare function getWidget(n: number): Widget;declare function getWidget(s: string): Widget[]; 组织类型 : 1234567891011121314151617181920212223242526272829303132greeter对象能够记录到文件或显示一个警告。 你可以为.log(...)提供LogOptions和为.alert(...)提供选项。代码const g = new Greeter(&quot;Hello&quot;);g.log(&#123; verbose: true &#125;);g.alert(&#123; modal: false, title: &quot;Current Greeting&quot; &#125;);声明使用命名空间组织类型。declare namespace GreetingLib &#123; interface LogOptions &#123; verbose?: boolean; &#125; interface AlertOptions &#123; modal: boolean; title?: string; color?: string; &#125;&#125;你也可以在一个声明中创建嵌套的命名空间：declare namespace GreetingLib.Options &#123; // Refer to via GreetingLib.Options.Log interface Log &#123; verbose?: boolean; &#125; interface Alert &#123; modal: boolean; title?: string; color?: string; &#125;&#125;","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"代码标准","slug":"代码标准","permalink":"http://wiki.haoqiao.me/tags/代码标准/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"开发标准","slug":"前端/开发标准","permalink":"http://wiki.haoqiao.me/categories/前端/开发标准/"}]},{"title":"Airbnb React 代码风格标准","date":"2017-09-04T03:23:22.000Z","path":"wiki/前端/开发标准/Airbnb React 标准/","text":"Airbnb React/JSX 编码规范算是最合理的React/JSX编码规范之一了 内容目录 基本规范 Class vs React.createClass vs stateless Mixins 命名 声明模块 代码对齐 单引号还是双引号 空格 属性 Refs引用 括号 标签 函数/方法 模块生命周期 isMounted Basic Rules 基本规范 每个文件只写一个模块. 但是多个无状态模块可以放在单个文件中. eslint: react/no-multi-comp. 推荐使用JSX语法. 不要使用 React.createElement，除非从一个非JSX的文件中初始化你的app. 创建模块 Class vs React.createClass vs stateless 如果你的模块有内部状态或者是refs, 推荐使用 class extends React.Component 而不是 React.createClass.eslint: react/prefer-es6-class react/prefer-stateless-function 123456789101112131415// badconst Listing = React.createClass(&#123; // ... render() &#123; return &lt;div&gt;&#123;this.state.hello&#125;&lt;/div&gt;; &#125;&#125;);// goodclass Listing extends React.Component &#123; // ... render() &#123; return &lt;div&gt;&#123;this.state.hello&#125;&lt;/div&gt;; &#125;&#125; 如果你的模块没有状态或是没有引用refs， 推荐使用普通函数（非箭头函数）而不是类: 12345678910111213141516// badclass Listing extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.hello&#125;&lt;/div&gt;; &#125;&#125;// bad (relying on function name inference is discouraged)const Listing = (&#123; hello &#125;) =&gt; ( &lt;div&gt;&#123;hello&#125;&lt;/div&gt;);// goodfunction Listing(&#123; hello &#125;) &#123; return &lt;div&gt;&#123;hello&#125;&lt;/div&gt;;&#125; Mixins 不要使用 mixins. 为什么? Mixins 会增加隐式的依赖，导致命名冲突，并且会以雪球式增加复杂度。在大多数情况下Mixins可以被更好的方法替代，如：组件化，高阶组件，工具模块等。 Naming 命名 扩展名: React模块使用 .jsx 扩展名. 文件名: 文件名使用帕斯卡命名. 如, ReservationCard.jsx. 引用命名: React模块名使用帕斯卡命名，实例使用骆驼式命名. eslint: react/jsx-pascal-case 1234567891011// badimport reservationCard from './ReservationCard';// goodimport ReservationCard from './ReservationCard';// badconst ReservationItem = &lt;ReservationCard /&gt;;// goodconst reservationItem = &lt;ReservationCard /&gt;; 模块命名: 模块使用当前文件名一样的名称. 比如 ReservationCard.jsx 应该包含名为 ReservationCard的模块. 但是，如果整个文件夹是一个模块，使用 index.js作为入口文件，然后直接使用 index.js 或者文件夹名作为模块的名称: 12345678// badimport Footer from './Footer/Footer';// badimport Footer from './Footer/index';// goodimport Footer from './Footer'; 高阶模块命名: 对于生成一个新的模块，其中的模块名 displayName 应该为高阶模块名和传入模块名的组合. 例如, 高阶模块 withFoo(), 当传入一个 Bar 模块的时候， 生成的模块名 displayName 应该为 withFoo(Bar). 为什么？一个模块的 displayName 可能会在开发者工具或者错误信息中使用到，因此有一个能清楚的表达这层关系的值能帮助我们更好的理解模块发生了什么，更好的Debug. 1234567891011121314151617181920// badexport default function withFoo(WrappedComponent) &#123; return function WithFoo(props) &#123; return &lt;WrappedComponent &#123;...props&#125; foo /&gt;; &#125;&#125;// goodexport default function withFoo(WrappedComponent) &#123; function WithFoo(props) &#123; return &lt;WrappedComponent &#123;...props&#125; foo /&gt;; &#125; const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component'; WithFoo.displayName = `withFoo($&#123;wrappedComponentName&#125;)`; return WithFoo;&#125; 属性命名: 避免使用DOM相关的属性来用作其他的用途。 为什么？对于style 和 className这样的属性名，我们都会默认它们代表一些特殊的含义，如元素的样式，CSS class的名称。在你的应用中使用这些属性来表示其他的含义会使你的代码更难阅读，更难维护，并且可能会引起bug。 12345// bad&lt;MyComponent style=\"fancy\" /&gt;// good&lt;MyComponent variant=\"fancy\" /&gt; Declaration 声明模块 不要使用 displayName 来命名React模块，而是使用引用来命名模块， 如 class 名称. 123456789// badexport default React.createClass(&#123; displayName: 'ReservationCard', // stuff goes here&#125;);// goodexport default class ReservationCard extends React.Component &#123;&#125; Alignment 代码对齐 遵循以下的JSX语法缩进/格式. eslint: react/jsx-closing-bracket-location 1234567891011121314151617181920// bad&lt;Foo superLongParam=\"bar\" anotherSuperLongParam=\"baz\" /&gt;// good, 有多行属性的话, 新建一行关闭标签&lt;Foo superLongParam=\"bar\" anotherSuperLongParam=\"baz\"/&gt;// 若能在一行中显示, 直接写成一行&lt;Foo bar=\"bar\" /&gt;// 子元素按照常规方式缩进&lt;Foo superLongParam=\"bar\" anotherSuperLongParam=\"baz\"&gt; &lt;Quux /&gt;&lt;/Foo&gt; Quotes 单引号还是双引号 对于JSX属性值总是使用双引号(&quot;), 其他均使用单引号(&#39;). eslint: jsx-quotes 为什么? HTML属性也是用双引号, 因此JSX的属性也遵循此约定. 1234567891011// bad&lt;Foo bar='bar' /&gt;// good&lt;Foo bar=\"bar\" /&gt;// bad&lt;Foo style=&#123;&#123; left: \"20px\" &#125;&#125; /&gt;// good&lt;Foo style=&#123;&#123; left: '20px' &#125;&#125; /&gt; Spacing 空格 总是在自动关闭的标签前加一个空格，正常情况下也不需要换行. eslint: no-multi-spaces, react/jsx-tag-spacing 123456789101112// bad&lt;Foo/&gt;// very bad&lt;Foo /&gt;// bad&lt;Foo /&gt;// good&lt;Foo /&gt; 不要在JSX {} 引用括号里两边加空格. eslint: react/jsx-curly-spacing 12345// bad&lt;Foo bar=&#123; baz &#125; /&gt;// good&lt;Foo bar=&#123;baz&#125; /&gt; Props 属性 JSX属性名使用骆驼式风格camelCase. 1234567891011// bad&lt;Foo UserName=\"hello\" phone_number=&#123;12345678&#125;/&gt;// good&lt;Foo userName=\"hello\" phoneNumber=&#123;12345678&#125;/&gt; 如果属性值为 true, 可以直接省略. eslint: react/jsx-boolean-value 123456789// bad&lt;Foo hidden=&#123;true&#125;/&gt;// good&lt;Foo hidden/&gt; &lt;img&gt; 标签总是添加 alt 属性. 如果图片以presentation(感觉是以类似PPT方式显示?)方式显示，alt 可为空, 或者&lt;img&gt; 要包含role=&quot;presentation&quot;. eslint: jsx-a11y/alt-text 1234567891011// bad&lt;img src=\"hello.jpg\" /&gt;// good&lt;img src=\"hello.jpg\" alt=\"Me waving hello\" /&gt;// good&lt;img src=\"hello.jpg\" alt=\"\" /&gt;// good&lt;img src=\"hello.jpg\" role=\"presentation\" /&gt; 不要在 alt 值里使用如 “image”, “photo”, or “picture”包括图片含义这样的词， 中文也一样. eslint: jsx-a11y/img-redundant-alt 为什么? 屏幕助读器已经把 img 标签标注为图片了, 所以没有必要再在 alt 里说明了. 12345// bad&lt;img src=\"hello.jpg\" alt=\"Picture of me waving hello\" /&gt;// good&lt;img src=\"hello.jpg\" alt=\"Me waving hello\" /&gt; 使用有效正确的 aria role属性值 ARIA roles. eslint: jsx-a11y/aria-role 12345678// bad - not an ARIA role&lt;div role=\"datepicker\" /&gt;// bad - abstract ARIA role&lt;div role=\"range\" /&gt;// good&lt;div role=\"button\" /&gt; 不要在标签上使用 accessKey 属性. eslint: jsx-a11y/no-access-key 为什么? 屏幕助读器在键盘快捷键与键盘命令时造成的不统一性会导致阅读性更加复杂. 12345// bad&lt;div accessKey=\"h\" /&gt;// good&lt;div /&gt; 避免使用数组的index来作为属性key的值，推荐使用唯一ID. (为什么?) 123456789101112131415// bad&#123;todos.map((todo, index) =&gt; &lt;Todo &#123;...todo&#125; key=&#123;index&#125; /&gt;)&#125;// good&#123;todos.map(todo =&gt; ( &lt;Todo &#123;...todo&#125; key=&#123;todo.id&#125; /&gt;))&#125; 对于所有非必须的属性，总是手动去定义defaultProps属性. 为什么? propTypes 可以作为模块的文档说明, 并且声明 defaultProps 的话意味着阅读代码的人不需要去假设一些默认值。更重要的是, 显示的声明默认属性可以让你的模块跳过属性类型的检查. 1234567891011121314151617181920212223// badfunction SFC(&#123; foo, bar, children &#125;) &#123; return &lt;div&gt;&#123;foo&#125;&#123;bar&#125;&#123;children&#125;&lt;/div&gt;;&#125;SFC.propTypes = &#123; foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node,&#125;;// goodfunction SFC(&#123; foo, bar, children &#125;) &#123; return &lt;div&gt;&#123;foo&#125;&#123;bar&#125;&#123;children&#125;&lt;/div&gt;;&#125;SFC.propTypes = &#123; foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node,&#125;;SFC.defaultProps = &#123; bar: '', children: null,&#125;; Refs 总是在Refs里使用回调函数. eslint: react/no-string-refs 123456789// bad&lt;Foo ref=\"myRef\"/&gt;// good&lt;Foo ref=&#123;(ref) =&gt; &#123; this.myRef = ref; &#125;&#125;/&gt; Parentheses 括号 将多行的JSX标签写在 ()里. eslint: react/jsx-wrap-multilines 123456789101112131415161718192021// badrender() &#123; return &lt;MyComponent className=\"long body\" foo=\"bar\"&gt; &lt;MyChild /&gt; &lt;/MyComponent&gt;;&#125;// goodrender() &#123; return ( &lt;MyComponent className=\"long body\" foo=\"bar\"&gt; &lt;MyChild /&gt; &lt;/MyComponent&gt; );&#125;// good, 单行可以不需要render() &#123; const body = &lt;div&gt;hello&lt;/div&gt;; return &lt;MyComponent&gt;&#123;body&#125;&lt;/MyComponent&gt;;&#125; Tags 标签 对于没有子元素的标签来说总是自己关闭标签. eslint: react/self-closing-comp 12345// bad&lt;Foo className=\"stuff\"&gt;&lt;/Foo&gt;// good&lt;Foo className=\"stuff\" /&gt; 如果模块有多行的属性， 关闭标签时新建一行. eslint: react/jsx-closing-bracket-location 12345678910// bad&lt;Foo bar=\"bar\" baz=\"baz\" /&gt;// good&lt;Foo bar=\"bar\" baz=\"baz\"/&gt; Methods 函数 使用箭头函数来获取本地变量. 123456789101112function ItemList(props) &#123; return ( &lt;ul&gt; &#123;props.items.map((item, index) =&gt; ( &lt;Item key=&#123;item.key&#125; onClick=&#123;() =&gt; doSomethingWith(item.name, index)&#125; /&gt; ))&#125; &lt;/ul&gt; );&#125; 当在 render() 里使用事件处理方法时，提前在构造函数里把 this 绑定上去. eslint: react/jsx-no-bind 为什么? 在每次 render 过程中， 再调用 bind 都会新建一个新的函数，浪费资源. 123456789101112131415161718192021222324252627// badclass extends React.Component &#123; onClickDiv() &#123; // do stuff &#125; render() &#123; return &lt;div onClick=&#123;this.onClickDiv.bind(this)&#125; /&gt;; &#125;&#125;// goodclass extends React.Component &#123; constructor(props) &#123; super(props); this.onClickDiv = this.onClickDiv.bind(this); &#125; onClickDiv() &#123; // do stuff &#125; render() &#123; return &lt;div onClick=&#123;this.onClickDiv&#125; /&gt;; &#125;&#125; 在React模块中，不要给所谓的私有函数添加 _ 前缀，本质上它并不是私有的. 为什么？_ 下划线前缀在某些语言中通常被用来表示私有变量或者函数。但是不像其他的一些语言，在JS中没有原生支持所谓的私有变量，所有的变量函数都是共有的。尽管你的意图是使它私有化，在之前加上下划线并不会使这些变量私有化，并且所有的属性（包括有下划线前缀及没有前缀的）都应该被视为是共有的。了解更多详情请查看Issue #1024, 和 #490 。 1234567891011121314151617// badReact.createClass(&#123; _onClickSubmit() &#123; // do stuff &#125;, // other stuff&#125;);// goodclass extends React.Component &#123; onClickSubmit() &#123; // do stuff &#125; // other stuff&#125; 在 render 方法中总是确保 return 返回值. eslint: react/require-render-return 123456789// badrender() &#123; (&lt;div /&gt;);&#125;// goodrender() &#123; return (&lt;div /&gt;);&#125; Ordering React 模块生命周期 class extends React.Component 的生命周期函数: 可选的 static 方法 constructor 构造函数 getChildContext 获取子元素内容 componentWillMount 模块渲染前 componentDidMount 模块渲染后 componentWillReceiveProps 模块将接受新的数据 shouldComponentUpdate 判断模块需不需要重新渲染 componentWillUpdate 上面的方法返回 true， 模块将重新渲染 componentDidUpdate 模块渲染结束 componentWillUnmount 模块将从DOM中清除, 做一些清理任务 点击回调或者事件处理器 如 onClickSubmit() 或 onChangeDescription() render 里的 getter 方法 如 getSelectReason() 或 getFooterContent() 可选的 render 方法 如 renderNavigation() 或 renderProfilePicture() render render() 方法 如何定义 propTypes, defaultProps, contextTypes, 等等其他属性… 1234567891011121314151617181920212223242526import React, &#123; PropTypes &#125; from 'react';const propTypes = &#123; id: PropTypes.number.isRequired, url: PropTypes.string.isRequired, text: PropTypes.string,&#125;;const defaultProps = &#123; text: 'Hello World',&#125;;class Link extends React.Component &#123; static methodsAreOk() &#123; return true; &#125; render() &#123; return &lt;a href=&#123;this.props.url&#125; data-id=&#123;this.props.id&#125;&gt;&#123;this.props.text&#125;&lt;/a&gt;; &#125;&#125;Link.propTypes = propTypes;Link.defaultProps = defaultProps;export default Link; React.createClass 的生命周期函数，与使用class稍有不同: eslint: react/sort-comp displayName 设定模块名称 propTypes 设置属性的类型 contextTypes 设置上下文类型 childContextTypes 设置子元素上下文类型 mixins 添加一些mixins statics defaultProps 设置默认的属性值 getDefaultProps 获取默认属性值 getInitialState 或者初始状态 getChildContext componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentWillUnmount clickHandlers or eventHandlers like onClickSubmit() or onChangeDescription() getter methods for render like getSelectReason() or getFooterContent() Optional render methods like renderNavigation() or renderProfilePicture() render isMounted 不要再使用 isMounted. eslint: react/no-is-mounted 为什么? isMounted 反人类设计模式:(), 在 ES6 classes 中无法使用， 官方将在未来的版本里删除此方法. ⬆ 回到顶部","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"代码风格标准","slug":"代码风格标准","permalink":"http://wiki.haoqiao.me/tags/代码风格标准/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"开发标准","slug":"前端/开发标准","permalink":"http://wiki.haoqiao.me/categories/前端/开发标准/"}]},{"title":"Airbnb ES6 代码风格标准","date":"2017-09-04T03:23:22.000Z","path":"wiki/前端/开发标准/Airbnb Es6 标准/","text":"目录 类型 引用 对象 数组 解构 字符串 函数 箭头函数 构造函数 模块 迭代器和生成器 属性 变量 提升 比较运算符和等号 代码块 注释 空白 逗号 分号 类型转换 命名规则 存取器 事件 jQuery ECMAScript 5 兼容性 ECMAScript 6 编码规范 测试 性能 相关资源 使用情况 其他翻译 JavaScript 编码规范说明 讨论 JavaScript 贡献者 许可协议 类型 1.1 基本类型: 直接存取基本类型。 字符串 数值 布尔类型 null undefined 123456const foo = 1;let bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 1.2 复杂类型: 通过引用的方式存取复杂类型。 对象 数组 函数 123456const foo = [1, 2];const bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 ⬆ 返回目录 引用 2.1 对所有的引用使用 const ；不要使用 var。 为什么？这能确保你无法对引用重新赋值，也不会导致出现 bug 或难以理解。 1234567// badvar a = 1;var b = 2;// goodconst a = 1;const b = 2; 2.2 如果你一定需要可变动的引用，使用 let 代替 var。 为什么？因为 let 是块级作用域，而 var 是函数作用域。 1234567891011// badvar count = 1;if (true) &#123; count += 1;&#125;// good, use the let.let count = 1;if (true) &#123; count += 1;&#125; 2.3 注意 let 和 const 都是块级作用域。 1234567// const 和 let 只存在于它们被定义的区块内。&#123; let a = 1; const b = 1;&#125;console.log(a); // ReferenceErrorconsole.log(b); // ReferenceError ⬆ 返回目录 对象 3.1 使用字面值创建对象。 12345// badconst item = new Object();// goodconst item = &#123;&#125;; 3.2 如果你的代码在浏览器环境下执行，别使用 保留字 作为键值。这样的话在 IE8 不会运行。 更多信息。 但在 ES6 模块和服务器端中使用没有问题。 1234567891011// badconst superman = &#123; default: &#123; clark: 'kent' &#125;, private: true,&#125;;// goodconst superman = &#123; defaults: &#123; clark: 'kent' &#125;, hidden: true,&#125;; 3.3 使用同义词替换需要使用的保留字。 1234567891011121314// badconst superman = &#123; class: 'alien',&#125;;// badconst superman = &#123; klass: 'alien',&#125;;// goodconst superman = &#123; type: 'alien',&#125;; 3.4 创建有动态属性名的对象时，使用可被计算的属性名称。 为什么？因为这样可以让你在一个地方定义所有的对象属性。 1234567891011121314151617function getKey(k) &#123; return `a key named $&#123;k&#125;`;&#125;// badconst obj = &#123; id: 5, name: 'San Francisco',&#125;;obj[getKey('enabled')] = true;// goodconst obj = &#123; id: 5, name: 'San Francisco', [getKey('enabled')]: true,&#125;; 3.5 使用对象方法的简写。 1234567891011121314151617// badconst atom = &#123; value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 3.6 使用对象属性值的简写。 为什么？因为这样更短更有描述性。 1234567891011const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123; lukeSkywalker: lukeSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker,&#125;; 3.7 在对象属性声明前把简写的属性分组。 为什么？因为这样能清楚地看出哪些属性使用了简写。 12345678910111213141516171819202122const anakinSkywalker = 'Anakin Skywalker';const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123; episodeOne: 1, twoJedisWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJedisWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4,&#125;; ⬆ 返回目录 数组 4.1 使用字面值创建数组。 12345// badconst items = new Array();// goodconst items = []; 4.2 向数组添加元素时使用 Arrary#push 替代直接赋值。 12345678const someStack = [];// badsomeStack[someStack.length] = 'abracadabra';// goodsomeStack.push('abracadabra'); 4.3 使用拓展运算符 ... 复制数组。 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 4.4 使用 Array#from 把一个类数组对象转换成数组。 12const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo); ⬆ 返回目录 解构 5.1 使用解构存取和使用多属性对象。 为什么？因为解构能减少临时引用属性。 123456789101112131415161718// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; 5.2 对数组使用解构赋值。 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 5.3 需要回传多个值时，使用对象解构，而不是数组解构。 为什么？增加属性或者改变排序不会改变调用时的位置。 1234567891011121314151617// badfunction processInput(input) &#123; // then a miracle occurs return [left, right, top, bottom];&#125;// 调用时需要考虑回调数据的顺序。const [left, __, top] = processInput(input);// goodfunction processInput(input) &#123; // then a miracle occurs return &#123; left, right, top, bottom &#125;;&#125;// 调用时只选择需要的数据const &#123; left, right &#125; = processInput(input); ⬆ 返回目录 Strings 6.1 字符串使用单引号 &#39;&#39; 。 12345// badconst name = \"Capt. Janeway\";// goodconst name = 'Capt. Janeway'; 6.2 字符串超过 80 个字节应该使用字符串连接号换行。 6.3 注：过度使用字串连接符号可能会对性能造成影响。jsPerf 和 讨论. 12345678910111213// badconst errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';// badconst errorMessage = 'This is a super long error that was thrown because \\of Batman. When you stop to think about how Batman had anything to do \\with this, you would get nowhere \\fast.';// goodconst errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.'; 6.4 程序化生成字符串时，使用模板字符串代替字符串连接。 为什么？模板字符串更为简洁，更具可读性。 1234567891011121314// badfunction sayHi(name) &#123; return 'How are you, ' + name + '?';&#125;// badfunction sayHi(name) &#123; return ['How are you, ', name, '?'].join();&#125;// goodfunction sayHi(name) &#123; return `How are you, $&#123;name&#125;?`;&#125; ⬆ 返回目录 函数 7.1 使用函数声明代替函数表达式。 为什么？因为函数声明是可命名的，所以他们在调用栈中更容易被识别。此外，函数声明会把整个函数提升（hoisted），而函数表达式只会把函数的引用变量名提升。这条规则使得箭头函数可以取代函数表达式。 1234567// badconst foo = function () &#123;&#125;;// goodfunction foo() &#123;&#125; 7.2 函数表达式: 1234// 立即调用的函数表达式 (IIFE)(() =&gt; &#123; console.log('Welcome to the Internet. Please follow me.');&#125;)(); 7.3 永远不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但它们的解析表现不一致。 7.4 注意: ECMA-262 把 block 定义为一组语句。函数声明不是语句。阅读 ECMA-262 关于这个问题的说明。 1234567891011121314// badif (currentUser) &#123; function test() &#123; console.log('Nope.'); &#125;&#125;// goodlet test;if (currentUser) &#123; test = () =&gt; &#123; console.log('Yup.'); &#125;;&#125; 7.5 永远不要把参数命名为 arguments。这将取代原来函数作用域内的 arguments 对象。 123456789// badfunction nope(name, options, arguments) &#123; // ...stuff...&#125;// goodfunction yup(name, options, args) &#123; // ...stuff...&#125; 7.6 不要使用 arguments。可以选择 rest 语法 ... 替代。 为什么？使用 ... 能明确你要传入的参数。另外 rest 参数是一个真正的数组，而 arguments 是一个类数组。 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join('');&#125;// goodfunction concatenateAll(...args) &#123; return args.join('');&#125; 7.7 直接给函数的参数指定默认值，不要使用一个变化的函数参数。 12345678910111213141516171819202122// really badfunction handleThings(opts) &#123; // 不！我们不应该改变函数参数。 // 更加糟糕: 如果参数 opts 是 false 的话，它就会被设定为一个对象。 // 但这样的写法会造成一些 Bugs。 //（译注：例如当 opts 被赋值为空字符串，opts 仍然会被下一行代码设定为一个空对象。） opts = opts || &#123;&#125;; // ...&#125;// still badfunction handleThings(opts) &#123; if (opts === void 0) &#123; opts = &#123;&#125;; &#125; // ...&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; 7.8 直接给函数参数赋值时需要避免副作用。 为什么？因为这样的写法让人感到很困惑。 123456789var b = 1;// badfunction count(a = b++) &#123; console.log(a);&#125;count(); // 1count(); // 2count(3); // 3count(); // 3 ⬆ 返回目录 箭头函数 8.1 当你必须使用函数表达式（或传递一个匿名函数）时，使用箭头函数符号。 为什么?因为箭头函数创造了新的一个 this 执行环境（译注：参考 Arrow functions - JavaScript | MDN 和 ES6 arrow functions, syntax and lexical scoping），通常情况下都能满足你的需求，而且这样的写法更为简洁。 为什么不？如果你有一个相当复杂的函数，你或许可以把逻辑部分转移到一个函数声明上。 123456789// bad[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;); 8.2 如果一个函数适合用一行写出并且只有一个参数，那就把花括号、圆括号和 return 都省略掉。如果不是，那就不要省略。 为什么？语法糖。在链式调用中可读性很高。 为什么不？当你打算回传一个对象的时候。 1234567// good[1, 2, 3].map(x =&gt; x * x);// good[1, 2, 3].reduce((total, n) =&gt; &#123; return total + n;&#125;, 0); ⬆ 返回目录 构造器 9.1 总是使用 class。避免直接操作 prototype 。 为什么? 因为 class 语法更为简洁更易读。 12345678910111213141516171819202122// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 9.2 使用 extends 继承。 为什么？因为 extends 是一个内建的原型继承方法并且不会破坏 instanceof。 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 9.3 方法可以返回 this 来帮助链式调用。 12345678910111213141516171819202122232425262728293031// badJedi.prototype.jump = function() &#123; this.jumping = true; return true;&#125;;Jedi.prototype.setHeight = function(height) &#123; this.height = height;&#125;;const luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20); // =&gt; undefined// goodclass Jedi &#123; jump() &#123; this.jumping = true; return this; &#125; setHeight(height) &#123; this.height = height; return this; &#125;&#125;const luke = new Jedi();luke.jump() .setHeight(20); 9.4 可以写一个自定义的 toString() 方法，但要确保它能正常运行并且不会引起副作用。 12345678910111213class Jedi &#123; constructor(options = &#123;&#125;) &#123; this.name = options.name || 'no name'; &#125; getName() &#123; return this.name; &#125; toString() &#123; return `Jedi - $&#123;this.getName()&#125;`; &#125;&#125; ⬆ 返回目录 模块 10.1 总是使用模组 (import/export) 而不是其他非标准模块系统。你可以编译为你喜欢的模块系统。 为什么？模块就是未来，让我们开始迈向未来吧。 1234567891011// badconst AirbnbStyleGuide = require('./AirbnbStyleGuide');module.exports = AirbnbStyleGuide.es6;// okimport AirbnbStyleGuide from './AirbnbStyleGuide';export default AirbnbStyleGuide.es6;// bestimport &#123; es6 &#125; from './AirbnbStyleGuide';export default es6; 10.2 不要使用通配符 import。 为什么？这样能确保你只有一个默认 export。 12345// badimport * as AirbnbStyleGuide from './AirbnbStyleGuide';// goodimport AirbnbStyleGuide from './AirbnbStyleGuide'; 10.3 不要从 import 中直接 export。 为什么？虽然一行代码简洁明了，但让 import 和 export 各司其职让事情能保持一致。 12345678// bad// filename es6.jsexport &#123; es6 as default &#125; from './airbnbStyleGuide';// good// filename es6.jsimport &#123; es6 &#125; from './AirbnbStyleGuide';export default es6; ⬆ 返回目录 Iterators and Generators 11.1 不要使用 iterators。使用高阶函数例如 map() 和 reduce() 替代 for-of。 为什么？这加强了我们不变的规则。处理纯函数的回调值更易读，这比它带来的副作用更重要。 123456789101112131415161718const numbers = [1, 2, 3, 4, 5];// badlet sum = 0;for (let num of numbers) &#123; sum += num;&#125;sum === 15;// goodlet sum = 0;numbers.forEach((num) =&gt; sum += num);sum === 15;// best (use the functional force)const sum = numbers.reduce((total, num) =&gt; total + num, 0);sum === 15; 11.2 现在还不要使用 generators。 为什么？因为它们现在还没法很好地编译到 ES5。 (译者注：目前(2016/03) Chrome 和 Node.js 的稳定版本都已支持 generators) ⬆ 返回目录 属性 12.1 使用 . 来访问对象的属性。 12345678910const luke = &#123; jedi: true, age: 28,&#125;;// badconst isJedi = luke['jedi'];// goodconst isJedi = luke.jedi; 12.2 当通过变量访问属性时使用中括号 []。 12345678910const luke = &#123; jedi: true, age: 28,&#125;;function getProp(prop) &#123; return luke[prop];&#125;const isJedi = getProp('jedi'); ⬆ 返回目录 变量 13.1 一直使用 const 来声明变量，如果不这样做就会产生全局变量。我们需要避免全局命名空间的污染。地球队长已经警告过我们了。（译注：全局，global 亦有全球的意思。地球队长的责任是保卫地球环境，所以他警告我们不要造成「全球」污染。） 12345// badsuperPower = new SuperPower();// goodconst superPower = new SuperPower(); 13.2 使用 const 声明每一个变量。 为什么？增加新变量将变的更加容易，而且你永远不用再担心调换错 ; 跟 ,。 123456789101112131415// badconst items = getItems(), goSportsTeam = true, dragonball = 'z';// bad// (compare to above, and try to spot the mistake)const items = getItems(), goSportsTeam = true; dragonball = 'z';// goodconst items = getItems();const goSportsTeam = true;const dragonball = 'z'; 13.3 将所有的 const 和 let 分组 为什么？当你需要把已赋值变量赋值给未赋值变量时非常有用。 123456789101112131415161718// badlet i, len, dragonball, items = getItems(), goSportsTeam = true;// badlet i;const items = getItems();let dragonball;const goSportsTeam = true;let len;// goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length; 13.4 在你需要的地方给变量赋值，但请把它们放在一个合理的位置。 为什么？let 和 const 是块级作用域而不是函数作用域。 12345678910111213141516171819202122232425262728293031323334353637383940// goodfunction() &#123; test(); console.log('doing stuff..'); //..other stuff.. const name = getName(); if (name === 'test') &#123; return false; &#125; return name;&#125;// bad - unnecessary function callfunction(hasName) &#123; const name = getName(); if (!hasName) &#123; return false; &#125; this.setFirstName(name); return true;&#125;// goodfunction(hasName) &#123; if (!hasName) &#123; return false; &#125; const name = getName(); this.setFirstName(name); return true;&#125; ⬆ 返回目录 Hoisting 14.1 var 声明会被提升至该作用域的顶部，但它们赋值不会提升。let 和 const 被赋予了一种称为「暂时性死区（Temporal Dead Zones, TDZ）」的概念。这对于了解为什么 type of 不再安全相当重要。 12345678910111213141516171819202122232425262728// 我们知道这样运行不了// （假设 notDefined 不是全局变量）function example() &#123; console.log(notDefined); // =&gt; throws a ReferenceError&#125;// 由于变量提升的原因，// 在引用变量后再声明变量是可以运行的。// 注：变量的赋值 `true` 不会被提升。function example() &#123; console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;&#125;// 编译器会把函数声明提升到作用域的顶层，// 这意味着我们的例子可以改写成这样：function example() &#123; let declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;&#125;// 使用 const 和 letfunction example() &#123; console.log(declaredButNotAssigned); // =&gt; throws a ReferenceError console.log(typeof declaredButNotAssigned); // =&gt; throws a ReferenceError const declaredButNotAssigned = true;&#125; 14.2 匿名函数表达式的变量名会被提升，但函数内容并不会。 123456789function example() &#123; console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; TypeError anonymous is not a function var anonymous = function() &#123; console.log('anonymous function expression'); &#125;;&#125; 14.3 命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会。 1234567891011121314151617181920212223function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function superPower(); // =&gt; ReferenceError superPower is not defined var named = function superPower() &#123; console.log('Flying'); &#125;;&#125;// the same is true when the function name// is the same as the variable name.function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function var named = function named() &#123; console.log('named'); &#125;&#125; 14.4 函数声明的名称和函数体都会被提升。 1234567function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log('Flying'); &#125;&#125; 想了解更多信息，参考 Ben Cherry 的 JavaScript Scoping &amp; Hoisting。 ⬆ 返回目录 比较运算符和等号 15.1 优先使用 === 和 !== 而不是 == 和 !=. 15.2 条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则： 对象 被计算为 true Undefined 被计算为 false Null 被计算为 false 布尔值 被计算为 布尔的值 数字 如果是 +0、-0、或 NaN 被计算为 false, 否则为 true 字符串 如果是空字符串 &#39;&#39; 被计算为 false，否则为 true 1234if ([0]) &#123; // true // An array is an object, objects evaluate to true&#125; 15.3 使用简写。 12345678910111213141516171819// badif (name !== '') &#123; // ...stuff...&#125;// goodif (name) &#123; // ...stuff...&#125;// badif (collection.length &gt; 0) &#123; // ...stuff...&#125;// goodif (collection.length) &#123; // ...stuff...&#125; 15.4 想了解更多信息，参考 Angus Croll 的 Truth Equality and JavaScript。 ⬆ 返回目录 代码块 16.1 使用大括号包裹所有的多行代码块。 12345678910111213141516171819// badif (test) return false;// goodif (test) return false;// goodif (test) &#123; return false;&#125;// badfunction() &#123; return false; &#125;// goodfunction() &#123; return false;&#125; 16.2 如果通过 if 和 else 使用多行代码块，把 else 放在 if 代码块关闭括号的同一行。 12345678910111213141516// badif (test) &#123; thing1(); thing2();&#125;else &#123; thing3();&#125;// goodif (test) &#123; thing1(); thing2();&#125; else &#123; thing3();&#125; ⬆ 返回目录 注释 17.1 使用 /** ... */ 作为多行注释。包含描述、指定所有参数和返回值的类型和值。 123456789101112131415161718192021222324252627// bad// make() returns a new element// based on the passed in tag name//// @param &#123;String&#125; tag// @return &#123;Element&#125; elementfunction make(tag) &#123; // ...stuff... return element;&#125;// good/** * make() returns a new element * based on the passed in tag name * * @param &#123;String&#125; tag * @return &#123;Element&#125; element */function make(tag) &#123; // ...stuff... return element;&#125; 17.2 使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行。 12345678910111213141516171819202122232425// badconst active = true; // is current tab// good// is current tabconst active = true;// badfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type'; return type;&#125;// goodfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type'; return type;&#125; 17.3 给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 FIXME -- need to figure this out 或者 TODO -- need to implement。 17.4 使用 // FIXME: 标注问题。 123456class Calculator &#123; constructor() &#123; // FIXME: shouldn't use a global here total = 0; &#125;&#125; 17.5 使用 // TODO: 标注问题的解决方式。 123456class Calculator &#123; constructor() &#123; // TODO: total should be configurable by an options param this.total = 0; &#125;&#125; ⬆ 返回目录 空白 18.1 使用 2 个空格作为缩进。 1234567891011121314// badfunction() &#123;∙∙∙∙const name;&#125;// badfunction() &#123;∙const name;&#125;// goodfunction() &#123;∙∙const name;&#125; 18.2 在花括号前放一个空格。 123456789101112131415161718192021// badfunction test()&#123; console.log('test');&#125;// goodfunction test() &#123; console.log('test');&#125;// baddog.set('attr',&#123; age: '1 year', breed: 'Bernese Mountain Dog',&#125;);// gooddog.set('attr', &#123; age: '1 year', breed: 'Bernese Mountain Dog',&#125;); 18.3 在控制语句（if、while 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。 12345678910111213141516171819// badif(isJedi) &#123; fight ();&#125;// goodif (isJedi) &#123; fight();&#125;// badfunction fight () &#123; console.log ('Swooosh!');&#125;// goodfunction fight() &#123; console.log('Swooosh!');&#125; 18.4 使用空格把运算符隔开。 12345// badconst x=y+5;// goodconst x = y + 5; 18.5 在文件末尾插入一个空行。 1234// bad(function(global) &#123; // ...stuff...&#125;)(this); 12345// bad(function(global) &#123; // ...stuff...&#125;)(this);↵↵ 1234// good(function(global) &#123; // ...stuff...&#125;)(this);↵ 18.5 在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。 12345678910111213141516171819202122232425262728293031323334// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// bad$('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount();// badconst leds = stage.selectAll('.led').data(data).enter().append('svg:svg').class('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led);// goodconst leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led); 18.6 在块末和新语句前插入空行。 1234567891011121314151617181920212223242526272829303132// badif (foo) &#123; return bar;&#125;return baz;// goodif (foo) &#123; return bar;&#125;return baz;// badconst obj = &#123; foo() &#123; &#125;, bar() &#123; &#125;,&#125;;return obj;// goodconst obj = &#123; foo() &#123; &#125;, bar() &#123; &#125;,&#125;;return obj; ⬆ 返回目录 逗号 19.1 行首逗号：不需要。 1234567891011121314151617181920212223242526272829// badconst story = [ once , upon , aTime];// goodconst story = [ once, upon, aTime,];// badconst hero = &#123; firstName: 'Ada' , lastName: 'Lovelace' , birthYear: 1815 , superPower: 'computers'&#125;;// goodconst hero = &#123; firstName: 'Ada', lastName: 'Lovelace', birthYear: 1815, superPower: 'computers',&#125;; 19.2 增加结尾的逗号: 需要。 为什么? 这会让 git diffs 更干净。另外，像 babel 这样的转译器会移除结尾多余的逗号，也就是说你不必担心老旧浏览器的尾逗号问题。 123456789101112131415161718192021222324252627282930313233343536// bad - git diff without trailing commaconst hero = &#123; firstName: 'Florence',- lastName: 'Nightingale'+ lastName: 'Nightingale',+ inventorOf: ['coxcomb graph', 'modern nursing']&#125;// good - git diff with trailing commaconst hero = &#123; firstName: 'Florence', lastName: 'Nightingale',+ inventorOf: ['coxcomb chart', 'modern nursing'],&#125;// badconst hero = &#123; firstName: 'Dana', lastName: 'Scully'&#125;;const heroes = [ 'Batman', 'Superman'];// goodconst hero = &#123; firstName: 'Dana', lastName: 'Scully',&#125;;const heroes = [ 'Batman', 'Superman',]; ⬆ 返回目录 分号 20.1 使用分号 1234567891011121314151617// bad(function() &#123; const name = 'Skywalker' return name&#125;)()// good(() =&gt; &#123; const name = 'Skywalker'; return name;&#125;)();// good (防止函数在两个 IIFE 合并时被当成一个参数);(() =&gt; &#123; const name = 'Skywalker'; return name;&#125;)(); Read more. ⬆ 返回目录 类型转换 21.1 在语句开始时执行类型转换。 21.2 字符串： 1234567// =&gt; this.reviewScore = 9;// badconst totalScore = this.reviewScore + '';// goodconst totalScore = String(this.reviewScore); 21.3 对数字使用 parseInt 转换，并带上类型转换的基数。 12345678910111213141516171819const inputValue = '4';// badconst val = new Number(inputValue);// badconst val = +inputValue;// badconst val = inputValue &gt;&gt; 0;// badconst val = parseInt(inputValue);// goodconst val = Number(inputValue);// goodconst val = parseInt(inputValue, 10); 21.4 如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。 123456// good/** * 使用 parseInt 导致我的程序变慢， * 改成使用位操作转换数字快多了。 */const val = inputValue &gt;&gt; 0; 21.5 注: 小心使用位操作运算符。数字会被当成 64 位值，但是位操作运算符总是返回 32 位的整数（参考）。位操作处理大于 32 位的整数值时还会导致意料之外的行为。关于这个问题的讨论。最大的 32 位整数是 2,147,483,647： 1232147483647 &gt;&gt; 0 //=&gt; 21474836472147483648 &gt;&gt; 0 //=&gt; -21474836482147483649 &gt;&gt; 0 //=&gt; -2147483647 21.6 布尔: 12345678910const age = 0;// badconst hasAge = new Boolean(age);// goodconst hasAge = Boolean(age);// goodconst hasAge = !!age; ⬆ 返回目录 命名规则 22.1 避免单字母命名。命名应具备描述性。 123456789// badfunction q() &#123; // ...stuff...&#125;// goodfunction query() &#123; // ..stuff..&#125; 22.2 使用驼峰式命名对象、函数和实例。 12345678// badconst OBJEcttsssss = &#123;&#125;;const this_is_my_object = &#123;&#125;;function c() &#123;&#125;// goodconst thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125; 22.3 使用帕斯卡式命名构造函数或类。 12345678910111213141516171819// badfunction user(options) &#123; this.name = options.name;&#125;const bad = new user(&#123; name: 'nope',&#125;);// goodclass User &#123; constructor(options) &#123; this.name = options.name; &#125;&#125;const good = new User(&#123; name: 'yup',&#125;); 22.4 不要使用下划线 _ 结尾或开头来命名属性和方法。 1234567// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';this._firstName = 'Panda';// goodthis.firstName = 'Panda'; 22.5 别保存 this 的引用。使用箭头函数或 Function#bind。 12345678910111213141516171819202122// badfunction foo() &#123; const self = this; return function() &#123; console.log(self); &#125;;&#125;// badfunction foo() &#123; const that = this; return function() &#123; console.log(that); &#125;;&#125;// goodfunction foo() &#123; return () =&gt; &#123; console.log(this); &#125;;&#125; 22.6 如果你的文件只输出一个类，那你的文件名必须和类名完全保持一致。 123456789101112131415// file contentsclass CheckBox &#123; // ...&#125;export default CheckBox;// in some other file// badimport CheckBox from './checkBox';// badimport CheckBox from './check_box';// goodimport CheckBox from './CheckBox'; 22.7 当你导出默认的函数时使用驼峰式命名。你的文件名必须和函数名完全保持一致。 1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 22.8 当你导出单例、函数库、空对象时使用帕斯卡式命名。 123456const AirbnbStyleGuide = &#123; es6: &#123; &#125;&#125;;export default AirbnbStyleGuide; ⬆ 返回目录 存取器 23.1 属性的存取函数不是必须的。 23.2 如果你需要存取函数时使用 getVal() 和 setVal(&#39;hello&#39;)。 1234567891011// baddragon.age();// gooddragon.getAge();// baddragon.age(25);// gooddragon.setAge(25); 23.3 如果属性是布尔值，使用 isVal() 或 hasVal()。 123456789// badif (!dragon.age()) &#123; return false;&#125;// goodif (!dragon.hasAge()) &#123; return false;&#125; 23.4 创建 get() 和 set() 函数是可以的，但要保持一致。 1234567891011121314class Jedi &#123; constructor(options = &#123;&#125;) &#123; const lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber); &#125; set(key, val) &#123; this[key] = val; &#125; get(key) &#123; return this[key]; &#125;&#125; ⬆ 返回目录 事件 24.1 当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。例如，不好的写法： 12345678// bad$(this).trigger('listingUpdated', listing.id);...$(this).on('listingUpdated', function(e, listingId) &#123; // do something with listingId&#125;); 更好的写法： 12345678// good$(this).trigger('listingUpdated', &#123; listingId : listing.id &#125;);...$(this).on('listingUpdated', function(e, data) &#123; // do something with data.listingId&#125;); ⬆ 返回目录 jQuery 25.1 使用 $ 作为存储 jQuery 对象的变量名前缀。 12345// badconst sidebar = $('.sidebar');// goodconst $sidebar = $('.sidebar'); 25.2 缓存 jQuery 查询。 12345678910111213141516171819202122// badfunction setSidebar() &#123; $('.sidebar').hide(); // ...stuff... $('.sidebar').css(&#123; 'background-color': 'pink' &#125;);&#125;// goodfunction setSidebar() &#123; const $sidebar = $('.sidebar'); $sidebar.hide(); // ...stuff... $sidebar.css(&#123; 'background-color': 'pink' &#125;);&#125; 25.3 对 DOM 查询使用层叠 $(&#39;.sidebar ul&#39;) 或 父元素 &gt; 子元素 $(&#39;.sidebar &gt; ul&#39;)。 jsPerf 25.4 对有作用域的 jQuery 对象查询使用 find。 1234567891011121314// bad$('ul', '.sidebar').hide();// bad$('.sidebar').find('ul').hide();// good$('.sidebar ul').hide();// good$('.sidebar &gt; ul').hide();// good$sidebar.find('ul').hide(); ⬆ 返回目录 ECMAScript 5 兼容性 26.1 参考 Kangax 的 ES5 兼容性。 ⬆ 返回目录 ECMAScript 6 规范 27.1 以下是链接到 ES6 各个特性的列表。 箭头函数 类 对象方法简写 对象属性简写 对象中的可计算属性 模板字符串 解构 默认参数 Rest 数组 Spreads Let 及 Const 迭代器和生成器 模块 ⬆ 返回目录 测试 28.1 Yup. 123function() &#123; return true;&#125; ⬆ 返回目录 性能 On Layout &amp; Web Performance String vs Array Concat Try/Catch Cost In a Loop Bang Function jQuery Find vs Context, Selector innerHTML vs textContent for script text Long String Concatenation Are Javascript functions like map(), reduce(), and filter() optimized for traversing arrays? 等等… ⬆ 返回目录 相关资源（英文）了解 ES6 ECMA 2015 (ES6) 规范草案 ExploringJS ES6 兼容性表 ES6 特性全面概况 看看这个 Annotated ECMAScript 5.1 工具 代码风格检查器（Lint） ESlint - Airbnb Style .eslintrc JSHint - Airbnb Style .jshintrc JSCS - Airbnb Style Preset 拓展阅读 Understanding JavaScript Closures - Angus Croll Basic JavaScript for the impatient programmer - Dr. Axel Rauschmayer You Might Not Need jQuery - Zack Bloom &amp; Adam Schwartz ES6 Features - Luke Hoban Frontend Guidelines - Benjamin De Cock 书籍 JavaScript: The Good Parts - Douglas Crockford JavaScript Patterns - Stoyan Stefanov Pro JavaScript Design Patterns - Ross Harmes and Dustin Diaz High Performance Web Sites: Essential Knowledge for Front-End Engineers - Steve Souders Maintainable JavaScript - Nicholas C. Zakas JavaScript Web Applications - Alex MacCaw Pro JavaScript Techniques - John Resig Smashing Node.js: JavaScript Everywhere - Guillermo Rauch Secrets of the JavaScript Ninja - John Resig and Bear Bibeault Human JavaScript - Henrik Joreteg Superhero.js - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy JSBooks - Julien Bouquillon Third Party JavaScript - Ben Vinegar and Anton Kovalyov Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript - David Herman Eloquent JavaScript - Marijn Haverbeke 修订我们鼓励您派生本指南和更改规则以适应您的团队需求。您可以在下方列出对本风格指南的修改，以便定期更新本指南而无需处理合并冲突。 };","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"代码风格标准","slug":"代码风格标准","permalink":"http://wiki.haoqiao.me/tags/代码风格标准/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"开发标准","slug":"前端/开发标准","permalink":"http://wiki.haoqiao.me/categories/前端/开发标准/"}]},{"title":"Airbnb CSS 代码风格标准","date":"2017-09-04T03:23:22.000Z","path":"wiki/前端/开发标准/Airbnb Css 标准/","text":"目录 术语 规则声明 选择器 属性 CSS 格式 注释 OOCSS 和 BEM ID 选择器 JavaScript 钩子 边框 Sass 语法 排序 变量 Mixins 扩展指令 嵌套选择器 术语 规则声明我们把一个（或一组）选择器和一组属性称之为 “规则声明”。举个例子： 1234.listing &#123; font-size: 18px; line-height: 1.2;&#125; 选择器在规则声明中，“选择器” 负责选取 DOM 树中的元素，这些元素将被定义的属性所修饰。选择器可以匹配 HTML 元素，也可以匹配一个元素的类名、ID, 或者元素拥有的属性。以下是选择器的例子： 1234567.my-element-class &#123; /* ... */&#125;[aria-hidden] &#123; /* ... */&#125; 属性最后，属性决定了规则声明里被选择的元素将得到何种样式。属性以键值对形式存在，一个规则声明可以包含一或多个属性定义。以下是属性定义的例子： 1234/* some selector */ &#123; background: #f1f1f1; color: #333;&#125; CSS 格式 使用 2 个空格作为缩进。 类名建议使用破折号代替驼峰法。如果你使用 BEM，也可以使用下划线（参见下面的 OOCSS 和 BEM）。 不要使用 ID 选择器。 在一个规则声明中应用了多个选择器时，每个选择器独占一行。 在规则声明的左大括号 { 前加上一个空格。 在属性的冒号 : 后面加上一个空格，前面不加空格。 规则声明的右大括号 } 独占一行。 规则声明之间用空行分隔开。 Bad 123456789.avatar&#123; border-radius:50%; border:2px solid white; &#125;.no, .nope, .not_good &#123; // ...&#125;#lol-no &#123; // ...&#125; Good 12345678910.avatar &#123; border-radius: 50%; border: 2px solid white;&#125;.one,.selector,.per-line &#123; // ...&#125; 注释 建议使用行注释 (在 Sass 中是 //) 代替块注释。 建议注释独占一行。避免行末注释。 给没有自注释的代码写上详细说明，比如： 为什么用到了 z-index 兼容性处理或者针对特定浏览器的 hack OOCSS 和 BEM出于以下原因，我们鼓励使用 OOCSS 和 BEM 的某种组合： 可以帮助我们理清 CSS 和 HTML 之间清晰且严谨的关系。 可以帮助我们创建出可重用、易装配的组件。 可以减少嵌套，降低特定性。 可以帮助我们创建出可扩展的样式表。 OOCSS，也就是 “Object Oriented CSS（面向对象的CSS）”，是一种写 CSS 的方法，其思想就是鼓励你把样式表看作“对象”的集合：创建可重用性、可重复性的代码段让你可以在整个网站中多次使用。 参考资料： Nicole Sullivan 的 OOCSS wiki Smashing Magazine 的 Introduction to OOCSS BEM，也就是 “Block-Element-Modifier”，是一种用于 HTML 和 CSS 类名的命名约定。BEM 最初是由 Yandex 提出的，要知道他们拥有巨大的代码库和可伸缩性，BEM 就是为此而生的，并且可以作为一套遵循 OOCSS 的参考指导规范。 CSS Trick 的 BEM 101 Harry Roberts 的 introduction to BEM 示例 123456789&lt;article class=\"listing-card listing-card--featured\"&gt; &lt;h1 class=\"listing-card__title\"&gt;Adorable 2BR in the sunny Mission&lt;/h1&gt; &lt;div class=\"listing-card__content\"&gt; &lt;p&gt;Vestibulum id ligula porta felis euismod semper.&lt;/p&gt; &lt;/div&gt;&lt;/article&gt; 1234.listing-card &#123; &#125;.listing-card--featured &#123; &#125;.listing-card__title &#123; &#125;.listing-card__content &#123; &#125; .listing-card 是一个块（block），表示高层次的组件。 .listing-card__title 是一个元素（element），它属于 .listing-card 的一部分，因此块是由元素组成的。 .listing-card--featured 是一个修饰符（modifier），表示这个块与 .listing-card 有着不同的状态或者变化。 ID 选择器在 CSS 中，虽然可以通过 ID 选择元素，但大家通常都会把这种方式列为反面教材。ID 选择器给你的规则声明带来了不必要的高优先级，而且 ID 选择器是不可重用的。 想要了解关于这个主题的更多内容，参见 CSS Wizardry 的文章，文章中有关于如何处理优先级的内容。 JavaScript 钩子避免在 CSS 和 JavaScript 中绑定相同的类。否则开发者在重构时通常会出现以下情况：轻则浪费时间在对照查找每个要改变的类，重则因为害怕破坏功能而不敢作出更改。 我们推荐在创建用于特定 JavaScript 的类名时，添加 .js- 前缀： 1&lt;button class=\"btn btn-primary js-request-to-book\"&gt;Request to Book&lt;/button&gt; 边框在定义无边框样式时，使用 0 代替 none。 Bad 123.foo &#123; border: none;&#125; Good 123.foo &#123; border: 0;&#125; Sass 语法 使用 .scss 的语法，不使用 .sass 原本的语法。 CSS 和 @include 声明按照以下逻辑排序（参见下文） 属性声明的排序 属性声明 首先列出除去 @include 和嵌套选择器之外的所有属性声明。 12345.btn-green &#123; background: green; font-weight: bold; // ...&#125; @include 声明 紧随后面的是 @include，这样可以使得整个选择器的可读性更高。 123456.btn-green &#123; background: green; font-weight: bold; @include transition(background 0.5s ease); // ...&#125; 嵌套选择器 如果有必要用到嵌套选择器，把它们放到最后，在规则声明和嵌套选择器之间要加上空白，相邻嵌套选择器之间也要加上空白。嵌套选择器中的内容也要遵循上述指引。 123456789.btn &#123; background: green; font-weight: bold; @include transition(background 0.5s ease); .icon &#123; margin-right: 10px; &#125;&#125; 变量变量名应使用破折号（例如 $my-variable）代替 camelCased 和 snake_cased 风格。对于仅用在当前文件的变量，可以在变量名之前添加下划线前缀（例如 $_my-variable）。 Mixins为了让代码遵循 DRY 原则（Don’t Repeat Yourself）、增强清晰性或抽象化复杂性，应该使用 mixin，这与那些命名良好的函数的作用是异曲同工的。虽然 mixin 可以不接收参数，但要注意，假如你不压缩负载（比如通过 gzip），这样会导致最终的样式包含不必要的代码重复。 扩展指令应避免使用 @extend 指令，因为它并不直观，而且具有潜在风险，特别是用在嵌套选择器的时候。即便是在顶层占位符选择器使用扩展，如果选择器的顺序最终会改变，也可能会导致问题。（比如，如果它们存在于其他文件，而加载顺序发生了变化）。其实，使用 @extend 所获得的大部分优化效果，gzip 压缩已经帮助你做到了，因此你只需要通过 mixin 让样式表更符合 DRY 原则就足够了。 嵌套选择器请不要让嵌套选择器的深度超过 3 层！ 1234567.page-container &#123; .content &#123; .profile &#123; // STOP! &#125; &#125;&#125; 当遇到以上情况的时候，你也许是这样写 CSS 的： 与 HTML 强耦合的（也是脆弱的）—或者— 过于具体（强大）—或者— 没有重用 再说一遍: 永远不要嵌套 ID 选择器！ 如果你始终坚持要使用 ID 选择器（劝你三思），那也不应该嵌套它们。如果你正打算这么做，你需要先重新检查你的标签，或者指明原因。如果你想要写出风格良好的 HTML 和 CSS，你是不应该这样做的。","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"代码风格标准","slug":"代码风格标准","permalink":"http://wiki.haoqiao.me/tags/代码风格标准/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"开发标准","slug":"前端/开发标准","permalink":"http://wiki.haoqiao.me/categories/前端/开发标准/"}]},{"title":"React项目开发一些摘要","date":"2017-08-22T06:30:41.000Z","path":"wiki/前端/框架/React/React项目开发一些摘要/","text":"React动画input css demo123456789101112131415.input &#123; transition: width .35s linear; outline: none; border: none; border-radius: 4px; padding: 10px; font-size: 20px; width: 150px; background-color: #dddddd;&#125;.input-focused &#123; width: 240px;&#125; 12345678910111213141516171819202122232425class App extends Component &#123; state = &#123; focused: false &#125; componentDidMount() &#123; this.input.addEventListener(&apos;focus&apos;, this.focus); this.input.addEventListener(&apos;blur&apos;, this.focus); &#125; focus = () =&gt; &#123; this.setState((state) =&gt; (&#123; focused: !state.focused &#125;)) &#125; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;div className=&quot;container&quot;&gt; &lt;input ref=&#123;input =&gt; this.input = input&#125; className=&#123;[&apos;input&apos;, this.state.focused &amp;&amp; &apos;input-focused&apos;].join(&apos; &apos;)&#125; /&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; input js demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class App extends Component &#123; state = &#123; disabled: true, &#125; onChange = (e) =&gt; &#123; const length = e.target.value.length; if (length &gt;= 4) &#123; this.setState(() =&gt; (&#123; disabled: false &#125;)) &#125; else if (!this.state.disabled) &#123; this.setState(() =&gt; (&#123; disabled: true &#125;)) &#125; &#125; render() &#123; const label = this.state.disabled ? &apos;Disabled&apos; : &apos;Submit&apos;; return ( &lt;div className=&quot;App&quot;&gt; &lt;button style=&#123;Object.assign(&#123;&#125;, styles.button, !this.state.disabled &amp;&amp; styles.buttonEnabled)&#125; disabled=&#123;this.state.disabled&#125; &gt;&#123;label&#125;&lt;/button&gt; &lt;input style=&#123;styles.input&#125; onChange=&#123;this.onChange&#125; /&gt; &lt;/div&gt; ); &#125;&#125;const styles = &#123; input: &#123; width: 200, outline: &apos;none&apos;, fontSize: 20, padding: 10, border: &apos;none&apos;, backgroundColor: &apos;#ddd&apos;, marginTop: 10, &#125;, button: &#123; width: 180, height: 50, border: &apos;none&apos;, borderRadius: 4, fontSize: 20, cursor: &apos;pointer&apos;, transition: &apos;.25s all&apos;, &#125;, buttonEnabled: &#123; backgroundColor: &apos;#ffc107&apos;, width: 220, &#125;&#125; 一些库和其他react-animations","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"React","slug":"React","permalink":"http://wiki.haoqiao.me/tags/React/"},{"name":"技术栈","slug":"技术栈","permalink":"http://wiki.haoqiao.me/tags/技术栈/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"框架","slug":"前端/框架","permalink":"http://wiki.haoqiao.me/categories/前端/框架/"},{"name":"React","slug":"前端/框架/React","permalink":"http://wiki.haoqiao.me/categories/前端/框架/React/"}]},{"title":"React-Es6对照表","date":"2017-07-23T06:30:41.000Z","path":"wiki/前端/框架/React/React-ES6对照表/","text":"前言整理在 React 中 ES5、ES6+ 常见用法对照表。 1. Modules随着 Web 技术的进展，模组化开发已经成为一个重要课题。关于 JavaScript 模组化我们这边不详述，建议读者参考 这份投影片 和 这篇文章。 ES5 若使用 CommonJS 标准，一般使用 require() 用法引入模组： 12var React = require('react');var MyComponent = require('./MyComponent'); 输出则是使用 module.exports： 1module.exports = MyComponent; ES6+ import 用法： 12import React from 'react';import MyComponent from './MyComponent'; 输出则是使用 export default： 123export default class MyComponent extends React.Component &#123;&#125; 2. Classes在 React 中组件（Component）是组成视觉页面的基础。在 ES5 中我们使用 React.createClass() 来建立 Component，而在 ES6+ 则是用 Classes 继承 React.Component 来建立 Component。若是有写过 Java 等物件导向语言（OOP）的读者应该对于这种写法比较不陌生，不过要注意的是 JavaScript 仍是原型继承类型的物件导向程式语言，只是使用 Classes 让物件导向使用上更加直观。对于选择 class 使用上还有疑惑的读者建议可以阅读 React.createClass versus extends React.Component 这篇文章。 ES5 React.createClass() 用法： 12345678910var Photo = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt; &lt;images alt=&#123;this.props.description&#125; src=&#123;this.props.src&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render(&lt;Photo /&gt;, document.getElementById('main')); ES6+ class 用法： 123456class Photo extends React.Component &#123; render() &#123; return &lt;images alt=&#123;this.props.description&#125; src=&#123;this.props.src&#125; /&gt;; &#125;&#125;ReactDOM.render(&lt;Photo /&gt;, document.getElementById('main')); 在 ES5 我们会在 componentWillMount 生命周期定义希望在 render 前执行，且只会执行一次的任务： 123var Photo = React.createClass(&#123; componentWillMount: function() &#123;&#125;&#125;); 在 ES6+ 则是定义在 constructor 建构子中： 123456class Photo extends React.Component &#123; constructor(props) &#123; super(props); // 原本在 componentWillMount 操作的动作可以放在这 &#125;&#125; 3. Method definition在 ES6 中我们使用 Method 可以忽略 function 和 ,，使用上更为简洁！ES5 React.createClass() 用法： 1234var Photo = React.createClass(&#123; handleClick: function(e) &#123;&#125;, render: function() &#123;&#125;&#125;); ES6+ class 用法： 1234class Photo extends React.Component &#123; handleClick(e) &#123;&#125; render() &#123;&#125;&#125; 4. Property initializersComponent 属性值是资料传递重要的元素，在 ES5 中我们使用 propTypes 和 getDefaultProps 来定义属性（props）的预设值和型别： 123456789101112131415var Todo = React.createClass(&#123; getDefaultProps: function() &#123; return &#123; checked: false, maxLength: 10, &#125;; &#125;, propTypes: &#123; checked: React.PropTypes.bool.isRequired, maxLength: React.PropTypes.number.isRequired &#125;, render: function() &#123; return(); &#125;&#125;); 在 ES6+ 中我们则是参考 ES7 property initializers 使用 class 中的静态属性（static properties）来定义： 12345678910111213class Todo extends React.Component &#123; static defaultProps = &#123; checked: false, maxLength: 10, &#125;; // 注意有分号 static propTypes = &#123; checked: React.PropTypes.bool.isRequired, maxLength: React.PropTypes.number.isRequired &#125;; render() &#123; return(); &#125;&#125; ES6+ 另外一种写法，可以留意一下，主要是看各团队喜好和规范，选择合适的方式： 123456789101112131415class Todo extends React.Component &#123; render() &#123; return ( &lt;View /&gt; ); &#125;&#125;Todo.defaultProps = &#123; checked: false, maxLength: 10,&#125;;Todo.propTypes = &#123; checked: React.PropTypes.bool.isRequired, maxLength: React.PropTypes.number.isRequired,&#125;; 5. State在 React 中 Props 和 State 是资料流传递的重要元素，不同的是 state 可更动，可以去执行一些运算。在 ES5 中我们使用 getInitialState 去初始化 state： 1234567var Todo = React.createClass(&#123; getInitialState: function() &#123; return &#123; maxLength: this.props.maxLength, &#125;; &#125;,&#125;); 在 ES6+ 中我们初始化 state 有两种写法： 12345class Todo extends React.Component &#123; state = &#123; maxLength: this.props.maxLength, &#125;&#125; 另外一种写法，使用在建构式初始化。比较推荐使用这种方式，方便做一些运算： 12345678class Todo extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123; maxLength: this.props.maxLength, &#125;; &#125;&#125; 6. Arrow functions在讲 Arrow functions 之前，我们先聊聊在 React 中 this 和它所代表的 context。在 ES5 中，我们使用 React.createClass() 来建立 Component，而在 React.createClass() 下，预设帮你绑定好 method 的 this，你毋须自行绑定。所以你可以看到像是下面的例子，callback function handleButtonClick 中的 this 是指到 component 的实例（instance），而非触发事件的物件： 12345678910111213var TodoBtn = React.createClass(&#123; handleButtonClick: function(e) &#123; // 此 this 指到 component 的实例（instance），而非 button this.setState(&#123;showOptionsModal: true&#125;); &#125;, render: function()&#123; return ( &lt;div&gt; &lt;Button onClick=&#123;this.handleButtonClick&#125;&gt;&#123;this.props.label&#125;&lt;/Button&gt; &lt;/div&gt; ) &#125;,&#125;); 然而自动绑定这种方式反而会让人容易误解，所以在 ES6+ 推荐使用 bind 绑定 this 或使用 Arrow functions（它会绑定当前 scope 的 this context）两种方式，你可以参考下面例子： 123456789101112131415class TodoBtn extends React.Component&#123; handleButtonClick(e)&#123; // 确认绑定 this 指到 component instance this.setState(&#123;toggle: true&#125;); &#125; render()&#123; // 这边可以用 this.handleButtonClick.bind(this) 手动绑定或是 Arrow functions () =&gt; &#123;&#125; 用法 return ( &lt;div&gt; &lt;Button onClick=&#123;this.handleButtonClick.bind(this)&#125; onClick=&#123;(e)=&gt; &#123;this.handleButtonClick(e)&#125; &#125;&gt;&#123;this.props.label&#125;&lt;/Button&gt; &lt;/div&gt; ) &#125;,&#125; Arrow functions 虽然一开始看起来有点怪异，但其实观念很简单：一个简化的函数。函数基本上就是参数（不一定要有参数）、表达式、回传值（也可能是回传 undefined）： 12345678910111213// Arrow functions 的一些例子()=&gt;7e=&gt;e+2()=&gt;&#123; alert(&apos;XD&apos;);&#125;(a,b)=&gt;a+be=&gt;&#123; if (e == 2)&#123; return 2; &#125; return 100/e;&#125; 不过要注意的是无论是 bind 或是 Arrow functions，每次执行回传都是指到一个新的函数，若需要再调用到这个函数，请记得先把它存起来： 错误用法： 12345678910class TodoBtn extends React.Component&#123; componentWillMount()&#123; Btn.addEventListener('click', this.handleButtonClick.bind(this)); &#125; componentDidmount()&#123; Btn.removeEventListener('click', this.handleButtonClick.bind(this)); &#125; onAppPaused(event)&#123; &#125;&#125; 正确用法： 123456789101112class TodoBtn extends React.Component&#123; constructor(props)&#123; super(props); this.handleButtonClick = this.handleButtonClick.bind(this); &#125; componentWillMount()&#123; Btn.addEventListener('click', this.handleButtonClick); &#125; componentDidMount()&#123; Btn.removeEventListener('click', this.handleButtonClick); &#125;&#125; 更多 Arrows and Lexical This 特性可以参考这个文件。 7. Dynamic property names &amp; template strings以前在 ES5 我们要动态设定属性名称时，往往需要多写几行程式码才能达到目标： 1234567var Todo = React.createClass(&#123; onChange: function(inputName, e) &#123; var stateToSet = &#123;&#125;; stateToSet[inputName + 'Value'] = e.target.value; this.setState(stateToSet); &#125;,&#125;); 但在 ES6+中，透过 enhancements to object literals 和 template strings 可以轻松完成动态设定属性名称的任务： 1234567class Todo extends React.Component &#123; onChange(inputName, e) &#123; this.setState(&#123; [`$&#123;inputName&#125;Value`]: e.target.value, &#125;); &#125;&#125; Template Strings 是一种语法糖（syntactic sugar），方便我们组织字串（这边也用上 let、const 变数和常数宣告的方式，和 var 的 function scope 不同的是它们是属于 block scope，亦即生存域存在于 {} 间）： 123// Interpolate variable bindingsconst name = \"Bob\", let = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` \\\\ Hello Bob, how are you today? 8. Destructuring &amp; spread attributes在 React 的 Component 中，父组件利用 props 来传递资料到子组件是常见作法，然而我们有时会希望只传递部分资料，此时 ES6+ 中的 Destructuring 和 JSX 的 Spread Attributes ，... Spread Attributes 主要是用来迭代物件： 1234567891011121314class Todo extends React.Component &#123; render() &#123; var &#123; className, ...others, // ...others 包含 this.props 除了 className 外所有值。this.props = &#123;value: 'true', title: 'header', className: 'content'&#125; &#125; = this.props; return ( &lt;div className=&#123;className&#125;&gt; &lt;TodoList &#123;...others&#125; /&gt; &lt;button onClick=&#123;this.handleLoadMoreClick&#125;&gt;Load more&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 但使用上要注意的是若是有重复的属性值则以后来覆蓋，下面的例子中若 ...this.props，有 className，则被后来的 main 所覆蓋： 123&lt;div &#123;...this.props&#125; className=\"main\"&gt; …&lt;/div&gt; 而 Destructuring 也可以用在简化 Module 的引入上，这边我们先用 ES5 中引入方式来看： 1234567891011121314var React = require('react-native');var Component = React.component;class HelloWorld extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Text&gt;Hello, world!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default HelloWorld; 以下 ES5 写法： 12var React = require(&apos;react-native&apos;);var View = React.View; 在 ES6+ 则可以直接使用 Destructuring 这种简化方式来引入模组中的组件： 12// 这边等于上面的写法var &#123; View &#125; = require(&apos;react-native&apos;); 更进一步可以使用 import 语法： 1234567891011121314151617import React, &#123; View, Component, Text,&#125; from 'react-native';class HelloWorld extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Text&gt;Hello, world!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default HelloWorld; 9. Mixins在 ES5 中，我们可以使用 Mixins 的方式去让不同的 Component 共用相似的功能，重用我们的程式码： 12345678var PureRenderMixin = require('react-addons-pure-render-mixin');React.createClass(&#123; mixins: [PureRenderMixin], render: function() &#123; return &lt;div className=&#123;this.props.className&#125;&gt;foo&lt;/div&gt;; &#125;&#125;); 但由于官方不打算在 ES6+ 中继续推行 Mixins，若还是希望使用，可以参考看看第三方套件或是这个文件的用法。 10. Default Parameters以前 ES5 我们函数要使用预设值需要这样使用： 1234var link = function (height, color) &#123; var height = height || 50; var color = color || 'red'; &#125; 现在 ES6+ 的函数可以支援预设值，让程式码更为简洁： 123var link = function(height = 50, color = 'red') &#123; ... &#125;","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"React","slug":"React","permalink":"http://wiki.haoqiao.me/tags/React/"},{"name":"表","slug":"表","permalink":"http://wiki.haoqiao.me/tags/表/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"框架","slug":"前端/框架","permalink":"http://wiki.haoqiao.me/categories/前端/框架/"},{"name":"React","slug":"前端/框架/React","permalink":"http://wiki.haoqiao.me/categories/前端/框架/React/"}]},{"title":"深入理解React技术栈","date":"2017-07-23T06:30:41.000Z","path":"wiki/前端/框架/React/深入理解React技术栈/","text":"组件间通信父组件向子组件Props 子组件向父组件 利用回调函数 利用this.props.onChange 利用自定义事件机制 跨组件通信方式利用context -&gt; 利用redux","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"React","slug":"React","permalink":"http://wiki.haoqiao.me/tags/React/"},{"name":"技术栈","slug":"技术栈","permalink":"http://wiki.haoqiao.me/tags/技术栈/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"框架","slug":"前端/框架","permalink":"http://wiki.haoqiao.me/categories/前端/框架/"},{"name":"React","slug":"前端/框架/React","permalink":"http://wiki.haoqiao.me/categories/前端/框架/React/"}]},{"title":"this","date":"2017-07-13T04:51:28.000Z","path":"wiki/前端/基础/Ecmascript/this/","text":"前置 this总是指向函数的直接调用者（而非间接调用者） this在运行时绑定，上下文取决于函数调用时各种条件，和函数声明的位置没关系，只取决于函数的调用方式 绑定规则隐式绑定,对象属性引用链中只有最后一层在调用位置起作用 123456function foo() &#123; console.log(this.a) &#125;var obj2 = &#123; a: 42, foo: foo &#125;var obj1 = &#123; a: 2, obj2: obj2 &#125;var obj3 = &#123; a: 233, foo: foo &#125;obj3.foo() //2333 obj1.obj2.foo() //42 隐式丢失 1234567function foo() &#123; console.log(this.a) &#125;function doFoo(fn) &#123; fn() &#125;var obj3 = &#123; a: 233, foo: foo &#125;var a = &quot;windows&quot;doFoo(obj3.foo) // windows obj3.foo() //233 显示绑定 call apply new 绑定创建一个新对象新对象被执行[prototype]链接 新对象会绑定到函数调用的this返回这个新对象 优先级从高到低：new,显示,隐式,默认 *在全局运行上下文中（在任何函数体外部），this指代全局对象 console.log(this===window);// true call与apply,bind的区别 call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向 call, apply方法区别是,从第二个参数起, call方法参数将依次传递给借用的方法作参数, 而apply直接将这些参数放到一个数组中再传递, 最后借用方法的参数列表是一样的. 在知道调用函数的参数数量时，使用 call() 的性能会优于 apply()。 主要在实现的过程中 apply() 需要完成额外的操作（判断第二个参数类数组的长度，etc.）更严谨的说法是，当有this指向或者执行参数时，call的性能要明显优于apply。 bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this. 传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数 123456var foo = &#123; bar: 1, eventBind: function() &#123; $(&apos;.someClass&apos;).on(&apos;click&apos;, function(event) &#123; console.log(this.bar); &#125;.bind(this)); &#125; &#125; bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 12345678910var obj = &#123; x: 81, &#125;;var foo = &#123; getX: function() &#123; return this.x; &#125;&#125;console.log(foo.getX.bind(obj)()); //81console.log(foo.getX.call(obj)); //81 console.log(foo.getX.apply(obj)); //81 实现BIND函数 基本原理就是使用 apply() 与闭包，返回包含 apply() 的闭包使得 apply() 绑定指定作用域，但并未执行。 1234567Function.prototype.bind = Function.prototype.bind || function (context) &#123; var self = this; return function () &#123; return self.apply(context, arguments); &#125;&#125;","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"this","slug":"this","permalink":"http://wiki.haoqiao.me/tags/this/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"闭包","date":"2017-07-13T04:51:28.000Z","path":"wiki/前端/基础/Ecmascript/闭包/","text":"作用域ES5中JS没有块作用域，只有函数作用域 函数作用域的含义是指，属于这个函数内部全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用。)在任意代码片段外部添加包装函数，可以将内部的变量和函数定义”隐藏起来”,外部作用域无法访问包装函数内部的任何内容 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的 每一段javascript代码(全局代码或函数)都有一个与之关联的作用域链，这个作用域链是一个对象列表或者链条，这组对象定义了这段代码作用域中的变量。对一个对象查找x的属性，如果没有继续在作用域链里的列表里一个个找，如果没找到抛出一个引用错误异常 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找， 直至全局函数，这种组织形式就是作用域链。 javascript只有函数作用域，它的含义是属于函数内部全部变量都可以在整个函数的范围内使用及复用。 每一段javascript代码(全局代码或函数)都有一个与之关联的作用域链，这个作用域链是一个对象列表或者链条，它不仅包含当前作用域还包含上层作用域，这组对象定义了这段代码作用域中的变量。对一个对象查找x的属性，如果没有继续在作用域链里的列表里一个个找，如果没找到抛出一个引用错误异常 作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 前置知识闭包是指有权访问函数作用域的变量的函数 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时产生了闭包。 javascript的函数可以嵌套在其他函数中定义，它们可以通过访问它们被定义时所处的作用域中的任何变量。这就构成了闭包。 javascript用作用域链来实现闭包,作用域链由执行环境维护 当一个函数执行后，通常会被垃圾回收器将内部作用域销毁。但是该内部中函数引用产生的闭包阻止了回收，使得该作用域一直存活，供内部函数随时引用 创建闭包的方式，就是在一个函数内部创建另一个函数 利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部 只要使用了回调函数，就是在使用闭包 特性 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 循环和闭包在循环中尽管函数在各个迭代中被定义，但是它们被封闭在一个共享的全局作用域中。因此共享一个变量I 123456for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i) &#125;, i * 1000)&#125; // 每隔一秒输出五次6 直接用立即表达式包装创建作用域 是不够的1234567for (var i = 1; i &lt;= 5; i++) &#123; (function() &#123; setTimeout(function timer() &#123; console.log(i) &#125;, i * 1000) &#125;)() &#125; // 每隔一秒输出五次6 在立即表达式中需要有自己的变量，来保存迭代中的值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455for (var i = 1; i &lt;= 5; i++) &#123; (function() &#123; var j = i setTimeout(function timer() &#123; console.log(j) &#125;, j * 1000) &#125;)() &#125;// 每隔一秒输出1,2,3,4,5 for (var i = 0; i &lt; 5; i++) &#123; (function(j) &#123; // j = i setTimeout(function() &#123; console.log(new Date, j); &#125;, 1000); &#125;)(i);&#125;// 0 1 2 3 4利用 JS 中基本类型（Primitive Type）的参数传递是按值传递（Pass by Value）的特征var output = function (i) &#123; setTimeout(function() &#123; console.log(new Date, i); &#125;, 1000);&#125;;for (var i = 0; i &lt; 5; i++) &#123; output(i); // 这里传过去的 i 值被复制了&#125;const tasks = []; // 这里存放异步操作的 Promiseconst output = (i) =&gt; new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, i); resolve(); &#125;, 1000 * i);&#125;);// 生成全部的异步操作for (var i = 0; i &lt; 5; i++) &#123; tasks.push(output(i));&#125;// 异步操作完成之后，输出最后的 iPromise.all(tasks).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, i); &#125;, 1000);&#125;); 作用封装！设计私有的方法和变量全局变量可能会造成命名冲突，使用闭包不用担心这个问题，因为它是私有化，加强了封装性，这样保护变量的安全 实现模块模式123456789101112function foo() &#123; var a = 2 function bar() &#123; console.log(a) &#125; function something() &#123; console.log(\"2333\") &#125; return &#123; bar: bar, something: something &#125; &#125; var baz = foo() baz.something() //2333 缺点与应用由于它是驻留在内存中，会增大内存使用量，使用不当很容易造成内存泄露，降低程序的性能 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变 1234567891011121314151617181920function count() &#123; var arr = []; for (var i = 1; i &lt;= 3; i++) &#123; arr.push((function(n) &#123; return function() &#123; return n * n; &#125; &#125;)(i)); &#125; return arr; &#125; var results = count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2]; f1(); // 1 f2(); // 4 f3(); // 9 手写once函数，传入函数参数只执行一次（闭包）1234567891011121314var singleton = (function() &#123; //缓存实例 var instance; var randomNum = Math.random(); //单例初始化代码 function init() &#123; //如果没有初始化，则初始化，否则返回已经执行的结果。 return randomNum; &#125; if (!instance) &#123; instance = init(); &#125; return instance;&#125;)()console.log(singleton);console.log(singleton);","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"闭包","slug":"闭包","permalink":"http://wiki.haoqiao.me/tags/闭包/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"ES6","date":"2017-07-13T04:51:28.000Z","path":"wiki/前端/基础/Ecmascript/ES6/","text":"Iterator 它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费 Iterator的遍历过程是这样的。 （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。 1234567891011121314151617var it = makeIterator(['a', 'b']); it.next() // &#123; value: \"a\", done: false &#125; it.next() // &#123; value: \"b\", done: false &#125; it.next() // &#123; value: undefined, done: true &#125; function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;; &#125; letlet可以将变量绑定到所在的任意作用域{…}中,它为声明的变量隐式劫持了所在的块作用域，也就是花括号中的块，每进入一次花括号就生成了一个块级域 let 的暂存死区与错误 重复Let定义同一个变量会抛出错误 在let定义之前引用会抛出引用错误let的作用域是块，而var的作用域是函数 *TDZ (暂时性死区)。指代码中的变量还没有初始化而不能被引用的情况。 * { a = 2; ERROR let a; } 原理：var 会变量提升，let 不会。 12345678910111213141516171819function varTest() &#123; var x = 1; if (true) &#123; var x = 2; // 同样的变量! console.log(x); // 2 &#125; console.log(x); // 2 &#125; function letTest() &#123; let x = 1; if (true) &#123; let x = 2; // 不同的变量 console.log(x); // 2 &#125; console.log(x); // 1 &#125; 箭头函数 用于将函数内部的this延伸到上一层作用域中。即上一次的上下文会穿透到内层。 箭头对上下文的绑定是强制的，无法通过apply或call方法改变。 使用了块语句的箭头函数不会自动返回值，你需要使用 return 语句将所需值返回 symbolSymbol 是JavaScript ES6 的原始数据类型 它能避免命名冲突的风险 调用Symbol()创建一个新的symbol，它的值与其它任何值皆不相等 JavaScript中最常见的对象检查的特性会忽略symbol键。例如，for-in循环只会遍历对象的字符串键，symbol键直接跳过，Object.keys(obj)和Object.getOwnPropertyNames(obj)也是一样。但是symbols也不完全是私有的：用新的APIObject.getOwnPropertySymbols(obj)就可以列出对象的symbol键。另一个新的API，Reflect.ownKeys(obj)，会同时返回字符串键和symbol键 for of for-of 循环语句通过方法调用来遍历各种 集合。数组、Maps 对象、Sets 对象 不会遍历自定义属性，不会遍历普通对象 可以正确响应 break、continue 和 return 语句 支持类数组遍历, 支持字符串字符遍历 generators Generator 函数是一个状态机，封装了多个内部状态，执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态 两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态（yield在英语里的意思就是“产出”） promisePromise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。 只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的 Promise新建后就会立即执行 Promise是一个对象，充当异步操作和回调函数之间的中介。 * var promise = new Promise(function(resolve, reject) { // 异步操作的代码 if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } }); 每一个异步函数立刻返回一个Promise对象，每个对象指定回调函数，在异步任务完成后调用。 Promise有三种状态:pending 未完成,resolved 已完成,rejected 失败。最终状态只有成功和失败。通过then方法添加两个回调函数处理resolved状态和rejected状态，一旦状态改变就调用。 po.then(function(value) { // success}, function(value) { // failure}); 优点在于流程清晰，让回调函数变成规范链式写法，可以为多个异步操作指定同一个回调，可以为多个回调指定同一个错误处理方法。如果一个任务已经完成，再往上添加回调，会立刻执行。无须担心错过某个事件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125; &#125;); promise.then(function(value) &#123; // success &#125;, function(error) &#123; // failure &#125;); function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;); &#125; timeout(100).then((value) =&gt; &#123; console.log(value); &#125;);* Promise对象实现的Ajax操作 * var getJSON = function(url) &#123; var promise = new Promise(function(resolve, reject)&#123; var client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); function handler() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; &#125;); return promise; &#125;; getJSON(\"/posts.json\").then(function(json) &#123; console.log('Contents: ' + json); &#125;, function(error) &#123; console.error('出错了', error); &#125;); * 用法 * 加载图片 * var preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;); &#125;; * Ajax * function search(term) &#123; var url = 'http://example.com/search?q=' + term; var xhr = new XMLHttpRequest(); var result; var p = new Promise(function (resolve, reject) &#123; xhr.open('GET', url, true); xhr.onload = function (e) &#123; if (this.status === 200) &#123; result = JSON.parse(this.responseText); resolve(result); &#125; &#125;; xhr.onerror = function (e) &#123; reject(e); &#125;; xhr.send(); &#125;); return p; &#125; search(\"Hello World\").then(console.log, console.error); 模板字符串 模板字符串中嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性还能调用函数 1234567891011121314151617181920var x = 1; var y = 2; `$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;` // &quot;1 + 2 = 3&quot; `$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;` // &quot;1 + 4 = 5&quot; var obj = &#123;x: 1, y: 2&#125;; `$&#123;obj.x + obj.y&#125;` // 3 function fn() &#123; return &quot;Hello World&quot;; &#125; `foo $&#123;fn()&#125; bar` // foo Hello World bar 标签1234567891011121314151617var a = 5; var b = 10; function tag(strings, ...values) &#123; console.log(strings[0]); // \"Hello \" console.log(strings[1]); // \" world \" console.log(strings[2]); // \"\" console.log(values[0]); // 15 console.log(values[1]); // 50 return \"Bazinga!\"; &#125; tag`Hello $&#123; a + b &#125; world $&#123; a * b&#125;`; // \"Bazinga!\" Array.from() Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。 Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组 1234567891011121314 * Array.from(arrayLike,x =&gt;x *x);// 等同于 Array.from(arrayLike).map(x =&gt;x *x); Array.from([1,2,3],(x)=&gt;x *x)// [1, 4, 9]* let arrayLike =&#123;'0':'a','1':'b','2':'c',length:3&#125;;// ES5的写法 var arr1 =[].slice.call(arrayLike);// ['a', 'b', 'c'] // ES6的写法 let arr2 =Array.from(arrayLike);// ['a', 'b', 'c']* 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组* 如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组,而且这两个数组不会引用同一份数据。a != b Array.of() Array.of方法用于将一组值，转换为数组 12345678910Array.of(3,11,8)// [3,11,8] Array.of(3)// [3] Array.of(3).length// 1 function ArrayOf()&#123; return [].slice.call(arguments); &#125; 数组实例的find()和findIndex() find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到 1234567* [NaN].indexOf(NaN) // -1 [NaN].findIndex(y =&gt; Object.is(NaN, y)) // 0 entries()，keys()和values() keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历 12345678910111213141516171819* for (let index of ['a', 'b'].keys()) &#123; console.log(index); &#125; // 0 // 1 for (let elem of ['a', 'b'].values()) &#123; console.log(elem); &#125; // 'a' // 'b' for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem); &#125; // 0 \"a\" // 1 \"b\" rest参数 用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中 123456789101112131415161718* // arguments变量的写法 function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort(); &#125; // rest参数的写法 const sortNumbers = (...numbers) =&gt; numbers.sort();* function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;); &#125; var a = []; push(a, 1, 2, 3) 扩展运算符(…) rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，用于展开数组。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 * function push(array, ...items) &#123; array.push(...items); &#125; function add(x, y) &#123; return x + y; &#125; var numbers = [4, 38]; add(...numbers) // 42* 替代数组的apply方法 * // ES5的写法 function f(x, y, z) &#123; // ... &#125; var args = [0, 1, 2]; f.apply(null, args); // ES6的写法 function f(x, y, z) &#123; // ... &#125; var args = [0, 1, 2]; f(...args); * // ES5的写法 Math.max.apply(null, [14, 3, 77]) // ES6的写法 Math.max(...[14, 3, 77]) // 等同于 Math.max(14, 3, 77); * // ES5的写法 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; Array.prototype.push.apply(arr1, arr2); // ES6的写法 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; arr1.push(...arr2);* 合并数组 * // ES5 [1, 2].concat(more) // ES6 [1, 2, ...more] var arr1 = ['a', 'b']; var arr2 = ['c']; var arr3 = ['d', 'e']; // ES5的合并数组 arr1.concat(arr2, arr3); // [ 'a', 'b', 'c', 'd', 'e' ] // ES6的合并数组 [...arr1, ...arr2, ...arr3] // [ 'a', 'b', 'c', 'd', 'e' ] name 属性函数的name属性，返回该函数的函数名。 12function foo()&#123;&#125;foo.name// &quot;foo&quot; Object.is() 它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致 12345* Object.is(&apos;foo&apos;, &apos;foo&apos;) // true Object.is(&#123;&#125;, &#123;&#125;) // false Object.assign() 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性 Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 123456789* var target = &#123; a: 1 &#125;; var source1 = &#123; b: 2 &#125;; var source2 = &#123; c: 3 &#125;; Object.assign(target, source1, source2); target // &#123;a:1, b:2, c:3&#125; 属性遍历 for…in for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性） Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性） Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性） Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性 Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举 proto属性 用来读取或设置当前对象的prototype对象 proto前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署 proto调用的是Object.prototype.proto Object.setPrototypeOf() Object.setPrototypeOf方法的作用与proto相同，用来设置一个对象的prototype对象，返回参数对象本身 1234567891011* let proto = &#123;&#125;; let obj = &#123; x: 10 &#125;; Object.setPrototypeOf(obj, proto); proto.y = 20; proto.z = 40; obj.x // 10 obj.y // 20 obj.z // 40 Object.getPrototypeOf()用于读取一个对象的原型对象 解构赋值 解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种 变量 [ variable1, variable2, …, variableN ] = array; 解构赋值允许指定默认值 12let[x,y =&apos;b&apos;]=[&apos;a&apos;] // x=&apos;a&apos;, y=&apos;b&apos;let[x,y =&apos;b&apos;] = [&apos;a&apos;,undefined];// x=&apos;a&apos;, y=&apos;b&apos; 对象的结构赋值 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者 123456789101112131415* var [foo, [[bar], baz]] = [1, [[2], 3]]; console.log(foo); // 1 console.log(bar); // 2 console.log(baz); // 3* var [,,third] = [\"foo\", \"bar\", \"baz\"]; console.log(third); // \"baz\"* var [head, ...tail] = [1, 2, 3, 4]; console.log(tail); // [2, 3, 4] Set 和 MapES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 方法 add(value)：添加某个值，返回Set结构本身 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值 遍历 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 123456789101112131415161718192021222324252627282930* const s = new Set(); [2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x)); for (let i of s) &#123; console.log(i); &#125; // 2 3 5 4 // 例一 var set = new Set([1, 2, 3, 4, 4]); [...set] // [1, 2, 3, 4] // 例二 var items = new Set([1, 2, 3, 4, 5, 5, 5, 5]); items.size // 5 // 例三 function divs () &#123; return [...document.querySelectorAll('div')]; &#125; var set = new Set(divs()); set.size // 56 // 类似于 divs().forEach(div =&gt; set.add(div)); set.size // 56 ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构 12345678910111213141516171819202122* var m = new Map(); var o = &#123;p: 'Hello World'&#125;; m.set(o, 'content') m.get(o) // \"content\" m.has(o) // true m.delete(o) // true m.has(o) // false var map = new Map([ ['name', '张三'], ['title', 'Author'] ]); map.size // 2 map.has('name') // true map.get('name') // \"张三\" map.has('title') // true map.get('title') // \"Author\"","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://wiki.haoqiao.me/tags/ES6/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"类与对象","date":"2017-07-13T04:51:28.000Z","path":"wiki/前端/基础/Ecmascript/类与对象/","text":"类的实现基于其原型继承机制构造函数法它用构造函数模拟 “类”，在其内部用this关键字指代实例对象。 function Cat(){this.name = “大毛”;} 生成实例的时候， 使用new关键字。 var cat1 = new Cat(); alert(cat1.name); // 大毛缺点: 就是每创建一个实例， 都会实例化该类的每个函数 工厂方法缺点： 就是每创建一个实例， 都会实例化该类的每个函数 12345678910function createCoderFactory() &#123; var obj = new Object(); obj.name = &apos;现代魔法&apos;; obj.job = &apos;程序员&apos;; obj.coding = function() &#123; alert(&apos;我正在写代码&apos;); &#125;; return obj; &#125;var coder = createCoderFactory();alert(coder.name);coder.coding(); 原型方式1234567891011121314function Car() &#123;&#125;Car.prototype.color = \"red\";Car.prototype.doors = 4;Car.prototype.mpg = 25;Car.prototype.showColor = function() &#123; document.write(this.color); &#125;;var oCar1 = new Car();var oCar2 = new Car();缺点: 不能通过给构造函数传递参数来初始化属性的值, 内部数据修改其它实例也会修改Object.create() 法var cat1 = Object.create(Cat);缺点： 不能实现私有属性和私有方法， 实例对象之间也不能共享数据， 对 \"类\"的模拟不够全面 创建对象的几种方式对象字面量的方式缺点： 使用同一个接口创建很多对象， 会产生大量重复代码。 person = { firstname: &quot;Mark&quot;, lastname: &quot;Yun&quot;, age: 25, eyecolor: &quot;black&quot; }; 工厂方式来创建（ 内置对象）缺点: 每个方法都要在每个实例上重新创造一遍。 123456789101112function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125; return o; &#125;var person1 = createPerson(\"Nicholas\", 29, \"software Engineer\");var person2 = createPerson(\"Greg\", 27, \"Doctor\");person1.sayName(); //\"Nicholas\" person2.sayName(); //“Greg\" 用原型方式来创建缺点: 一旦一个继承对象修改了其中变量，所有继承都会改变 1234567function Dog() &#123;&#125;Dog.prototype.name = \"旺财\";Dog.prototype.eat = function() &#123; alert(this.name + \"是个吃货\"); &#125;var wangcai = new Dog();wangcai.eat(); 构造函数模式缺点: 每个方法都要在每个实例上重新创造一遍。 12345678function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125; &#125;var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);person1.sayName(); //&quot;Nicholas&quot; person2.sayName(); //&quot;Greg&quot; 构造函数和原型模式组合实例共享的属性方法在原型中定义， 其它私有属性不共享 123456function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; &#125;Person.prototype = &#123; constructor: Person, sayName = function() &#123; alert(this.name); &#125; &#125;","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"类与对象","slug":"类与对象","permalink":"http://wiki.haoqiao.me/tags/类与对象/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"PolyFill","date":"2017-07-13T04:51:28.000Z","path":"wiki/前端/基础/Ecmascript/PolyFill/","text":"requestAnimationFrame polyfill1234567891011121314151617181920212223242526(function() &#123; var lastTime = 0; var vendors = ['ms', 'moz', 'webkit', 'o']; for(var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) &#123; window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame']; &#125; if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) &#123; var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function() &#123; callback(currTime + timeToCall); &#125;, timeToCall); lastTime = currTime + timeToCall; return id; &#125;; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) &#123; clearTimeout(id); &#125;;&#125;()); Object.create()123456789101112131415161718192021222324252627282930313233343536373839404142434445if (typeof Object.create != 'function') &#123; // Production steps of ECMA-262, Edition 5, 15.2.3.5 // Reference: http://es5.github.io/#x15.2.3.5 Object.create = (function() &#123; //为了节省内存，使用一个共享的构造器 function Temp() &#123;&#125; // 使用 Object.prototype.hasOwnProperty 更安全的引用 var hasOwn = Object.prototype.hasOwnProperty; return function (O) &#123; // 1. 如果 O 不是 Object 或 null，抛出一个 TypeError 异常。 if (typeof O != 'object') &#123; throw TypeError('Object prototype may only be an Object or null'); &#125; // 2. 使创建的一个新的对象为 obj ，就和通过 // new Object() 表达式创建一个新对象一样， // Object是标准内置的构造器名 // 3. 设置 obj 的内部属性 [[Prototype]] 为 O。 Temp.prototype = O; var obj = new Temp(); Temp.prototype = null; // 不要保持一个 O 的杂散引用（a stray reference）... // 4. 如果存在参数 Properties ，而不是 undefined ， // 那么就把参数的自身属性添加到 obj 上，就像调用 // 携带obj ，Properties两个参数的标准内置函数 // Object.defineProperties() 一样。 if (arguments.length &gt; 1) &#123; // Object.defineProperties does ToObject on its first argument. var Properties = Object(arguments[1]); for (var prop in Properties) &#123; if (hasOwn.call(Properties, prop)) &#123; obj[prop] = Properties[prop]; &#125; &#125; &#125; // 5. 返回 obj return obj; &#125;; &#125;)();&#125; Bind()1234567891011121314151617181920Function.prototype.bind = function() &#123;var self = this;// 需要绑定的this上下文var context = [].shift.call(arguments);// 剩余的参数转成数组var args = [].slice.call(arguments);return function() &#123;return self.apply(context, [].concat.call(args, [].slice.call(arguments)));&#125;&#125;var obj = &#123;name: 'microzz'&#125;;var func = function(a, b, c, d) &#123;console.log(this.name); // microzzconsole.log([a, b, c, d]); // [1, 2, 3, 4]&#125;.bind(obj, 1, 2);func(3, 4);","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"PolyFill","slug":"PolyFill","permalink":"http://wiki.haoqiao.me/tags/PolyFill/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"浏览器-性能-安全","date":"2017-07-13T04:51:28.000Z","path":"wiki/前端/基础/Ecmascript/浏览器-性能-安全/","text":"安全XSS 跨站脚本攻击是一种针对网站应用程序的安全漏洞攻击，是代码注入的一种，类似于SQL注入。XSS漏洞的存在允许作为站点合法用户将代码注入到网页上，接着浏览器渲染页面时会试行一些不被预期的脚本指令，使用该网页的用户就会受到不良影响甚至严重危害 防范xss的关键是过滤所有的‘《’和‘》’字符，确保从后端而来的数据并不带有任何的html标签，xss的危险在于有不可预料的前端脚本 CSRF跨站请求伪造是一种对信任网站的恶意利用，通过伪装来自受信任用户的请求来利用信任网站进行某种用户不知道的、甚至有害的操作 在HTTP请求中加入随机数，无法正常伪造请求 https为什么更安全https = http和SSL/TLS组队 SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。（1）如何保证公钥不被篡改？解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。（2）公钥加密计算量太大，如何减少耗用的时间？解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。因此，SSL/TLS协议的基本过程是这样的：（1） 客户端向服务器端索要并验证公钥。（2） 双方协商生成”对话密钥”。（3） 双方采用”对话密钥”进行加密通信。 SSL/TLS提供了身份验证、加密和签名等安全措施来保护用户和服务器之间的数据传输 https是用来加密网络上传输的数据，不对数据内容做验证 请描述一下 GET 和 POST 的区别 get 向指定的资源请求数据,请求的数据会附在URL 之后,就是把数据放置在请求行（request line）中），以?分割URL和传输数据，多个参数用&amp;连接； get 请求是安全,get 操作不会修改服务器的数据 get 请求发送数据更小 get 能被缓存，post 不能被缓存 post 向指定的资源提交要被处理的数据。get 方法，查询请求是在url中显示的，有长度限制，get 方法是安全幂等的。而post 方法请求是封装在http 消息包体中 cookie 和 session 的区别 cookie 和session的区别是：cookie数据保存在客户端，session数据保存在服务器端。cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式。cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。不重要的信息以cookie形式存放，重要的token以session方式存放 性能回流和重绘 repain(重绘)当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain 减少重绘 合适的网页分层技术以减少需要重新计算的布局和绘图使用css 3d变形和动画技术 reflow(回流)DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow 减少回流、重绘其实就是需要减少对render tree的操作（合并多次多DOM和样式的修改），并减少对一些style信息的请求，尽量利用好浏览器的优化策略 display:none和visibility：hidden会产生回流与重绘吗？ display：none指的是元素完全不陈列出来，不占据空间，涉及到了DOM结构，故产生reflow与repaint visibility：hidden指的是元素不可见但存在，保留空间，不影响结构，故只产生repaint 浏览器缓存,HTTP缓存控制 整体缓存策略 1.先看看有没有设置expires,Cache-control 2.对比缓存时间，如果过期了 3.对比上次响应的Etag和本次请求的，如果没变读取缓存，变了更新 4.Last-Modified 对比文件最后修改日期，如果没变，读取缓存，变了更新 对于浏览器端的缓存来讲，这些规则是在HTTP协议头和HTML页面的Meta标签中定义的。他们分别从新鲜度和校验值两个维度来规定浏览器是否可以直接使用缓存中的副本，还是需要去源服务器获取更新的版本 HTTP Cache-control策略 指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据 Cache-Control的max-age规定了缓存有效时间（2552s） 如果max-age和Expires同时存在，前者优先级高于后者 ETag/If-None-Match 当客户端发现和服务器约定的直接读取缓存的时间过了，就在请求中发送If-None-Match选项，值即为上次请求后响应头的ETag值，该值在服务端和服务端代表该文件唯一的字符串对比（如果服务端该文件改变了，该值就会变），如果相同，则相应HTTP304，客户端直接读取缓存，如果不相同，HTTP200，下载正确的数据，更新ETag值 如果两者同时存在，If-None-Match优先，忽略If-Modified-Since Last-Modified/If-Modified-Since 将If-Modified-Since的日期和服务端该文件的最后修改日期对比，如果相同，则响应HTTP304，从缓存读数据；如果不相同文件更新了，HTTP200，返回数据，同时通过响应头更新last-Modified的值（以备下次对比） 新鲜度（过期机制）：也就是缓存副本有效期。一个缓存副本必须满足以下条件，浏览器会认为它是有效的，足够新的： 含有完整的过期时间控制头信息（HTTP协议报头），并且仍在有效期内；浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度 Expires策略 Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 Expires规定了缓存失效时间 浏览器可以并行下载多少个资源 IE6 2 个并发 iE7 升级之后的 6 个并发，之后版本也是 6 个 Firefox，chrome 也是6个 性能优化的具体思路 减少请求 减小传输体积 尽可能利用缓存 缩短关键路径 合理安排请求顺序 css等静态文件放在其他域名下的好处比如图片CSS等静态文件放在静态资源服务器上并配置单独域名，客户端请求静态文件的时候，减少COOKIE反复传输时对主域名的影响。 前端性能优化的方法（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 避免链接重定向、避免错误的链接请求。建立多次链接、多次 DNS 解析，阻碍 DNS 预取技术。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 CDN加速的原理 CDN加速将网站的内容缓存在网络边缘（离用户接入网络最近的地方），然后在用户访问网站内容的时候，通过调度系统将用户的请求路由或者引导到离用户接入网络最近或者访问效果最佳的缓存服务器上，有该缓存服务器为用户提供内容服务；相对于直接访问源站，这种方式缩短了用户和内容之间的网络距离，从而达到加速的效果 如何优化Cookie 减小大小 去除不必要的 Cookie；尽量压缩 Cookie 大小；注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；设置合适的过期时间。 静态资源使用无 Cookie 域名 把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度 域名收敛域名收敛的意思就是建议将静态资源只放在一个域名下面，而非发散情况下的多个域名下。 DNS 解析其实是一个很复杂的过程，在 PC 上，我们采用域名发散策略，是因为在 PC 端上，DNS 解析通常而言只需要几十 ms ，可以接受。而移动端，2G 网络，3G网络，4G网络/wifi 强网，而且移动 4G 容易在信号不理想的地段降级成 2G ，通过大量的数据采集和真实网络抓包分析（存在DNS解析的请求），DNS的消耗相当可观 在移动网络环境下，减少非必要 DNS 请求，将相关域名收敛成一个，可以尝到缓存的红利，进而可以减少打开页面时间移动端减少 DNS 解析时间有两种方式： 减少 DNS 请求 缩短 DNS 解析路径 从上面的各种网络环境下 DNS 解析时间对比，减少 DNS 请求是我们做域名收敛的主要原因 白屏时间计算白屏时间是用户首次看到内容的时间，也叫做首次渲染时间，chrome 高版本有 firstPaintTime 接口来获取这个耗时，但大部分浏览器并不支持 白屏时间出现在头部外链资源加载完附近，因为浏览器只有加载并解析完头部资源才会真正渲染页面。基于此我们可以通过获取头部资源加载完的时刻来近似统计白屏时间。尽管并不精确，但却考虑了影响白屏的主要因素： 首字节时间和头部资源加载时间。 目前普遍使用的白屏时间统计方案是在html文档的head中所有的静态资源以及内嵌脚本/样式之前记录一个时间点，在head最底部记录另一个时间点，两者的差值作为白屏时间 123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"/&gt;&lt;!--这里还有一大串meta信息--&gt;&lt;script&gt;var start_time = new Date();//统计起点，实际为html开始解析的时间节点&lt;/script&gt;&lt;link href='a.css'&gt;&lt;/link&gt;&lt;script src='a.js'&gt;&lt;/script&gt;&lt;script&gt;var end_time = new Date();//统计起点，实际为html开始解析的时间节点&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 首屏时间计算多久首屏渲染完成(包含图片等元素加载完成)。 在每个点打上一个时间戳，首屏时间 = 点8 – 点1； 首屏线处埋点标记，然后计算标记点之前所有图片加载完成的时间，把这个时间作为首屏时间 通过统计首屏内图片的加载时间便可以获取首屏渲染完成的时间。统计流程如下： 首屏位置调用 API 开始统计 -&gt; 绑定首屏内所有图片的 load 事件 -&gt; 页面加载完后判断图片是否在首屏内，找出加载最慢的一张 -&gt; 首屏时间 目前应用比较广的方案是将首屏的图片、iframe等资源添加onload事件，获取最慢的一个。 这种方案比较适合首屏元素数量固定的页面，比如移动端首屏不论屏幕大小都展示相同数量的内容，响应式得改变内容的字体、尺寸等。但是对于首屏元素不固定的页面，这种方案并不适用，最典型的就是PC端页面，不同屏幕尺寸下展示的首屏内容不同。上述方案便不适用于此场景。","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"浏览器-性能-安全","slug":"浏览器-性能-安全","permalink":"http://wiki.haoqiao.me/tags/浏览器-性能-安全/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"正则","date":"2017-07-13T04:51:28.000Z","path":"wiki/前端/基础/Ecmascript/正则/","text":"var exp = /pattern/flagsflagsg:全局模式，应用于所有字符串，不会匹配到第一个就停，一直匹配到结束 i:不区分大小写模式 m:多行模式，到达一行文本末尾还需继续查找下一行 元字符: ( [ { \\ ^ $ | ) ? * + . ] }都需要转义匹配 特殊字符\\12345非特殊字符之前的反斜杠表示下一个字符是特殊模式 /a*/ 代表会匹配 0 个或者多个 a。相反，模式 /a\\*/ 将 &apos;*&apos; 的特殊性移除，从而可以匹配像 &quot;a*&quot; 这样的字符 ^匹配输入的开始 /^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’ $匹配输入的结束 /t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’ *匹配前一个表达式0次或多次。等价于 {0,} +匹配前面一个表达式1次或者多次。等价于 {1,}。 例如，/a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’。 ?1234567 匹配前面一个表达式0次或者1次。等价于 &#123;0,1&#125;。例如，/e?le?/ 匹配 &quot;angel&quot; 中的 &apos;el&apos;，和 &quot;angle&quot; 中的 &apos;le&apos; 以及&quot;oslo&apos; 中的&apos;l&apos;。如果紧跟在任何量词 *、 +、? 或 &#123;&#125; 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。 对 &quot;123abc&quot; 应用 /\\d+/ 将会返回 &quot;123&quot;，如果使用 /\\d+?/,那么就只会匹配到 &quot;1&quot;。 小数点 .匹配除换行符之外的任何单个字符 (x)1234匹配 &apos;x&apos; 并且记住匹配项，就像下面的例子展示的那样。括号被称为 捕获括号模式 /(foo) (bar) \\1 \\2/ 中的 &apos;(foo)&apos; 和 &apos;(bar)&apos; 匹配并记住字符串 &quot;foo bar foo bar&quot; 中前两个单词。模式中的 \\1 和 \\2 匹配字符串的后两个单词。注意 \\1、\\2、\\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，&apos;bar foo&apos;.replace( /(...) (...)/, &apos;$2 $1&apos; ) {n}n是一个正整数，匹配了前面一个字符刚好发生了n次。 比如，/a{2}/不会匹配“candy”中的’a’,但是会匹配“caandy”中所有的a，以及“caaandy”中的前两个’a’ {n,m}n 和 m 都是正整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。 例如，/a{1, 3}/ 并不匹配“cndy”中得任意字符，匹配“candy”中得a，匹配“caandy”中得前两个a，也匹配“caaaaaaandy”中得前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。 (?:x)匹配 ‘x’ 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式。 来看示例表达式 /(?:foo){1,2}/。 如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。 如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。 x(?=y)匹配’x’仅仅当’x’后面跟着’y’.这种叫做正向肯定查找。 例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。 x(?!y)匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。 /\\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!.)/.exec(“3.141”)匹配‘141’但是不是‘3.141’ x|y 匹配‘x’或者‘y’。 [xyz]一个字符集合。匹配方括号的中任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的 [abcd] 和[a-d]是一样的。他们都匹配”brisket”中得‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\\w.]+/都匹配“test.i.ng”中得所有字符 [^xyz]一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的 [^abc] 和 [^a-c] 是一样的。他们匹配”brisket”中得‘r’，也匹配“chop”中的‘h’。 \\b1234匹配一个词的边界。一个词的边界就是一个词不被另外一个词跟随的位置或者不是另一个词汇字符前边的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0（不要和[\\b]混淆了）例子： /\\bm/匹配“moon”中得‘m’； [\\b]匹配一个退格(U+0008)。（不要和\\b混淆了。） \\B匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是单词或者都不是单词。一个字符串的开始和结尾都被认为是非单词。 例如，/\\B../匹配”noonday”中得’oo’, 而/y\\B./匹配”possibly yesterday”中得’ye‘ \\d匹配一个数字。 等价于[0-9]。 /\\d/或者/[0-9]/匹配”B2 is the suite number.”中的’2’ \\D匹配一个非数字字符。 等价于[^0-9]。 /\\D/或者/[^0-9]/匹配”B2 is the suite number.”中的’B’ \\n匹配一个换行符 (U+000A) \\r匹配一个回车符 (U+000D) \\s匹配一个空白字符，包括空格、制表符、换页符和换行符。 \\S匹配一个非空白字符 \\W匹配一个非单字字符 方法exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null） test一个在字符串中测试是否匹配的RegExp方法，它返回true或false。 match 一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1 replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串 split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法 正则例子","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"正则","slug":"正则","permalink":"http://wiki.haoqiao.me/tags/正则/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"前端工程化","date":"2017-07-13T04:51:28.000Z","path":"wiki/前端/基础/Ecmascript/前端工程化/","text":"模块化模块化只是在语言层面上，对代码的拆分；而组件化是基于模块化，在设计层面上，对UI（用户界面）的拆分 编码规范 js使用eslint，目前采用 google 的 javascript style guide css使用相应的stylelint 使用editorconfig，统一编辑器或ide的一些设定，如js缩进为2空格 前后端接口规范采用 restful 风格，接口描述使用swagger 自动化docker自动化部署 持续化集成 gitlab/git hook 实现 hook jenkin/gitlab ci执行相应的构建脚本，并订阅构建结果","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://wiki.haoqiao.me/tags/前端工程化/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"原型","date":"2017-07-13T04:51:28.000Z","path":"wiki/前端/基础/Ecmascript/原型/","text":"原型只要创建了一个函数,就会根据一组规则为该函数创建一个prototype,prototype指向函数的原型对象。 prototype是函数才会有的属性 prototype用于当你用new关键词创建一个新的对象时,构建__proto__ 比如你创了一个 function xxx(){} 它的prototype就是Object,因为javascript中，所有引用类型默认都默认继承了Object,而这个继承是通过原型链实现的，所以，所有的函数的默认原型都是Object的实例 每个原型对象自动获得一个constructor(构造函数)属性，它包含指向prototype属性所在的指针。 比如Person.prototype.constructor指向Person当你创建了一个新对象并替换了函数默认的.prototype对象引用，那么新对象不会自动获得.constructor属性。需要手动指定 123456789101112131415161718function Foo()&#123; &#125; Foo.prototype = &#123; //... &#125; //创建一个新的原型对象 var a = new Foo() a.constructor === Foo // falsea.constructor === Object // true__proto__指向构造函数的prototype 所有对象都会从它的原型上继承一个 constructor 属性,用于引用原型对象(Function Object/Function,对象.contructor永远返回是个函数) xx.constructor // function Function() &#123; [native code] &#125; var f = &#123;&#125; 等价于 new Object() // f不是函数 所以它没有f.prototype // 但是f可以通过访问f.__proto__访问它原型 Object &#123;&#125; // f.constructor.prototype == Object &#123;&#125; function F()&#123;&#125; // prototype指向的，是以当前函数作为构造函数构造出来的对象的原型对象 // F是函数，它有prototype 为 Object &#123;&#125; var sf = new F()&#123;&#125; // sf.constructor === F // sf.__proto__ == F.prototype 当你创建了一个新对象并替换了函数默认的.prototype对象引用，那么新对象不会自动获得.constructor属性。需要手动指定。 方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。 proto 每个JS对象一定对应一个原型对象，并从原型对象继承属性和方法对象proto属性的值就是它所对应的原型对象 proto是一些浏览器提供的一个查看prototype的接口，也就是说prototype才是标准的原型、可用在代码中，而proto用于调试 proto是每个对象都有的一个属性，而prototype是函数才会有的属性 proto指向的是当前对象的原型对象，而prototype指向的，是以当前函数作为构造函数构造出来的对象的原型对象 .prototype是一个对象的原型对象，而.proto则是对原型对象的引用 123456__proto__ == constructor.prototype true__proto__指向自己构造函数的prototype。obj.__proto__.__proto__...的原型链由此产生，包括我们的操作符instanceof正是通过探测obj.__proto__.__proto__... === Constructor.prototype来验证obj是否是Constructor的实例 JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 原型链原型链并非十分完美, 它包含如下两个问题. 问题一: 当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享; 问题二: 在创建子类型(例如创建Son的实例)时,不能向超类型(例如Father)的构造函数中传递参数. 构造函数，通过prototype来存储要共享的属性和方法，也可以设置prototype指向现存的对象来继承该对象。 对象的proto指向自己构造函数的prototype 每一个构造函数都有一个prototype，指向一个对象，这个对象的所有属性和方法，都会被构造函数的实例继承。 原型链正是基于proto才得以形成(note：不是基于函数对象的属性prototype) 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype， 于是就这样一直找下去，也就是我们平时所说的原型链的概念。 关系：instance.constructor.prototype = instance.proto 原型链最终是—&gt; Object.prototype —&gt; null hasOwnProperty()检测一个属性是否存在于实例中还是存在于原型中。属性在对象实例中返回true hasPrototypeProperty()只有属性先存在原型中，不存在实例中才返回true","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"原型","slug":"原型","permalink":"http://wiki.haoqiao.me/tags/原型/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"继承","date":"2017-07-12T12:32:59.000Z","path":"wiki/前端/基础/Ecmascript/继承/","text":"类式继承12345678910function SuperClass() &#123; this.books = ['javascript', 'html'] &#125;function SubClass() &#123;&#125;SubClass.prototype = new SuperClass() var a1 = new SubClass() var a2 = new SubClass() console.log(a2.books) //[\"javascript\", \"html\"] a1.books.push('css’)console.log(a2.books)//[\"javascript\", \"html\", \"css”] 类式继承需要将第一个类的实例赋值给第二个类的原型 类的原型对象作用是为类的原型添加公共方法， 但类不能直接访问这些， 需要通过原型prototype访问， 实例化一个父类时， 新创建的对象复制了父类构造函数内的属性和方法， 并将原型proto指向了父类的原型对象， 就拥有了父类原型对象上的属性和方法。 将新创建的对象赋值给子类原型， 子类原型可以访问父类原型上的属性和方法与从父类构造函数中复制的属性和方法。 构造函数继承1234567891011121314151617function SuperClass(id) &#123; this.books = ['javascript', 'html'] this.id = id &#125;SuperClass.prototype.showBooks = function() &#123; console.log(this.books) &#125;function SubClass(id) &#123; SuperClass.call(this, id) &#125;var a1 = new SubClass(1)var a2 = new SubClass(2) a1.books.push('设计模式’) console.log(a1.books) //[\"javascript\", \"html\", \"设计模式”] console.log(a1.id) // 1 console.log(a2.books) //[\"javascript\", \"html”] console.log(a2.id)2 a1.showBooks() //VM413:22 Uncaught TypeError: a1.showBooks is not a function 组合继承子类构造函数中执行父类构造函数， 子类原型上实例化父类 1234567891011121314151617181920212223function SuperClass(name) &#123; this.books = ['javascript', 'html'] this.name = name &#125;SuperClass.prototype.getName = function() &#123; console.log(this.name) &#125;function SubClass(name, time) &#123; //构造函数式继承父类name属性 SuperClass.call(this, name) //子类添加公有属性 this.time = time&#125;////类式继承 SubClass.prototype = new SuperClass() //子类原型方法 SubClass.prototype.getTime = function() &#123; console.log(this.time) &#125;var a1 = new SubClass('test', 2016)a1.books.push('test')a1.getName() //test a1.getTime() //2016 var a2 = new SubClass('good', 2017)a2.books.push('best') //[\"javascript\", \"html\", \"best\"] console.log(a2.books) a2.getName() //gooda2.getTime() //2017 原型式继承1234567891011function inheritObject(o) &#123; function F() &#123;&#125; F.prototype = o return new F() &#125; var book = &#123; name: \"books\", allbooks: ['css', 'html'] &#125; var a1 = inheritObject(book) a1.allbooks.push('js’) var a2 = inheritObject(book) console.log(a2.allbooks) //[\"css\", \"html\", \"js\"] 原型继承与类继承的区别 首先，构造函数继承的方法都会存在父对象之中，每一次实例，都回将funciton保存在内存中，这样的做法毫无以为会带来性能上的问题。其次类式继承是不可变的。在运行时，无法修改或者添加新的方法，这种方式是一种固步自封的死方法。而原型继承是可以通过改变原型链接而对子类进行修改的。另外就是类式继承不支持多重继承，而对于原型继承来说，你只需要写好extend对对象进行扩展即可。 寄生式继承123456789101112function inheritObject(o) &#123; function F() &#123;&#125; F.prototype = o return new F() &#125; var book = &#123; name: \"books\", allbooks: ['css', 'html'] &#125; function createBook(obj) &#123; var o = new inheritObject(obj) o.getName = function() &#123; console.log(this.name) &#125; return o &#125; var a1 = createBook(book) a1.getName() //books 寄生组合式继承1234567891011121314151617181920212223242526272829303132333435function inheritObject(o) &#123; function F() &#123;&#125; F.prototype = o return new F() &#125;function inheritPrototype(subClass, superClass) &#123; //复制一份父类的原型副本保存在变量中 var p = inheritObject(superClass.prototype) //修正因为重写子类原型导致子类的constructor属性被改写 p.constructor = subClass //设置子类的原型 subClass.prototype = p //子类的原型继承了父类的原型并且没有执行父类的构造函数 &#125;function SuperClass(name) &#123; this.name = name this.colors = ['red', 'blue']&#125;SuperClass.prototype.getName = function() &#123; console.log(this.name) &#125;function SubClass(name, time) &#123; SuperClass.call(this, name) this.time = time&#125;inheritPrototype(SubClass, SuperClass)SubClass.prototype.getTime = function() &#123; console.log(this.time)&#125;var a1 = new SubClass('js', 2016)var a2 = new SubClass('ca', 2017)a1.colors.push('green')console.log(a1.colors) //[\"red\", \"blue\", \"green\"] console.log(a2.colors) //[\"red\", \"blue\"] a1.getTime() //2016 a2.getName() //ca 子类想要添加原型方法必须通过prototype对象 多继承 mix方法作用是将传入的多个对象的属性复制到源对象中， 实现对多个对象的属性的继承 123456789101112Object.mix = function(_class, mix) &#123; var classProto = _class.prototype, mixProto = mix.prototype; for (var i in mixProto) &#123; if (i in classProto) &#123; classProto[\"_\" + i] = mixProto[i]; &#125; else &#123; classProto[i] = mixProto[i]; &#125; &#125; &#125; 写一个B继承a的方法12345678910B.prototype = new A();function a ()&#123; this.a = &quot;23332&quot;&#125;function b ()&#123;&#125;;b.prototype = new a();var test = new b()test.a //2332","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"继承","slug":"继承","permalink":"http://wiki.haoqiao.me/tags/继承/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"Webpack","date":"2017-07-12T12:32:59.000Z","path":"wiki/前端/基础/Ecmascript/Webpack/","text":"概述webpack提供的是一个前端模块化的方案 requirejs是一种在线”编译” 模块的方案，相当于在页面上加载一个AMD 解释器，以便于浏览器能够识别 define、exports、module，而这些东西就是用于模块化的关键。 而browserify / webpack，则是一个预编译模块的方案。它是预编译的，，不需要在浏览器中加载解释器。另外，你在本地直接写JS，不管是 AMD / CMD / ES6 风格的模块化，它都能认识，并且编译成浏览器认识的JS 原理 所有资源统一入口webpack是通过js来获取和操作其他文件资源的，比如webpack想处理less, 但是它并不会直接从本地的文件夹中直接通过路径去读取css文件，而且通过执行入口js文件，如果入口 文件中，或者入口文件相关联的js文件中含有 require(xx.less) 这个less文件，那么它就会通过 对应的loader去处理这个less文件 总结: 每个文件都是一个资源，可以用require导入js 每个入口文件会把自己所依赖(即require)的资源全部打包在一起，一个资源多次引用的话，只会打包一份 对于多个入口的情况，其实就是分别独立的执行单个入口情况，每个入口文件不相干(可用CommonsChunkPlugin优化) 在入口文件中，对每个require资源文件进行配置一个id, 也 就是说，对于同一个资源,就算是require多次的话，它的id也是一样的，所以无论在多少个文件中 require，它都只会打包一分 tree shaking即从模块包中排除未使用的 exports 项 tree-shaking 消灭没有用到的代码 不管是 rollup 还是 webpack 2，tree-shaking 都是因为 ES6 modules 的静态特性才得以实现的 只能作为模块顶层的语句出现，不能出现在 function 里面或是 if 里面。（ECMA-262 15.2) import 的模块名只能是字符串常量。(ECMA-262 15.2.2) 不管 import 的语句出现的位置在哪里，在模块初始化的时候所有的 import 都必须已经导入完成。换句话说，ES6 imports are hoisted。(ECMA-262 15.2.1.16.4 - 8.a) import binding 是 immutable 的，类似 const。比如说你不能 import { a } from ‘./a’ 然后给 a 赋值个其他什么东西。(ECMA-262 15.2.1.16.4 - 12.c.3) 这些设计虽然使得灵活性不如 CommonJS 的 require，但却保证了 ES6 modules 的依赖关系是确定 (deterministic) 的，和运行时的状态无关，从而也就保证了 ES6 modules 是可以进行可靠的静态分析的 正是基于这个基础上，才使得 tree-shaking 成为可能（这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking） Webpack 怎么提取公共模块common chunk plugins 顾名思义，Common Chunks 插件的作用就是提取代码中的公共模块，然后将公共模块打包到一个独立的文件中去，以便在其它的入口和模块中使用。","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"Webpack","slug":"Webpack","permalink":"http://wiki.haoqiao.me/tags/Webpack/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"基础","date":"2017-07-12T12:32:59.000Z","path":"wiki/前端/基础/Ecmascript/基础/","text":"基本类型基本数据类型Undefined、 Null、 Boolean、 Number、 StringES6新增symbol一个复杂数据类型 Object null， undefined 的区别 null 表示一个对象是“ 没有值” 的值， 也就是值为“ 空”； ；undefined 表示一个变量没有被声明， 不存在这个值， 或者被声明了但没有被赋值null的类型(typeof) 是objectundefined的类型(typeof) 是undefined除了NULL和Undefined 任何值都有toString() 方法试图把这两者转为对象会抛出TypeError 内置函数hasOwnProperty()用于检查给定的属性在当前对象实例中(而不是在实例的原型中) 是否存在 getPrototypeOf() 方便取得一个对象的原型对象的比较并非值的比较， 即使两个对象包含同样的属性和相同的值， 他们也不是相等的， 各个索引完全相等的两个数组也不相等。 他们的比较是引用的比较。 基本类型和引用类型基本类型在内在中具有固定的大小引用类型则不同对象可以具有任意的长度,无固定大小。 数组也是 String Object是引用类型基本类型变量存的是数据的具体值而引用类型变量保存的是值的引用 动态属性 不能给基本类型的值添加属性， 即使添加了也会消失。 因为创建的是临时对象， 赋值之后立刻销毁。 123456789101112var a = new Object();a.name = “2333 \"console.log(a) VM327: 3 Object &#123; name: \"2333\" &#125;undefinedvar b = \"666”;b.name = “2333 \"console.log(b) VM363: 3 666 undefinedvar b = \"666”;b.name = \"2333” console.log(b.name) 方法 栈方法push() 接受任意数量的参数， 逐个添加到数组末尾 pop() 方法从数组末尾移除最后一项， 返回移除的项 队列方法 shift() 移除数组中第一项并返回该项 unshift() 在数组前端添加任意个项并返回新数组的长度 配合pop() 实现队列操作方法 concat()先创建当前数组的一个副本， 然后将接收到的参数添加到这个副本的末尾， 然后返回新构建的数组 slice()基于当前数组中的一或者多个项创建新数组， 接受(起始位置， 结束位置。) 只有一个参数， 则指定开始到数组末尾。 如果有两个参数， 则起始位置到结束位置（ 不包括结束位置） slice() 不会影响原数组 splice()删除： 指定删除的第一项位置和要删除的数量。 splice(0, 2) 删除前两项插入: 可以向指定位置插入任意数量的项。 只需提供三个参数: 起始位置, 0(删除数量设为0), 要插入的任意数量的项.如splice(2, 0, ’red’, ’blue’) 在数组位置2插入两项。替换: 向指定位置插入任意数量的项目， 同时删除任意数量的项。 插入数量和删除数量不用相等。 如splice(2, 1, ’red’, ’blue’) 会删除位置2的项， 然后从位置2开始插入新的数据。始终返回被删除的数据， 如果没有删除任何项， 则返回空数组。 会改变原数组。位置方法 indexOf() 接受两个参数: 查找的项， 查找起始位置, 没找到返回 - 1 lastIndexOf() 接受两个参数: 查找的项， 查找起始位置 倒序找， 没找到返回 - 1迭代方法 这些方法都不会修改数组内原始的值every() 对数组每一项运行给定函数， 如果该函数对每一项都返回 true，则返回 true some() 对数组每一项运行给定函数， 如果该函数对任意一项返回 true则返回 true filter() 对数组每一项运行给定函数， 返回 true的项组成的数组 forEach()对数组每一项运行给定函数, 没有返回值 map() 对数组每一项运行给定函数， 返回每次函式调用的结果组成的数组归并方法 reduce() 迭代数组中所有项， 然后构建一个最终返回的值。reduce 为数组中的每一个元素依次执行回调函数， 不包括数组中被删除或从未被赋值的元素接受四个参数： 初始值（ 或者上一次回调函数的返回值）， 当前元素值， 当前索引， 调用 reduce 的数组回调函数第一次执行时， previousValue 和 currentValue 的取值有两种情况， 如果 initialValue 在调用 reduce 时被提供， 那么第一个 previousValue 等于 initialValue， 并且currentValue 等于数组中的第一个值； 如果initialValue 未被提供， 那么previousValue 等于数组中的第一个值， currentValue等于数组中的第二个值[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array) { return previousValue + currentValue; }); //10reduceRight() 从数组末尾往前遍历 内置对象数据封装类对象Object、 Array、 Boolean、 Number 和 StringString类型 var s = ‘linshuizhaoying,lin’console.log(s.charAt(0)) //第一个字符 console.log(s.charAt(s.length -1)) //最后一个字符 console.log(s.substring(1,4)) //第2~4个字符 console.log(s.slice(-3)) //最后三个字符 console.log(s.indexOf(‘l’)) //l第一次出现的位置 console.log(s.lastIndexOf(‘l’)) //l最后一次出现的位置 console.log(s.split(‘,’)) //分割成两个子串 console.log(s.replace(‘y’, ‘Y’)) //全文字符替换 console.log(s.toUpperCase()) //大写其他对象Function、 Arguments、 Math、 Date、 RegExp、 ErrorDate类型new Date();new Date(value);new Date(dateString);new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);Date.now() 返回自 1970 - 1 - 1 00: 00: 00 UTC(时间标准时间) 至今所经过的毫秒数。 Date.parse() 解析一个表示日期的字符串， 并返回从 1970 - 1 - 1 00: 00: 00 所经过的毫秒数。 Date.UTC() 接受和构造函数最长形式的参数相同的参数（ 从2到7）， 并返回从 1970 - 01 - 01 00: 00: 00 UTC 开始所经过的毫秒数。 Date.prototype.getDate() 根据本地时间返回指定日期对象的月份中的第几天（ 1 - 31）。 Date.prototype.getDay() 根据本地时间返回指定日期对象的星期中的第几天（ 0 - 6）。 Date.prototype.getFullYear() 根据本地时间返回指定日期对象的年份（ 四位数年份时返回四位数字）。 Date.prototype.getHours() 根据本地时间返回指定日期对象的小时（ 0 - 23）。 Date.prototype.getMilliseconds() 根据本地时间返回指定日期对象的微秒（ 0 - 999）。 Date.prototype.getMinutes() 根据本地时间返回指定日期对象的分钟（ 0 - 59）。 Date.prototype.getMonth() 根据本地时间返回指定日期对象的月份（ 0 - 11）。 Date.prototype.getSeconds() 根据本地时间返回指定日期对象的秒数（ 0 - 59）。 Date.prototype.getTime() 返回从1970 - 1 - 1 00: 00: 00 UTC（ 协调世界时） 到该日期经过的毫秒数， 对于1970 - 1 - 1 00: 00: 00 UTC之前的时间返回负值。var a = new Date() //Thu Sep 22 2016 10:50:26 GMT+0800 (CST) console.log(a.toDateString())//Thu Sep 22 2016 console.log(a.toTimeString())//10:51:25 GMT+0800 (CST) console.log(a.toUTCString())//Thu, 22 Sep 2016 02:51:25 GMTMath对象console.log(Math.pow(2, 3)) // 2的3次幂 console.log(Math.round(.6)) // 四舍五入 console.log(Math.ceil(.6)) // 向上求整 console.log(Math.floor(.6)) // 向下求整 console.log(Math.abs(-5)) // 求绝对值 var x = 1, y = 3, z = 2 console.log(Math.max(x,y,z)) // 返回最大值 console.log(Math.min(x,y,z)) // 返回最小值 console.log(Math.random()) // 生成随机数 console.log(Math.sqrt(3)) // 3的平方根toFixed() 根据小数位后指定位数将数字转为字符串函数也是一种特殊的对象 js单线程 JS运行在浏览器中， 是单线程的， 在某个特定的时刻只有特定的代码能够被执行， 并阻塞其它的代码。 而浏览器是事件驱动的（ Event driven）， 浏览器中很多行为是异步（ Asynchronized） 的， 会创建事件并放入执行队列中。 javascript引擎是单线程处理它的任务队列， 你可以理解成就是普通函数和回调函数构成的队列。当异步事件发生时， 如mouse click, a timer firing, or an XMLHttpRequest completing（ 鼠标点击事件发生、 定时器触发事件发生、 XMLHttpRequest完成回调触发等）， 将他们放入执行队列， 等待当前代码执行完成Ajax请求确实是异步的， 这请求是由浏览器新开一个线程请求， 事件回调的时候是放入Event loop单线程事件队列等候处理 ECMAScript： JavaScript的核心， 描述了语言的基本语法文档对象模型（ DOM）： DOM（ 文档对象模型） 是 HTML 和 XML 的应用程序接口（ API）设置css12345oDiv.style.width = ‘300 px’;oDiv.className = ‘active’;批量设置样式 oDiv.style.cssText = ‘width: 300 px;height: 300 px’; Dom getAttribute()可以取得自定义特性 setAttribute()可以对dom节点设定自定义特性 querySelector()接受一个css选择符， 返回与该模式匹配的第一个元素。 没有返回Null querySelectorAll()接受一个css选择符， 返回与该模式匹配的所有元素。 没有返回Null 12document.querySelector(&apos;.test&apos;).classList.remove(&quot;test&quot;).remove(&apos;disabled&apos;) document.querySelector(&apos;.test&apos;).classList.add(...) //只会添加一次 document.querySelector(&apos;.test&apos;).classList.toggle(...) //有class则删除，没有添加 getElementsByTagName()通过标签名称 getElementsByName()通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById()通过元素Id，唯一性 getElementsByClassName DOM操作添加appendChild() 移除removeChild() 移动replaceChild()insertBefore() //在已有的子节点前插入一个新的子节点 创建创建新节点createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点 DOM操作例子如果要插入的 li 是 300 个 (() =&gt; { var ndContainer = document.getElementById(‘js-list’); if (!ndContainer) { return; } for (let i = 0; i &lt; 300; i++) { const ndItem = document.createElement(&apos;li&apos;); ndItem.innerText = i + 1; ndContainer.appendChild(ndItem); } ndContainer.addEventListener(&apos;click&apos;, function (e) { const target = e.target; if (target.tagName === &apos;LI&apos;) { alert(target.innerHTML); } }); })(); 如果要在 ul 中插入 30000 个 li，会有什么问题？代码需要怎么改进？几乎可以肯定，页面体验不再流畅，甚至会出现明显的卡顿感，该怎么解决？ 综合上面的分析，可以从减少 DOM 操作次数、缩短循环时间两个方面减少主线程阻塞的时间。减少 DOM 操作次数的良方是 DocumentFragment；而缩短循环时间则需要考虑使用分治的思想把 30000 个 分批次插入到页面中，每次插入的时机是在页面重新渲染之前 1234567891011121314151617181920212223242526272829303132333435363738394041424344(() =&gt; &#123; const ndContainer = document.getElementById('js-list'); if (!ndContainer) &#123; return; &#125; const total = 30000; const batchSize = 4; // 每批插入的节点次数，越大越卡 const batchCount = total / batchSize; // 需要批量处理多少次 let batchDone = 0; // 已经完成的批处理个数 function appendItems() &#123; const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; batchSize; i++) &#123; const ndItem = document.createElement('li'); ndItem.innerText = (batchDone * batchSize) + i + 1; fragment.appendChild(ndItem); &#125; // 每次批处理只修改 1 次 DOM ndContainer.appendChild(fragment); batchDone += 1; doBatchAppend(); &#125; function doBatchAppend() &#123; if (batchDone &lt; batchCount) &#123; window.requestAnimationFrame(appendItems); &#125; &#125; // kickoff doBatchAppend(); ndContainer.addEventListener('click', function (e) &#123; const target = e.target; if (target.tagName === 'LI') &#123; alert(target.innerHTML); &#125; &#125;);&#125;)(); DOM 中 Property 和 Attribute 的区别 property是DOM中的属性,JavaScript里的对象每个DOM节点都是一个object对象， 它可以像其他的js Object一样具有自己的property和method， 所以property的值可以是任何数据类型，大小写敏感 attribute是HTML标签上的特性， 它的值只能够是字符串attribute出现在dom中， js提供了getAttribute / setAttribute等方法来获取和改变它的值， attribute的值只能是字符串且大小写不敏感， 最后作用于html中， 可以影响innerHTML获取的值。 可以通过访问dom节点的attributes属性来获取改节点的所有的attribute 非自定义的属性(id / src / href / name / value等)， 通过setAttribute修改其特性值可以同步作用到property上， 而通过.property修改属性值有的(value) 时候不会同步到attribute上， 即不会反应到html上 Array - like Object（ 伪数组） 不是数组， 但是有length属性 不可以使用数组的push、 pop、 shift、 unshift等数组原生的方法 具体代表： NodeList， HTML Collections，function.arguments slice方法可以用来将一个类数组（ Array - like） 对象 / 集合转换成一个数组Array.prototype.slice.call(arguments) 判断数据类型typeof（ 返回字符串）‘string’‘number’‘boolean’‘object’: 如果这个值是对象或者null(因为null被认为是一个空对象)‘function’：这个值是函数undefined 未定义无法判断引用类型（ 除了function类）， 也就是继承自object类型的具体类型， 比如Array、 Date、 自定义类， 这些一律返回object instanceof操作符判断数据类型 所有typeof值返回值为 “object”的对象(如数组) 都包含一个内部属性[class] 一般通过 Object.prototype.toString() 获得 instanceof 检测一个对象A是不是另一个对象B的实例的原理是：查看对象B的prototype指向的对象是否在对象A的[[prototype]]链上。如果在，则返回true,如果不在则返回false a istanceof A: 判断a是否是A的实例， 其实是在判断a.proto === A.prototypeinstanceof 只能用来判断两个对象是否属于原型链的关系， 而不能获取对象的具体类型 1234567var arr = [];arr instanceof Array // true arr instanceof Object // true 原因 arr._proto_ === Array.prototype;Array.prototype._proto_ === Object.prototype; Object.prototype._proto_ === null; Object.prototype.toString.call() 精确判断数据类型 可以用来精确判断数据类型， 包括Boolean、 Number、 String、 Function、 Array、 Date、 RegExp、 Object、 Error等类型。 返回类似’[object type]‘ 的字符串， type指前面提到过的Boolean、 String等类型。 缺点： 无法检测开发人员自定义的构造函数创建的实例类型。 toString是Object原型对象上的一个方法， 该方法默认返回其调用者的具体类型 1234Object.prototype.toString.call(&apos;&apos;); // [object String] Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call([]) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(document) ; // [object HTMLDocument] Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用 判断一个变量是数组Array类型Object.prototype.toStringArray.isArray() 1234567if(typeof Array.isArray===&quot;undefined&quot;)&#123; Array.isArray = function(arg)&#123; return Object.prototype.toString.call(arg)===&quot;[object Array]&quot; &#125;; &#125; javascript 本地对象 内置对象 宿主对象分别指什么 本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。 本地对象”包含哪些内容： Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError 简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。 内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了 而ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。 所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。 所有的BOM和DOM对象都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。其实说白了就是，ECMAScript官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过ECMAScript程序创建的对象。 浏览器对象模型（ BOM） 对浏览器窗口进行访问和操作BOMlocation对象host: 返回服务器名和端口(如果有)href: 返回完整urlprotocol: 返回协议, http或httpssearch: 返回URL查询字符串 outerWidth和 outerHeight返回浏览器窗口本身的尺寸 innerWidth和 innerHeight返回该容器内页面视图区的大小（ 减去边框）(高程书上写Chrome中两者返回相同.然而这时错的， 经过测试是宽度返回相同， 然而高度却是按照本身定义所返回的。) navigator.userAgent用户代理检测 utf8和gbk的区别GBK的文字编码是双字节来表示的，即不论中、英文字符均使用双字节来表示，只不过为区分中文，将其最高位都定成1。 至于UTF－8编码则是用以解决国际上字符的一种多字节编码，它对英文使用8位（即一个字节），中文使用24位（三个字节）来编码。对于英文字符较多的论坛则用UTF－8节省空间。 GBK包含全部中文字符，UTF-8则包含全世界所有国家需要用到的字符。 对于中文较多的论坛，适宜用GBK编码节省数据库空间。 对于英文较多的论坛，适宜用UTF-8节省数据库空间。 offsetHeight, scrollHeight, clientHeight分别代表什么 clientHeight 大部分浏览器对 clientHeight 都没有什么异议，认为是元素可视区域的高度，也就是说元素或窗口中可以看到内容的这个区域的高度，即然是指可看到内容的区域，滚动条不算在内。但要注意padding是算在内。其计算方式为clientHeight = topPadding + bottomPadding+ height - 水平滚动条高度。 offsetHeight 在IE6，IE7，IE8， IE9以及最新的的FF, Chrome中，对于一般元素，都是offsetHeight = padding + height + border = clientHeight + 滚动条 + 边框。 scrollHeight scrollHeight的争议比较大，有些浏览器认为scrollHeight可以小于clientHeight，有些认为scrollHeight至少应该等于clientHeight。但有一点是一样的，就是scrollHeight &gt;= topPadding + bottomPadding + 内容margin box的高度。 果你想获取视窗可见部分的高度，应该使用documentElement.clientHeight，因为body.clientHeight是由它的内容决定的。","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"基础","slug":"基础","permalink":"http://wiki.haoqiao.me/tags/基础/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"实习到工作一条龙","date":"2017-07-12T11:24:10.000Z","path":"wiki/前端/实习/2017-09-24-实习到工作一条龙/","text":"准备阶段一份看得过去的简历。项目经历很重要，建议是遵循Star原则。关于简历如何写，看这里 算法必须 必须 必须 提前准备1个月及以上，不然平时复习职业技能相关的内容来不及。 面试最好从小公司一路面过去，再面大公司，这样你心里会有底。而且你每次面试完之后查漏补缺，到面大公司的时候就比较稳。 手写基本排序，基本算法都是必要的。因为笔试过了基本有三面，第一面问基础，第二面视频面写代码(前端考察基本的数据结构，后端就是算法),第三面HR。 前两面都是靠实打实的内容，平时项目经历一定要丰富，不然面试没有话题就会很尴尬。HR面有很多套路，建议多看看别人的面试心得。然后自己不要用套路，面对套路有自己的一套说法就Ok。 大二开始就可以关注秋招和春招，以及大公司一些实习机会了.能投就投，不要犹豫被拒绝。 书单《剑指offer》 《技术之瞳》 《算法第四版》 《其它所有技术相关的书0-0都刷一遍，平时有做笔记最好》 网站牛客网主要是这个网站，题库很全，而且有在线的大公司的投递时间。 牛客网最需要看的还是往年的面试心得，还有一系列总结。比如刷题的网站大全。笔试大全等等。 还有很多类似我这种总结，针对性的去加入到自己的列表。 现在也有很多课程我建议随便瞄一下就行了。 刷算法的网站有: 基本上把剑指offer的题目刷完。再刷200道leetcode的题目，一般面试和笔试的算法题就稳了。更复杂的还要看平时积累。 leetcode Codeforces APP实习僧(用于平时实习，兼职) 拉钩(关键靠简历) 牛客(牛客网的APP) 脉脉(职场APP，内推大公司首选，基本上都会很乐意帮你内推的，只要简历关过,免笔试啊~) 其他途径各大公司的校招官网投递简历。 微信群，校招群，QQ群。平时加入的一些技术讨论群里都会有内推。 霸面(适合比较有勇气的) 实习基本就是能内推免笔试最好。 其次就是正常渠道。 多关注各大公司的校招时间。 提前准备起来。 实习中不仅看你技术能力还有考察你的学习能力，这点要有心理准备。 抗压能力一定要稳稳的，hr压力面一定要稳住。 自己平时一定要有做项目，然后要有自己的思考。 框架源码要多看，现在大公司特别喜欢问源码。 另外有什么问题可以私聊","tags":[{"name":"实习","slug":"实习","permalink":"http://wiki.haoqiao.me/tags/实习/"},{"name":"工作","slug":"工作","permalink":"http://wiki.haoqiao.me/tags/工作/"},{"name":"面试","slug":"面试","permalink":"http://wiki.haoqiao.me/tags/面试/"},{"name":"笔试","slug":"笔试","permalink":"http://wiki.haoqiao.me/tags/笔试/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"实习","slug":"前端/实习","permalink":"http://wiki.haoqiao.me/categories/前端/实习/"}]},{"title":"基础","date":"2017-07-12T11:24:10.000Z","path":"wiki/前端/框架/JQuery/基础/","text":"jQuery中$的理解[?]jQuery各种事件，自己实现[?]jauery中map和each的区别[?]bind和on的区别，live和bind的区别 bind是直接绑定在一个对象上。 live(type,[data],fn) 给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的通过冒泡的方式来绑定到元素上的。更适合列表类型的，绑定到document DOM节点上。和.bind()的优势是支持动态数据。 on方法是一个事件委托。on(events,[selector],[data],fn) 在选择元素上绑定一个或多个事件的事件处理函数 window.onload和$(document).ready()的区别 window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行，$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕 window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个，$(document).ready()可以同时编写多个，并且都可以得到执行 在jquery方法和原型上面添加方法的区别和实现（$.extend,$.fn.extend），以及jquery对象的实现（return new jQuery.fn.init）[?]手写一个jQuery插件123456789101112131415161718;(function($, window, document, undefined) &#123; //定义构造函数 var Puzzle = function(ele, opt) &#123; this.$element = ele, this.defaults = &#123;&#125;, this.options = $.extend(&#123;&#125;, this.defaults, opt) &#125; //定义方法 Puzzle.prototype = &#123; puzzleinit: function() &#123;&#125; &#125; //在插件中使用对象 $.fn.myPlugin = function(options) &#123; //创建的实体 var puzzle = new Puzzle(this, options); //调用其方法 return puzzle.puzzleinit(); &#125;&#125;)(jQuery, window, document);$('#puzzle').myPlugin(&#123;&#125;);","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"基础","slug":"基础","permalink":"http://wiki.haoqiao.me/tags/基础/"},{"name":"JQuery","slug":"JQuery","permalink":"http://wiki.haoqiao.me/tags/JQuery/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"框架","slug":"前端/框架","permalink":"http://wiki.haoqiao.me/categories/前端/框架/"},{"name":"JQuery","slug":"前端/框架/JQuery","permalink":"http://wiki.haoqiao.me/categories/前端/框架/JQuery/"}]},{"title":"在CVTE实习的那些天(生活篇)","date":"2017-07-12T11:24:10.000Z","path":"wiki/前端/实习/2017-08-19-cvte-生活记录/","text":"起始大概也是在今年春节过后到学校的时候，本来想着提前找个实习，没想到那个时间段很多内推都已经截止，剩下投了几个简历，阿里和cvte给了面试机会。 然后阿里二面挂，cvte一路畅通，暑期7月15号学校一放假就买好票来cvte，因为来回路费是按硬卧报销，然后我就直接买了硬卧的。在路途之中，司机师傅打电话再三来跟我确定到达时间，来接我的hr小姐姐也沟通了几次，到达的时候就很迅速的上车来到公司。 我记得那个时候是晚上5点多了，然后其它实习生都high完了，好像我是最迟那一批，不过我的生活导师夏纯鑫，从我来的路上开始跟我聊，然后到的时候亲自下来，那个时候我以为导师就一位，没想到生活导师是做销售的，技术导师在第二周才遇见。 我记得比较清楚的就是餐厅挺大的，全自助。饭后水果，果酒，饮料都不缺。还有各种甜点。这是后期一直很吸引我的地方。 吃完我记得是直接回实习生宿舍，好像是说实习生住的好一些，公司专门用来提供外派员工住宿的地方，跟酒店一样，按照姓氏，我也分到了一个姓钱的室友，他的职位方向是海外销售。我记得进门之前有一个标题，上面写着，欢迎XXX,XXX回家。那个时候感觉还有点奇妙的。两人寝，床对面就是一个很大的电视，往后一起的日子晚上十点多我和钱圳冰就以暴走大事件和非诚勿扰来进行话题的交流，但是钱圳冰作为销售岗提前一周离开，然后电视再也没开过。 对实习生感觉真的蛮好，各种老员工过来夹道给你鼓掌，第一周各种素质培训，包括紧急救人的一些医学知识，打领带配衣装的礼仪知识，开了个实习生晚宴教餐桌礼仪，餐前酒，各种酒下来三四种，然后各种老总看到外面的东西吃起来不错就往公司里顺，晚宴上大部分甜品种类都是这么来的2333 公司文化感觉还是外圣内王。 我记得第一周培训有几个有意思的点。一个是将所有人打散，然后一起团队协作完成一些任务。第一天一个团队，第二天可能就换了一个。那个时候认识了不少有意思的人。然后是周四还是周三有一个活动就是用眼罩围着眼睛，拉着周围人的手，从公司大楼底部，绕了不知道多少圈然后走上三楼，相信别人。在黑暗中时间流淌的特别慢，当你惊慌失措，遇到台阶，遇到障碍物，都是你的队友给予你的帮助，不放开手。这种体验对我来说很新颖，也很有感触。 还有就是周四下午讲完头脑风暴这门课，然后立刻让我们小组准备周五晚上，实习生表演节目晚会。这个真心爆炸，不过感觉那两天学到了很多东西。那一个星期最大的体会就是，没有什么不可能，你认为做不到的事情不是做不到，你去做就肯定能做到。这为后来的实习有了一个比较好的心态。后来三周实习是去公司的另一个产业园，早上8点班车接送半小时到达。晚上8点班车接回。 公司的福利现在记得比较清楚的是: 1.每年两次员工体检（公司有自己的体检中心，设备据说都是一流的。） 2.每年一次家属体检。可以带老人来公司体检。公司餐厅每周一个家属开放日。不要小看餐厅，下面我来讲下餐厅。3.三餐全是自助形式的餐厅，我能感受到最大的福利。早上，八分熟单还是全熟的任意选，还有广州的特产，然后各种包子，馒头，更重要的是还有什么鸡爪啊，牛肉啊。茶叶蛋，白煮蛋。还有各种蔬菜。早上我一般喝酸奶，旁边的配料有各种葡萄干，核桃等等各种干果。旁边也有水果沙拉，不过不习惯就没怎么点。不喜欢酸奶的可以去吃面或者还有粥。公司有个西餐厅专门给孕妇，据说夜宵的时候是开放的，但是晚餐每次都很饱，就没去吃过。孕妇餐厅据说一条鱼都给你把刺给去掉。不过那么复杂的我觉得会少一些，更多应该是刺少的那种煎鱼。中餐和晚餐，都可以去喝点酒，酒有香槟，红白葡萄酒，rio果酒。每餐肉类至少五种。都是无限量，不过遵循少拿多次的原则避免浪费。每周还有美食节，我记得第一产业园是周四，第二产业园是周五，有次运气好两边的我都赶上了。。。美食节会有各种大餐，三文鱼无限，大虾，烤全羊，海鲜荟，各种烧烤，烤茄子，鸡翅，玉米。都有。。。每次还都有几个专门的cvte蛋糕，甜点有各种寿司，不过每次三文鱼吃饱，寿司没想法。。。美食节相当于每周都去浪一次，而且还是令人超级满意的，能吃饱的。感觉对吃的太满意了，导致后来实习结束hr问我公司什么地方最吸引你，毫不犹豫暴露了吃货本质。然后HR压力面的时候说不给你吃怎么办。。。然后我想了一会，说不会吧😲…我觉得HR小姐姐可能是崩溃的 4 公司有健身房，很专业，虽然我只用过一次，感觉还不错，也有游泳池，但是去游的那天人比较多，游泳池显的小，应该是周六去游，那个时候人比较少。 5.公司两个产业园里面有自己的幼儿园，虽然并用不到现在2333，感觉最后会发展出小学的既视感 6.正式员工住房在公司附近，半小时以内路程，有班车接送，而且还可以搭乘老员工的私家车。据说新人没钱的时候想浪怎么办，带上一个老员工就可以啦~这据说是传统。。。 7.讲道理工资还是很吸引人，虽然都是hr让你自己提，我怂都没敢提更多。。。而且你基本在公司没地方花钱啊！！！想吃零食，办公室旁边就有，想喝水，每个办公室都有饮水机，而且是直接净水的那种，想喝咖啡，每个大厅都有休息处，咖啡机，手动磨，想怎么玩都可以。所以你的工资除了交税完，每个月基本剩下来去掉几百块的住房就只能剩下来了。。。大概就是我一心只想上班的理由。。。 8.玩的话我记得第二产业园健身房有两个台球桌，可以打乒乓。我们部门那层有滑滑梯。。。有电子琴，有按摩椅（看上去很高级） 公司里有一个房间专门听黑胶唱片。。。虽然没去过，但是感觉b格好高啊。。。大厅也有音响。第一产业园有专门用来午睡的房间，第二产业园就没有，只有休息的躺椅，或者去大厅的沙发休息。 9.还有个隐形的福利，这是我们实习的时候自主加班发现的，周末的会议室，就那种电视里常见的，落地窗，可以看到窗外风景的那种，很大的桌子，空调，wifi，零食，还有公司的主打产品，会议屏幕，都可以使用~我们小组开发带上电脑，带上充电器，就能在那坐一天，哇，这种写代码给人的感觉，非常美好~ 接下来说人吧： 我就只讲几个对我影响比较大的： 1.我的生活导师夏纯鑫，讲道理我以前真没遇见过对一个实习的人如此上心的人，说是生活导师，其实更多是一个万能的朋友，关心你的生活，关心你的心理状态，然后我室友那个生活导师基本没怎么碰过，好像就我和另一个妹子共同的生活导师是这样的，导致别人都挺羡慕我们的。我们导师常常和在我们一起吃饭，有人过来的时候这么说，我一个销售分配到的小学员一个是软件的一个是硬件的，我是来跟他们学习的。作为刚入职的销售他其实挺忙的，但是他还是会打电话过来跟我聊天，聊聊公司，聊下一些想法。他总是在夸，不断的提升你的自信心，让你觉得你做的很多都是对的，你只需坚持自己。这种态度我很少体会到。因为他要派到上海去工作，走之前还来我实习的部门，送了我一本鸟哥的linux书，收到礼物是挺开心。然后在我前三周的实习答辩的时候，他在门外站了一个小时，讲道理，我做不到像他那样，正是如此更加觉得不可思议。因为答完hr找我聊的过程压力面，感觉不是很理想，然后他说在和我聊天中感觉没有前几周那样，特地从公司拉了几个老人来给我和另一个妹子讲讲他们的经历，因为之前我觉得如果被拒那我可能秋招就不投这家了，他觉得我不应该放弃，举了公司几个屡败屡战，败的hr都觉得再拒绝他都不好意思的例子，以及几个很厉害的销售去霸面的经历。那天正好是他准备和朋友们去嗨的时间，因为第二天他就要去上海了，然后他把聚会推掉了，特地为我，主要是我做心理疏通，其实我这人蛮心大的，对压力面也没特别想法，因此提出延期实习，在另外一个部门，我心里其实有股火，因为之前三周我技术栈整个被替换了，因此被说做的慢，但这个慢其实还包括大部分是项目那方面的，不过作为项目负责进度人，任务分配者，这锅我背了。不过我就想证明一下我的学习能力，我的学习速度，我也能做的很快。因此当第四周技术实习的时候，我一天完成需求分析，流程图，数据库设计，接口文档详细到每一个细节。第二天完成第一版本的编码，第三天完成任务基本需求。第四天把增强功能全部加上。我记得我的时候我导师说你做的很快啊，我其实就想证明这么一点。当然再一次HR面的时候hr压力面跟我讲我的技术还有很大提升空间…这就不细说了…非常感激这段日子有这样的生活导师，我的荣幸。 2.技术导师，第一个部门实习的时候是潘潇，潇神。技术很厉害，我经常拿一些幼稚的问题去问，因为当时想着好不容易逮住一只能问的，死命问~潇神估计内心也是无语的。不过实习的时候不是跟着导师，因此见面次数蛮少，只在技术上有过问问题，没有和第二个技术导师那样，一起上下班，吃饭，聊天。 第二个部门的技术导师是郑南辉，最后一个字也是辉，所以我也不好直接叫辉哥是把。。。这里有个搞笑的是hr问我技术导师叫什么，我说南…然后hr接上辉，然后笑问你是不是忘了他的名字，我回她不，主要是想让你能接住话题… 南哥在最后两天教会我的东西非常多，因为我在实习答辩的时候问了很多问题(在技术篇会提到),感觉修正了我很多技术上的路线，以及给了我很多启发。当然还有坐我旁边的小哥，我每次遇到玄学问题都问他，哈哈，虽然他也没彻底解决，但是每次他分析的思路都给了我很大启发，让我最终能够解决问题。非常感谢这么一群人。 所以公司技术氛围很浓厚，相比较而言我更喜欢第二个部门，因为写的开心。学到很多。对我接下来的一些计划都有革命性的启发。 走之前还是和之前联络负责来回车的赵钰姐帮忙定的接送车,准点上车。 在生活上，公司给我的感觉就是在邀请函上吹的牛都超乎想象的实现了，然后更多b格高的体验大概是邀请函上写不下了吧23333 而且实习工资很靠谱~来回路费都报销了，在公司基本没花钱，除了周日公司没提供饭，自己得出去觅食。。。","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"实习","slug":"实习","permalink":"http://wiki.haoqiao.me/tags/实习/"},{"name":"CVTE","slug":"CVTE","permalink":"http://wiki.haoqiao.me/tags/CVTE/"},{"name":"生活","slug":"生活","permalink":"http://wiki.haoqiao.me/tags/生活/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"实习","slug":"前端/实习","permalink":"http://wiki.haoqiao.me/categories/前端/实习/"}]},{"title":"基础","date":"2017-07-12T11:24:10.000Z","path":"wiki/前端/框架/Vue/基础/","text":"vue双向绑定基于什么实现defineProperty()方法 该方法允许精确添加或修改对象的属性。一般情况下，我们为对象添加属性是通过赋值来创建并显示在属性枚举中（for…in或 Object.keys方法）， 但这种方式添加的属性值可以被改变，也可以被删除。而使用 Object.defineProperty() 则允许改变这些额外细节的默认设置","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"基础","slug":"基础","permalink":"http://wiki.haoqiao.me/tags/基础/"},{"name":"Vue","slug":"Vue","permalink":"http://wiki.haoqiao.me/tags/Vue/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"框架","slug":"前端/框架","permalink":"http://wiki.haoqiao.me/categories/前端/框架/"},{"name":"Vue","slug":"前端/框架/Vue","permalink":"http://wiki.haoqiao.me/categories/前端/框架/Vue/"}]},{"title":"基础","date":"2017-07-12T11:24:10.000Z","path":"wiki/前端/框架/React/基础/","text":"概述react的优势 组件式开发 代码清晰 采用单向数据流，数据流动方向单一，可跟踪组件化，JSX 自定义标签，便于抽象化 什么是虚拟dom,React如何实现,和dom对比 虚拟的DOM 核心思想是：对复杂的文档DOM结构，提供一种方便的工具，进行最小化地DOM操作 用JS表示DOM结构 如果没有 Virtual DOM，简单来说就是直接重置 innerHTML。这样操作，在一个大型列表所有数据都变了的情况下，还算是合理，但是，当只有一行数据发生变化时，它也需要重置整个 innerHTML，这时候显然就造成了大量浪费。 React实现 用JS对象模拟DOM树 比较两棵虚拟DOM树的差异 把差异应用到真正的DOM树上 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 props和state的区别 state只能在组件内部使用，state只应该用于存储简单的视图状（如：上面示例用于控制下拉框的可见状态） State如果component的某些状态需要被改变，并且会影响到component的render，那么这些状态就应该用state表示。例如：一个购物车的component，会根据用户在购物车中添加的产品和产品数量，显示不同的价格，那么“总价”这个状态，就应该用state表示。 Props会在整个组件数中传递数据和配置，props可以设置任命类型的数据，应该把它当做组件的数据源。其不但可以用于上级组件与下组件的通信，也可以用其做为事件处理器。 Props如果component的某些状态由外部所决定，并且会影响到component的render，那么这些状态就应该用props表示。例如：一个下拉菜单的component，有哪些菜单项，是由这个component的使用者和使用场景决定的，那么“菜单项”这个状态，就应该用props表示，并且由外部传入。 props和state都不能直接修改，而应该分别使用setProps()和setSate()方法修改 为什么要单向数据流单向数据流：通过事件分发器 (dispatcher)，开发者必须显式地通过这个统一的事件机制做数据变更通知 这样做的好处是所有状态变化都可以被记录、跟踪，状态变化通过手动调用通知，源头易追溯，使得程序更直观更容易理解，有利于应用的可维护性。缺点则是代码量会相应的上升 单向数据绑定的实现思路所有数据只有一份一旦数据变化，就去更新页面(data-页面) 但是没有(页面-data)如果用户在页面上做了变动。那么就手动收集起来(双向是自动)，合并到原有的数据中 React设计思想 设计 React 的核心前提是认为 UI 只是把数据通过映射关系变换成另一种形式的数据。同样的输入必会有同样的输出。这恰好就是纯函数。","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"基础","slug":"基础","permalink":"http://wiki.haoqiao.me/tags/基础/"},{"name":"React","slug":"React","permalink":"http://wiki.haoqiao.me/tags/React/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"框架","slug":"前端/框架","permalink":"http://wiki.haoqiao.me/categories/前端/框架/"},{"name":"React","slug":"前端/框架/React","permalink":"http://wiki.haoqiao.me/categories/前端/框架/React/"}]},{"title":"在CVTE实习的那些天(技术篇)","date":"2017-07-12T11:24:10.000Z","path":"wiki/前端/实习/2017-08-19-技术记录/","text":"前言因为技术这块需要严谨一点，因此把自己每天的日报贴上来。 第一个部门实习日志–钱育辉[2017-07-24]今日实习内容及完成情况完成了前端基本开发环境的搭建确认了基本的技术选型。我们小组选择了React 全家桶原因有以下几点：1.公司内部大部分业务是用react，有问题我们可以获得非常给力的技术支援。2.小组成员有大部分由react开发经验，上手较快，而且小组有准备进行技术文档的编写，能够方便统一风格。3.考虑到项目是跳蚤市场这种交互性比较强的，我们可以用react写交互也比较方便。4.react全家桶方便我们调试测试。而且react相关的技术文档也比较好找。小组准备尝试用worktile来管理项目进程。之后我们全组包括后台进行了简单的需求分析，前端这边将业务用maxhubs进行了首页草稿设计，大家进行探讨，因为有了这种会议级的设备，我们草稿迭代的很快。并且根据我们的项目特点，我们参考了掘金，淘宝等网站的设计。我们将所有需求点列举出来，先不分工，先头脑风暴列举，然后合并，并且具体化了明日的安排。今天主要的是将前后端的职责先大体确定了，我们在没有数据的情况下，将先进行数据mock，后端们将努力攻克比较复杂的算法，前端们将把流程 给确定下来。利用思维导图我们先确定了整个项目大致需要12个页面。我们讨论了最终大部分按组件方式进行分工，在开发前组件划分还需要更细致的约定与讨 论。根据小组讨论我们确定了大部分技术难点:关键点：微信支付下拉刷新图片上传web安全移动端性能 将在未来一步步分工合作完成。 明日上午:前端选型确定 最终成果 可直接进行开发的环境。（包括单元测试）技术文档编写 -&gt; 组件划分 数据请求模块 async promise… 路由调用 路由传参 单元测试确定测试文档编写 -&gt; 普通模块 TRUE FALSE react测试普遍写法 确定人员分工 页面组件分配 对接说明技术文档编写 -&gt; 变量命名约定 MOCK数据（包括基本的数据格式）下午：与后台确定数据字段 （包括大分类 需要的内容）出流程图 确定后天的任务 感想今天进行项目分组的时候，从一开始的前后端分离大概念，然后逐步进行细化，因为前端小组一致认为不要先讨论过于细节化的东西，因此讨论中如果有一些细节争议，我们将其先放置一边，然后继续讨论。 在前端流程讨论中，大伙都很活跃，我觉得还是挺有效率的完成了讨论。而且个人觉得在开发前我们需要一个统一的开发环境（包括redux的一些 demo,router的一些demo,单元测试的一些demo） 在后来就有了一个技术文档的概念，大家约定一些函数的代码的写法，比如ajax获取，以及路由跳转等等，然后确定开发的变量命名，以及一些抽象的函数说 明，这样大家在写东西的时候就比较协调。更细节的还没有讨论，我们觉得将其放在实际开发中慢慢迭代更加有效率。因为之前我自己写小项目的时候也有过琢磨项目工程的一些小想法，在这次团队中我会将其进行测试验证。今天下午的web安全基础分享挺有收获，让我对web安全有了一个大致的总结，在这个项目中我们将会使用进去。因为我对react没有项目开发经验（只看过两个星期的文档），但是因为有两个小伙伴有经验，我认为我可以借鉴在vue开发项目经验，然后通过demo，技术文档以及小伙伴们在项目中的代码，完成属于自己的那部分开发任务。因为大家内心都想做一个靠谱的东西。 实习日志–钱育辉[2017-07-25]今日实习内容及完成情况今天早上按照昨天的计划，分配到的是react测试的研究。一开始考虑用enzyme做单元测试。测试学习后发现项目以redux架构后，只能对组件进行测试，然后就很难对一些具体的函数进行测试。因此经过和导师讨论公司内部单元测试主要是在nodejs端进行，因此考虑到react部分单元测试比较复杂，而且在没有具体的组件时，不好做组件这块的测试。暂时先将组件的单元测试放置。但是也同时看到有对reducer和action进行单元测试的内容。因此最终决定还是先做action和reducer的单元测试。最后将其集成到前端的技术文档里面。中午在看文档的时候，有人提醒把需求文档写完。一开始其实我们罗列需求的时候只是将一些点写下来，然后接口原先打算跟着设计稿和后台一起对一 下，但是经过提醒发现因为没有产品经理和设计师的存在，我们需要有一些文档来帮助我们将流程，进度给书面化，让大家都知道要做什么，以及对时间的安排。经 过探讨，最终决定还是划分三周的大任务，每天都划分一些任务。然后对最近两天的工作安排具体量化安排。午休的时候首先把需求文档先写了一个初始版本，然后和两个小伙伴将其细化。并且花时间完成了项目进度文档。等导师来的时候，和导师一起对着流程图和需求分析进行探讨。对页面的布局想的不够多，经过导师指出，将其进行修改。在思考购物车模块的时候，导师举了购物快照的概念，这是在之前思考的时候没有想到的，在和后台讨论接口的时候提出了这个设想并且列入需求之中。和后台讨论接口完毕后，将笔记整理成接口表格。大致确定了前端需要提交什么内容，后端返回哪种格式的数据，确认了权限验证。下午在对页面进行划分的时候，将原先12个页面扩展到18个页面。对具体需求也有了更明确的认识，比如购物车在未登陆情况下也应该能使用，一开始设想是购物车未登录直接跳转到登陆页面。。。 然后和小伙伴们一起确认了明天要开始正式编码，并且将开发文档进行了一个整合。 明日计划前端开发页面草稿， 前端需要规范页面尺寸。前端开发组件。早上初步合作写页面，下午正式写页面。我们小组将先把首页的静态版本完成（最终目标）。期间进行组件的划分，因为有了代码命名 规范，团队将对着这份进行统一风格的开发。然后进行git代码提交的正式磨合。先确定大体该怎么开发后，再具体慢慢磨合确定该如何开发。因为我们的项目跳 蚤市场首页是比较复杂的，我们需要考虑组件划分之后该如何进行配合。 感想今天早上感觉花费了挺长时间在react的单元测试上，但是在本地测试组件的时候，发现引入了4个包，代码写起来也很复杂，因此思考在我们这 个萌新小组中有没有必要一开始就写那么复杂的单元测试。后来和导师沟通后决定放弃不写组件的测试，改为对action和reducer的测试。 之后中午原本是打算按照计划来完成。但中午有前辈过来进行了指导，指出了小组现阶段的不足，我们一开始考虑的是如何把需求都完成，也有完成流 程图之类帮助理解的内容，但是没有需求文档，并没有把自己现有的已经讨论过的内容将其书面化，然后我们也没有将接口细化，没有一个比较成熟的开发思想。然 后在指导之下，明白了当前应该把需要书面化的内容全部书面化。并且该找导师的时候一定要找导师把关，因为一开始我都是遇到技术难题的时候去问，后来经过提 点，才知道导师还可以帮我们把关。 实习日志–钱育辉[2017-07-26]####今日实习内容及完成情况 今天主要是切图，将跳蚤市场的静态首页完成。因为之前有讨论如何进行分工，在今天早上大家把环境统一之后，发现组件划分还有点问题，因此先让一个同学完善，之后和另外一个小伙伴分工，一个负责主要的搜索组件，我负责切首页的图。因为是草稿，一开始打算先借鉴一点antidesign的组件，但是没有特别合适的，因此，先划分了整体结构，然后从header开始写，在写之前负责命名规范的小伙伴先讲解了命名规则，在开发过程中有一些更特别的例子先进行小组讨论，确定后再继续。因此一开始早上的效率不算高，在统一的组件结构确定后，明确了解该在哪部分写页面，哪部分写组件之后，我切图的时候提前将位置用色块留出。之后的复杂组件的小伙伴写完就可以直接套进去。下午将首页动态化，以及配合ant desgin将原先和草稿比较相似的首页进行布局调整，样式修改。因为不是特别确定组件该如何套用，因此在首页静态页面完成后，我对其中一个产品列表组件进行拆分，编码。然后再套回之前的页面。对于整个静态页面设计和路由切换比较熟悉后。之后就是对各个页面快速切图。下午团队再将代码合并，然后看了一下整体效果，再微调。 晚上和后台先确定了一下首页的接口对接。 明日计划前端开发页面，前端进行流程调试。早上 出购物车和商品详情页草稿。进行一次接口评审。和后端把首页的接口正式确定下来。将开发的页面和导师再次确定需求。进行一次code reviewMock首页所需数据。确定API调用方式。 感想因为今天工作是将设计稿页面化，因此更多的是css的编写，重新温习了一下各种布局，最后大部分页面采用flex布局。因为对react开发项目不怎么熟悉，有些地方引用文件报错，比如如何引用内部的图片。之后查了资料，将问题解决。今天花了一些时间将首页的动画效果完成，关于页面切换的效果还未完成。因为今天是第一天正式编码，团队还在磨合。今天把git冲突的解决方案团队小伙伴直接手把手教学，还有其他的一些技术问题都直接上手帮助解决。关于团队进度问题，主要是这周如果想把所有静态页面切出来还是比较赶的，主要原因是一些复杂交互的页面没有设计稿，因此安排一个擅长做草稿的 小伙伴将设计稿先做出几张，然后另一个对react开发比较熟悉的小伙伴去将接口对接以及对react中数据流的抽象完成一个简单的demo。之后我将尽 力把大部分的静态页面先切出来，然后将流程打通。尽量能够完成之前规划的第一周的目标。关于单元测试我的想法是将其延后，之后需要对api的单元测试，因为还没正式牵扯到数据这块，这两天先不考虑。今天的收获还是很大的，团队分工逐渐明确，大家完成各自的模块后都能抽空帮助解决其它人的一些疑问。 实习日志–钱育辉[2017-07-27]今日实习内容及完成情况今天完成了购物车功能的开发。并完成了订单详情页面的开发。完成了类型选择页面的开发。修改了一些bug。和后台将首页字段确定后，小伙伴将首页数据mock完成。差不多明天能够进行基本流程的编写。开发购物车的时候遇到了不少问题，主要是在react的state的改变以及数据异步的情况。因为设计到多处地方需要修改总金额这个变量。以 及购物车删除列表内容的时候，在ant desgin的插件中需要重新对数据进行一个编号的查询。后来经过调试和查资料，对照react官方文档的API文档，将问题解决。然后为了后面方便对接 数据，将所有写死的内容都抽象出来，以对象属性的方式进行赋值。并且模拟了最终提交过程的输出。 明日计划继续开发，完成大部分的静态页面。完成我的订单页面。完成 注册-&gt;登陆-&gt;发布信息 的流程完成 点击详情 -&gt; 添加到购物车的 流程完成 搜索 -&gt; 显示搜索结果的流程完成 点击分类 -&gt; 显示分类结果(可能需要新的页面，有分页)的流程 前端小组总结。 感想今天花了一天时间在切图上面，然而离目标的静态图片还有很多。比如关于管理员后台这些页面一个也没动。因此这周大概只能尽力将首页的功能尽可能的流程打通，就如明天的计划，前端组需要开始将整个应用的状态梳理出来，对接mock数据，并且有余力继续切图0-0今天晚上前端沙龙，希望能把各个能给的源码给出来带回去学习0-0 关于那个mock系统很感兴趣它的具体实现 实习日志–钱育辉[2017-07-28]今日实习内容及完成情况今天的进展有点慢，昨天的目标是首页各个部分进行流程的确定，但是中间出现了一些问题，首先早上将昨天规定的页面进行开发完成，然后是在进行调试的时候发现引用的组件有一些问题，花了一些时间去解决，但是后来发现这个其实完全可以拖到后期去做。然后和后端确定了一下关于登陆后权限如何处理的问题。之后将自己负责的页面进行了mock数据的构造。因为对redux的不熟悉，花了一些时间去构思购物车在未登录和已登陆的状态下数据的存放以及流程。下午小组因为引入了一个css module的问题，花费了很长的时间去尝试配置，然后发觉这样做的意义不大，在进度未完成的情况下，去尝试这样的重构是不科学的，花了比较多的时间也没完成，后来立刻决定先放下，先将进度去完成。 明日计划将首页各个部分接口继续完善。 将能首页各个部分的数据全都mock。 感想今天感觉虽然走了不少弯路，但是收获还是蛮大的。一个是在一些技术问题上跟导师沟通后，发现其实是自己钻了牛角尖，有些问题不应该先去考虑框架是怎么样的，而且要先将解决思路先列出来，之后再进行拆解。 关于现在的技术栈我最大的疑惑就是我写的东西应该放哪QAQ感觉需要大量成熟的react项目源码来帮助我构建整个流程。之后就是团队应该以完成功能优先，在开发前期不应该过多的考虑重构和优化，因为这会延误项目开发周期。今天下午后期的时候，阿里的rap还突然挂了一下，正在写功能的表示一脸懵逼。。。在开发过程中一些重要的服务我觉得还是本地的比较靠谱 实习日志–钱育辉[2017-07-29]今日实习内容及完成情况过去一周，花了两天需求分析，环境搭配，技术文档编写。最终三天用来开发。不过项目进度有点缓慢，主要是花了时间去做切图和功能模块编写，团队配合还有点生疏，有不少地方因为需要多次确定也浪费了不少的时间。不过基本上把首页的逻辑做完，因为一开始没想到登陆状态的重要性，导致大家一开始想着先做未登录的需求，等这些需求完成后发现，有部分功能点需要配合登陆状态一起实现，这样就导致了一些返工。还有一些时间有点浪费在css 重构上。在进度控制上就有点延后。因此在下周我们将尽力赶上进度，主要体现在一个是流程的打通。以及所有基本功能的实现。剩下时间和后台调联。 明日计划将管理员的后台页面切完。整理一下现在的代码，梳理一下整体架构。并且画一下思维导图。将下周的开发进度进行细化。争取周三前有个比较好的展示。 感想今天和导师讨论的如何关于进度的分配和关键点的切割。 之前我的考虑是大家分工将组件/页面开发，然后有个总协调的人开发整体架构。之后进行填充，这样能提升效率。但是因为一个登陆状态的缺少，的确影响到了团队的开发进度。这让我引起一个思考，就是在项目开发中关于最小流程的切割。导师给的意见是在开发的时候不要先考虑那么多，应该迭代出一个最基础的核心逻辑流程。比如在我们的项目中最核心的就是 登陆/注册 -&gt; 用户浏览商品 -&gt;添加到购物车 -&gt; 支付按道理应该是将登陆注册这个逻辑完成后再基于此进行延伸，但是因为我们需求分析后是以完成需求点为中心，因此将整个项目先进行了一次切割，这样就造成了连贯性不足，到后期组合的时候发现缺少了一些关键点。感觉从这块学到了不少。 之后就是对react框架的熟悉度不够，我还纠结了一会，不过昨天经过提醒我先把功能逻辑写出来，写完后发现把整个流程定下来之后代码逻辑还 是很清楚的，虽然不符合react的action和reduce的那种写法，然后今天考虑将其拆分后写入，因为导师也给了分析了一下写法，应该能把购物车 给彻底搞定。 实习日志–钱育辉[2017-07-31]今日实习内容及完成情况因为昨天把管理员后台的所有页面写完了今天切图的压力就少了很多。今天完成了四个页面，并且把接口模拟了。不过今天和后台确定支付的时候还需要增加一个支付确定的页面。 下午进行对接后台数据，但是中间出现不少问题。一个是后台定义的数据层级和之前约定的不符合。还有就是进行发布信息接口对接的时候，后台返回的状态不对。还有不少问题。在登陆这块和后台联调也卡了很久，主要是购物车数据返回这块。前端现阶段主要是将后台的接口给对接完，但是现阶段是卡在了前期比较关键的地方，比如发布商品这块。等后台解决后应该可以正常走流程。 明日计划负责将发布商品页面重构。 继续和后台对接。 感想今天对接的时候遇到不少奇怪的问题，服务器的，后端逻辑的，前端发送数据没带上header,cookie引发的。磨合了蛮久。不过前端这块基本上页面完成了。不过因为之前尽快的赶出页面，没有对团队的页面进行仔细的查收，在测试的时候浪费了一些时间。对数据没有进行验证。需要重构一些地方。在和后台对接的时候经常性的发现和之前约定的一些没有遵守，主要是一开始也没有将每个字段定下来。然后还有一些需求逻辑当初讲的不够细致。比 如支付这块，前端这块做得是直接购物车然后发起支付。后台需要订单状态的更改，因此后台需要的是发布订单，订单未支付，支付订单，订单已支付。因此再次确 定的时候把这几个需求加进去了。不过这两天学到了不少redux的使用技巧和关于学习的一些方法。 实习日志–钱育辉[2017-08-01]今日实习内容及完成情况今天主要做的事情是把用户发布商品，用户查看自己发布的商品，用户修改商品的组件给完善。之前做的发布功能，是将上传和提交信息分开。因此，而且我们上传后接口是返回一个字符串，因此提交的时候要收集用户上传图片的内容作为传递参数。但是有个需求就是用户可以在发布商品的时候自定义删除图片，因此还需要对上传组件做一个动作判断。ant desgin给的删除回调函数会和上传的handle函数进行冲突，因此上传一个图片会触发多次onchange,以及删除动作也会触发 onchange,因此加一个局部的删除标志，当删除的时候，上传回调函数默认不处理。之后是将上传的内容进行收集，一开始是收集每个控件内容。但是后来因为需要复用，当获取参数的时候这个发布页面可以获取产品内容，将内容自动赋值。因此又改版了，获取参数用state状态来维护。用户商品修改页面因为需要自动载入该商品的图片，而上传图片显示的控件是作为一个发布页面子组件存在。因此判断参数的时候还需要父组件将判断页面是否是从修改商品页面转来的判断参数一并传过去。之后是删除接口对接完毕。然后发现需要将用户发布的商品数据缓存到store上，因为table数据获取多页的时候，再浏览器后退，会只缓存了一页，因此需要做一个本地的数据维护。 明日计划继续对接口，前端调整页面。 感想今天在一个父子组件的重构中收获很多，一个是需要对接受的组件先进行一些修改，然后先完成和后端数据的对接，让后台能够顺利进行下一步调试。 然后前端再进行细致化的页面修改。再进行逻辑的修改。从一个单纯的发布页面，能够变成接受参数，自动载入用户的数据，并且能够任意修改商品数据，再正确对 接接口。 期间遇到一些ant desgin的组件的问题，比如textare它是很难获取数据，最后写原生的textare，然后样式模仿。数据用state来维护。 实习日志–钱育辉[2017-08-01]今日实习内容及完成情况今天主要做的事情是把用户发布商品，用户查看自己发布的商品，用户修改商品的组件给完善。之前做的发布功能，是将上传和提交信息分开。因此，而且我们上传后接口是返回一个字符串，因此提交的时候要收集用户上传图片的内容作为传递参数。但是有个需求就是用户可以在发布商品的时候自定义删除图片，因此还需要对上传组件做一个动作判断。ant desgin给的删除回调函数会和上传的handle函数进行冲突，因此上传一个图片会触发多次onchange,以及删除动作也会触发 onchange,因此加一个局部的删除标志，当删除的时候，上传回调函数默认不处理。之后是将上传的内容进行收集，一开始是收集每个控件内容。但是后来因为需要复用，当获取参数的时候这个发布页面可以获取产品内容，将内容自动赋值。因此又改版了，获取参数用state状态来维护。用户商品修改页面因为需要自动载入该商品的图片，而上传图片显示的控件是作为一个发布页面子组件存在。因此判断参数的时候还需要父组件将判断页面是否是从修改商品页面转来的判断参数一并传过去。之后是删除接口对接完毕。然后发现需要将用户发布的商品数据缓存到store上，因为table数据获取多页的时候，再浏览器后退，会只缓存了一页，因此需要做一个本地的数据维护。 明日计划继续对接口，前端调整页面。 感想今天在一个父子组件的重构中收获很多，一个是需要对接受的组件先进行一些修改，然后先完成和后端数据的对接，让后台能够顺利进行下一步调试。 然后前端再进行细致化的页面修改。再进行逻辑的修改。从一个单纯的发布页面，能够变成接受参数，自动载入用户的数据，并且能够任意修改商品数据，再正确对 接接口。 期间遇到一些ant desgin的组件的问题，比如textare它是很难获取数据，最后写原生的textare，然后样式模仿。数据用state来维护。 实习日志–钱育辉[2017-08-02]今日实习内容及完成情况将个人发布功能模块数据存到store中，完成了接口的对接。修复了一些页面逻辑的小问题，将路由跳转进行了校验。完成了管理员页面的一些交互动作，对数量比较多的管理员查看页面进行了数据缓存。下午完成了个人信息获取的接口对接。更新接口因为木有只能等待。对一些未授权直接访问地址的页面做了处理，判断传入的userId是否存在，不存在直接跳转到首页。 明日计划打算完成订单结算并到支付后的流程。 接口等待后台给。 感想很多时候在对接口的时候才发现一些问题。有时候也是因为字段的命名问题，造成接入数据不显示等问题。因此造成排错时间增加 实习日志–钱育辉[2017-08-03]今日实习内容及完成情况今天早上主要把个人信息更改接口对接了。然后做了个人信息页面访问限制，当通过记住url路径来直接访问的时候判断，跳回首页。之后因为当前接口对接差不多，剩下的订单模块还没完成，因此我就先对整个流程和功能页面进行了测试，并找出一些bug，进行修改。首先是点击左上角首页，应该能恢复到最初状态。（现在如果点分页，再点首页，是不会出现变化的。） 还有切换首页更多的状态没有动作。这是因为当初开发的时候只有静态页，其它功能组件未确定，因此留下来这种点击的动作没有连接。 比如 添加用户商品之后，回到商品列表是往本地数据库加了一个包括商品信息的一条，但没有商品ID，如果用户这个时候去点修改，是查不到商品信息的，因此向后台 反馈，发布商品返回一个商品ID。然后前端这边进行缓存加入商品ID，这样，不需要重新获取整个列表，就能针对单个商品进行修改操作。当用户没有上传图片的时候，应该显示默认图片。这里对几个展示了图片的组件做了一个判断。商品详情页，购物车可以无限添加，而且结算的页面没有进行校验。原本是打算在详情页做一个校验，判断当前添加的数量，但是发现如果切换 页面重新添加，商品数量还是会超过库存。因此在购物车详情页做了一个库存的判断，如果数量大于库存，那么就减少到库存的数量。因此今天主要做了一下排查的工作。 明日计划因为商品订单完成之后可能需要再加一个商品被购买的展示。因此可能会根据订单完成后一些需求再开发。 感想项目在开发的时候有时候为了尽快赶出功能，会有一些逻辑不严谨的判断，而且在开发的时候会无意识的忽略。因此多次回走流程进行排查，站在用户角度上使用，发现一些问题，比如输入过滤不严谨，跳转出现一些问题。 今天在对接口的时候，因为我对需要分页的批量数据做了本地化的存储，因此修改动作发生后我提交接口，然后本地是直接对单条数据进行修改，于是 在显示中我修改数据后可以直接显示数据修改成功。但是进行再次测试的时候我进行了一个对比，发现刷新重新获取后台后，获取的列表数据并没有更新，但是对单 条数据进行查询的时候数据已经更新了。后台反应是缓存问题。因此大概了解了后台给的数据也不一定可信的，进行数据校验需要再耐心对比。这几天对接数据的时候因为多个接口都对接，因此后台那边处理一些特定的异常需要debug，造成其它接口访问有些影响。不过今天另一个后台回来开了第二个访问接口，减小了影响。还有就是接口字段的问题，对接的时候有时候一不小心就会有一些问题。这让我思考，之前和别人聊天说node中间件来对后台的数据进行转发。我 觉得如果有个前后端同时协作的接口平台，在上面 前后端都能修改接口规范，字段，结构。然后前端能对接出模拟的数据，后端需要将接口地址接入平台，然后平台能够校验后端接口返回的数据是否和规定的字段相 同，这样就不会有很多对接上的错误了。前端后后台可以同时一边开发一边修改验证。因为修改都是实时通知的。然后有修改接口日志，能够时刻告知双方哪块字段 更改了名称。我觉得能把这个想法接入mock系统。 第一个部门总结技术栈从vue全家桶换成react全家桶，一开始三大疑惑，我的代码写好了放哪，action怎么写，reducer怎么写。幸好团队里有个react很熟练的小伙伴先把脚手架搭起来，然后demo写好，在不断询问中渐渐掌握了react开发的整体流程，在三周之中把技术栈彻底换成了react。但是期间也有一些问题，比如一开始技术栈磨合花去不少时间，因为项目经验相对来说还算多，对整体的流程有个熟悉，但是一开始没有把需求分析文档化，直到第三天才弄完，然后一开始接口文档没有彻底细化，造成后来前后端的一些对接问题，然后后台数据库老崩，前端核心流程没有一开始就走通，等等很多通病，都在整个开发流程中体现了出来。然后后来HR压力面的时候就说我做的慢，作为项目总体负责这个锅我背了。然后是说技术和部门要求不匹配，于是调岗到另一个部门。对我来说部门好像都不怎么介意，毕竟在哪写代码不是写。。。 第二个部门第二个部门虽然只实习了短短一周，但是我验证了之前三周所学，和自家琢磨的一些东西，然后和第二个技术导师在同一个办公室，周围有经验丰富的前端开发，因此问问题，解决问题效率也很快。 第二周实习日报我是直接邮件传给导师，因此从邮件里抄录。。 8-14今日实习内容及完成情况根据项目内容先进行了需求分析。将其书面化整理。然后通过思维导图将任务拆分。然后梳理前后端交互逻辑图。确定数据库字段。然后根据查找的接口文档规范以markdown完成接口字段文档。在完成接口文档的同时，将前后端路由修正为一致。然后将API提取出来，保持一致。下午完成了用户的数据表建立。完成了登录注册登出逻辑。包括后台生成token，前端以Localstroge保持，完成在单页面应用中登录状态的持久化。完成了react基础模块的编写。 下午因为已经有配置好的环境，因此直接先进行核心流程的开发。注册-&gt;登录-&gt;登出。然后考虑到密码明文的不安全，前端传输加了md5的加密模块。然后在github上搜集了关于websocket的一些资料，准备以socket.io为基础进行开发。 明日计划打算早上把页面模块划分完，交互完成。下午将模拟一些操作。然后完成简单的消息推送。再完成任务中的基本要求。 感想需求分析时觉得应该再做一层好友，对在线用户聊天后成为好友，有了这层关系，数据库比较好设计。然后是开发的时候遇到在router render前想以token模拟登陆，发现页面闪跳。而且react 的router的组件生命周期是和react相同的，原本想引入await等请求完毕后再让router判断。后来跳出这个思维，多进行一次简单的判定解决跳转问题。websocket从来没用过，因此今天查资料的时候核心就是代码需要在自己本机上运行，跑通之后对整个代码进行分析，将其划分思想，构建的内容借鉴到自己的项目里。比如jwt的使用。因为之前实习因为react的不熟悉和项目控制的一些误区导致开发缓慢。这次感觉应该能快不少。 8-15今日实习内容及完成情况今天整体完成了聊天的数据库版本。 早上完成了静态界面以及一些交互，逻辑分为选择用户会判断这个用户是否在好友表，如果不在就给提示让用户添加。添加成功，获取两个用户之间的聊天记录。然后一边写界面一遍把接口数据完成。一开始是让后台对应的接口按照接口文档格式模拟数据，然后把token验证加上去，然后加上数据库操作。一共对接完成获取在线人数，添加好友，获取好友列表，获取用户之间聊天历史记录，一对一聊天添加记录。 晚上把整个流程走通，虽然还有一些交互上的问题。会在明天解决。 昨天的目标是今天最好对接一下简单的socket，但是没有达到。只能在明天把东西全部完成。 明日计划先对接socket.io，然后再将修改聊天和撤销聊天功能接口完成。之后是修改一些交互的Bug，然后进行一些容错的处理。再然后是进行一些新功能的添加。以及一些极端情况下的考虑。 感想今天早上能把图切完主要是放弃了对细节的一些考虑，然而下午还是一头扎进了如何让react 中 指定元素的scroll自动滑到底端。然而研究半天没有找到合适方案，因此把这个交互需求先放着，完成接口的编写。 之后是数据库版的聊天室中Mongoose有个问题，官方给的例子中设计schema的时候会有个默认值写法。default固定值或者函数名， 写成 new Date()在服务器启动的时候就会把执行结果当做默认值。因此造成我两个间隔聊天的记录时间戳居然是相同的，然后返回数据的排列是乱的。后来查资料定位到这里的问题，修改成Date.now…大概官方玄学。 8-16今日实习内容及完成情况总体上来说基本需求完成，继续改Bug.下面比较长： 接入socket.io,完成基本功能。然后修复交互的问题。 接入之前的思考： socket接口需要将之前的哪些接口进行替换，哪些数据需要socket接口来进行二次处理。 在基于现有数据库聊天，首先需要 1.完成socket接入到Koa和react，然后模拟一个通信，了解整个流程以及数据处理。 2.登录注册，携带token登录成功后，都需要发起一个给socket服务一个消息告知用户登录。 socket服务维护一个登录对象数组 // socket -&gt; onlineUserList [{ userId:’’, userName:’’, state:’’, }] 之所以加一个state是因为好友列表需要显示所有好友，因此状态必须加上，在线用户前端获取的时候无视就好了，反正退出的时候会自动从数组中删去。 获取好友列表socket -&gt; myFriendsList 因为从数据库中取出来的时候都加了一个state，因此需要做一个循环判断在在线用户组中是否存在，存在的话更改state状态 0是已登录，1是未登录。 [{ userId:’’, userName:’’, state:’’, }] 消息推送这块还需要研究一下怎么针对某个用户进行分发。(ok，已经全部解决) 已经完成了基本需求，接下来需要对一些交互做一些更改。 今天遇到的几个问题，一个是昨天研究的聊天信息自动跳到底部，当1V1聊天完成之后有了灵感，解决了这个问题，然后顺便完成了查看历史消息(置顶),查看最新消息(置底) 并且遇到了一些问题，比如在开发的时候，一开始合并获取在线用户列表，然后发现好友列表也可以一起合并返回,不需要再emit新的请求，因为一次校验成功就能说明权限通过审核。之后更新好友上下线状态的时候一开始打算单独写一个好友下线的动作然后跟着刷新列表，但是写着写着发现不对，因为需要多次对数据库操作。想了一下换了一下逻辑，一开始我两个查询内容都给，好友我只给离线状态的所有成员，然后让前端自己在获取数据的时候循环遍历在线的userId,并自己更改好友状态，这样后台压力减小，前端只需要根据state状态排序，就可以让登录的好友在列表里置顶。一开始我获取列表的接口是传递一个本地token去验证，然后我在react里写一个socket中间件去拦截action，loginwithtoken没问题，因为登录后localstroge已经存在本地，后来发现如果是登录和注册就不行了，因为动作拦截的时候登录状态并没有保存下来，因此动作拦截我就不做登录和注册，因为思考了流程里 一开始我以为维护一个在线人数列表就行了，但是后来发现一对一用户需要将socket给保存下来，直接加入到在线的数组是不靠谱的，因此又维护一个socket数组来保存用户socket连接。 因为一开始的接口文档设计的比较好，接入socket没费多大力气，消息的接受者ID和发起者ID都直接有数据传入，进行一个socket查找，然后再指定发送就行了。然后通过timeago做了一下时间的处理。优化了一下界面。之后是打算先解决一些bug，完成消息撤销和修改。然后往加入图片上传和表情发送的功能。 明日计划完成消息撤销和修改。然后往加入图片上传和表情发送的功能。然后再优化整体，再调整一下交互。然后再加新功能。 感想写完socket对接感觉很棒，玄学问题没出现感觉更棒。之前写的数据库版本给了很大的帮助，对接没多花心思在数据是否出错，是否需要调整等等，数据库设计的比较简单，加快了开发效率。然后是真正意义上学习websocket和socket文档还是周一的早上和对接口的今天下午。感觉搜索资料经验积攒了不少。第一次发现学习效率那么高2333剩下没啥感想，就想先把要求的先全完成，然后我再看看有没有时间加点别的~ 8-17今日实习内容及完成情况完成更多的功能，基本实现大部分需求。下面比较长： 今天的任务是先完成消息的60秒内撤销和修改之前已经有了update_time现在需要是˜把消息撤销接口完善（后来去看接口文档发现已经有了。。。），以及和socket直接通讯，因为不是发送所以可以直接让socket服务处理请求。前端 action 里面也需要加一个动作 editChat修改本地的消息内容 然后是完成聊天中emoji和Img的发送 emoji一开始知道有种方式就是字符串对应emoji，然后发送字符串，显示emoji。但是想试试在发送框里也是emoji。然后发现输入法自带的emoji能直接发送。。。先考虑图片上传吧 图片上传我想了三种方法：1.用封装好的模块2.用node.js自己写一个上传3.利用第三方图床 三种方法有利有弊，为了稳定开发我打算用第一种方式。 然后一个下午都在调试Bug,主要问题是数据socket发过来了但是在reduce里面对于对象数组只更新某个属性，它是判断为相等 比如[{}.{}]这种结构，我记得下午在写后台接口的时候成功过，然后更新到github，后来修改的时候发现用Object.assign一直不更新页面，有时候是数据没更新过来。后来定位到reducer里面的代码，想了很多种方法，最后把更改属性的函数提取到外部执行再返回。成功。 完成了图片上传，前端图片验证 明日计划准备先把后端的图片的逻辑验证了，然后开始修改优化。做PPT 感想遇到玄学BUG，改了一下午，改完~ 8-18今日实习内容及完成情况完成图片上传后端的验证逻辑 添加服务器错误 0 2的统一错误处理 前端添加对应的提示信息 然后优化代码： 1.去除多余 2.格式化 3.整理流程 做PPT 明日计划心跳检测前后端service层建立 socket中间件红点标记，未读聊天 感想需要学习的地方还很多。 session管理方案，以及在业务中一般是如何考量，然后一般用什么方法。 session-stroge cookie 统一权限管理 socket 中间件 airbnb 规范 service 方法抽象 继续学习。","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"实习","slug":"实习","permalink":"http://wiki.haoqiao.me/tags/实习/"},{"name":"CVTE","slug":"CVTE","permalink":"http://wiki.haoqiao.me/tags/CVTE/"},{"name":"技术篇","slug":"技术篇","permalink":"http://wiki.haoqiao.me/tags/技术篇/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"实习","slug":"前端/实习","permalink":"http://wiki.haoqiao.me/categories/前端/实习/"}]},{"title":"Ajax","date":"2017-07-12T02:58:50.000Z","path":"wiki/前端/基础/Ecmascript/Ajax/","text":"概述ajax的全称： Asynchronous Javascript And XML。 异步传输 + js + xml ajax应用主要特点是使用脚本控制http和web服务器进行数据交换， 不会导致页面重载 特点 改善的用户体验, 无刷新更新数据。 - AJAX提供的更丰富的用户体验是其主要优点 减少带宽的使用并增加速度 - AJAX使用客户端脚本来和web服务器通讯， 用JavaScript来交互数据。 使用AJAX能减少网路负载和带宽使用并且只获得你所需的数据。 这样能给你更快的接口和更低的响应时间 支持异步处理 缺点 安全问题, 跨站点脚本攻击、 SQL注入攻击 违背URL和资源定位的初衷 对搜索引擎支持较弱 原理XMLHttpRequest基本用法 XMLHttpRequest readystate四个值： 0: uninitialized， 还没调用open() 1: open， 调用了open()， 但还没调用send() 2: sent， 调用了send()， 但请求还没返回 3: receiving， 收到了部分响应数据 4: complete， 收到了所有的响应数据， 并且可用了 xhr.open(method, url, isAsyn); 1234567891011121314function createXHR() &#123; return new XMLHttpRequest();&#125;var xhr = createXHR();xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; var status = xhr.status; if ((status》 = 200 &amp;&amp; status《 300) || status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert('Request was unsuccessful: ' + xhr.status); &#125; &#125;&#125;;xhr.open('get', 'example.txt', true);xhr.send(null); 原生ajax的请求总结为一下六个步骤 1.创建XHR对象 2.调用open()方法创建请求 3.调用send()方法发送请求 4.onreadychange捕获请求的状态码 5.判断状态码是否成功 6.调用ajax的responseText属性返回数据 json与jsonp的区别 jsonp全名叫做json with padding， 很形象， 就是把json对象用符合js语法的形式包裹起来以使其它网站可以请求得到， 也就是将json数据封装成js文件 json是理想的数据交换格式， 但没办法跨域直接获取， 于是就将json包裹(padding) 在一个合法的js语句中作为js文件传过去。 这就是json和jsonp的区别， json是想要的东西， jsonp是达到这个目的而普遍采用的一种方法， 当然最终获得和处理的还是json。 所以说json是目的， jsonp只是手段。 json总会用到， 而jsonp只有在跨域获取数据才会用到。 理解了json和jsonp的区别之后， 其实ajax里的跨域获取数据就很好理解和实现了， 同源时候并没有什么特别的， 直接取就行， 跨域时候需要拐个弯来达到目的 123456789脚本创建一个 &lt;script&gt; 元素， 地址指向第三方的API网址， 形如： &lt; script src = &quot;http://www.example.net/api?param1=1&amp;param2=2&quot; &gt; &lt; /script&gt; 并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如： callback(&#123;&quot;name&quot;:&quot;hax&quot;,&quot;gender&quot;:&quot;Male&quot;&#125;) 这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。 1234567891011121314151617181920212223242526272829&lt; script type = \"text/javascript\" &gt; /* js 解析返回的格式为 json */ function telljson() &#123; // 创建 xmlhttpRequest 对象 var xmlhttpRequest = new XMLHttpRequest(); //请求URL var url = \"http://localhost:18080/servlet/Servlet3?aa=10\"; // 将请求过程绑定到 open 方法 xmlhttpRequest.open(\"POST\", url, true); // 发送请求 xmlhttpRequest.send(url); // readstate 就是一个xmlhttprequest 对象的一个属性用来记录服务端响应的状态 var readstate = xmlhttpRequest.readyState; alert(\"请求准备状态：\" + readstate); // status 服务器执行的状态 var status = xmlhttpRequest.status; alert(\"请求发送结果\" + status); // responseText 对象为xmlhttpRequest 对象的一个属性，用来以字符串的方式存储服务器端返回的值。 var text = xmlhttpRequest.responseText; alert(\"json text: \" + text); // 获取json 返回值 // 那边传的是json对象的格式的一个字符串，在前台首先将字符串转化为一个json格式的js对象 var json = eval(\"(\" + text + \")\"); // 通过eval() 方法将json格式的字符串转化为js对象，并进行解析获取内容 alert(\"age:\" + json.age + \"age1:\" + json.age1); &#125;; &lt; /script&gt; JSONP 的缺点以及安全隐患 它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 JSONP是一种脚本注入(Script Injection)行为，所以有一定的安全隐患。 Ajax的兼容性问题 document.getElementById替代document.all（ie适用） 集合[]替代()（ie适用） target替代srcElement;parentNode替代parentElement（parentNode ie适用） 4,node.parentNode.removeChild(node)替代removeNode(this)（ie适用） DOMMouseScroll替代onmousewheel;-e.detail替代event.wheelDelta addEventListener替代attachEvent;removeEventListener替代detachEvent e.preventDefault()替代event.returnValue=false;e.stopPropagation()替代event.cancelBubble=true style.top、style.left等严格检查”px”单位（加”px” ie适用） style=”-moz-opacity:0.9”替代style=”filter:alpha(opacity=90)”;无其它filter style.cursor=”pointer”替代style.cursor=”hand”（ie适用） title替代alt（ie适用） 所有的空间在引用时都要这样引用：document.getElementById（“XX”）","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"Ajax","slug":"Ajax","permalink":"http://wiki.haoqiao.me/tags/Ajax/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"模块化","date":"2017-07-12T02:58:50.000Z","path":"wiki/前端/基础/Ecmascript/模块化/","text":"AMD全称”Asynchronous Module Definition”，称为异步模块加载规范 规范其实只有一个主要接口 define(id?, dependencies?, factory)，它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置 优点： 适合在浏览器环境中异步加载模块 可以并行加载多个模块缺点： 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅 不符合通用的模块化思维方式，是一种妥协的实现实现： RequireJS 一般应用在浏览器端提前执行依赖 - 尽早执行requireJS 是它的实现 AMD依赖前置，js可以方便知道依赖模块是谁，立即加载 AMD 同样都是异步加载模块，AMD在加载模块完成后就会执行该模块（不是回调函数），所有模块都加载执行完后才会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。 CMD全称”Common Module Definition”，称为通用模块加载规范 按需执行依赖 - 懒执行，seaJS 是它的实现 AMD和CMD的区别AMD和CMD最大的区别是对依赖模块的执行时机处理不同 CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块 CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的 CommonJS该规范的核心思想是允许模块通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口 优点： 服务器端模块便于重用 NPM 中已经有将近20万个可以使用模块包 简单并容易使用缺点： 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的 不能非阻塞的并行加载多个模块 ES6 模块 ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。 CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"模块化","slug":"模块化","permalink":"http://wiki.haoqiao.me/tags/模块化/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"跨域","date":"2017-07-12T02:58:50.000Z","path":"wiki/前端/基础/Ecmascript/跨域/","text":"概述 如果两个页面拥有相同的协议（protocol），端口（如果指定），和主机，那么这两个页面就属于同一个源（origin），JavaScript 允许这种同源页面的数据互相通信。对于端口和协议的不同，只能通过后台来解决 跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但返回结果被浏览器拦截了HTML里面所有带src属性的标签都可以跨域，如iframe，img，script 《a href=””》《/a》 《img src=”” alt=””/》 《link rel=”stylesheet” href=””/》 《iframe src=”” frameborder=”0”》《/iframe》 《script src = “”》《/script》 解决方案对于主域相同而子域不同document.domain+iframe的设置 12345678910111213www.a.com其实是二级域名 www.a.com上的a.html document.domain = &apos;a.com&apos;;var ifr = document.createElement(&apos;iframe&apos;);ifr.src = &apos;http://script.a.com/b.html&apos;;ifr.style.display = &apos;none&apos;;document.body.appendChild(ifr);ifr.onload = function() &#123; var doc = ifr.contentDocument || ifr.contentWindow.document; alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue);&#125;;script.a.com上的b.html document.domain = &apos;a.com’; window.namewindow.postMessage 跨文档消息传输功能 原理：HTML5允许窗口之间发送消息 限制：浏览器需要支持HTML5，获取窗口句柄后才能相互通信 这是一个安全的跨域通信方法，postMessage(message,targetOrigin)也是HTML5引入的特性。 可以给任何一个window发送消息，不论是否同源。第二个参数可以是*但如果你设置了一个URL但不相符，那么该事件不会被分发。 12345678// URL: http://a.com/foovar win = window.open(&apos;http://b.com/bar&apos;);win.postMessage(&apos;Hello, bar!&apos;, &apos;http://b.com&apos;);// URL: http://b.com/barwindow.addEventListener(&apos;message&apos;,function(event) &#123; console.log(event.data);&#125;); JSONP跨域 JSONP（JSON with Padding）是资料格式 JSON 的一种“使用模式”，可以让网页从别的网域要资料，原理是HTML的script标签可以加载并执行其他域JS文件。站点B把要提供的数据作为参数传给一个站点A定义的全局函数，站点A引用这个文件就可以跨域获取数据了，A站还可以把少量参数放在script标签的src里提交给B站 跨域资源共享（CORS） 原理：服务器设置Access-Control-Allow-OriginHTTP响应头之后，浏览器将会允许跨域请求 限制：浏览器需要支持HTML5，可以支持POST，PUT等方法 前面提到的跨域手段都是某种意义上的Hack， HTML5标准中提出的跨域资源共享（Cross Origin Resource Share，CORS）才是正道。 它支持其他的HTTP方法如PUT, POST等，可以从本质上解决跨域问题。 例如，从http://a.com要访问http://b.com的数据，通常情况下Chrome会因跨域请求而报错：错误原因是被请求资源没有设置Access-Control-Allow-Origin，所以我们在b.com的服务器中设置这个响应头字段即可：Access-Control-Allow-Origin: * # 允许所有域名访问，或者Access-Control-Allow-Origin: http://a.com # 只允许所有域名访问 为 xhr 设置 withCredentials 后 CORS 方法跨域还可 携带Cookie","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"跨域","slug":"跨域","permalink":"http://wiki.haoqiao.me/tags/跨域/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"事件","date":"2017-07-12T02:58:50.000Z","path":"wiki/前端/基础/Ecmascript/事件/","text":"事件流 事件捕获 最上级接收到事件然后一层层向下广播直到最具体的元素接收到事件。 它的用意是在事件到达目标前提前捕获然后处理 处于目标阶段 事件冒泡 事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点 dom0 和 dom2 区别 dom0 如果定义了两个dom0级事件，dom0级事件会覆盖 dom2dom2不会覆盖，会依次执行 dom0和dom2可以共存，不互相覆盖，但是dom0之间依然会覆盖 DOM0级事件处理程序 12var btn = document.getElementById(&quot;btn&quot;) btn.onclick = function()&#123; alert(&quot;clicked&quot;) &#125; btn.onclick = null DOM2级事件处理程序 addEventListener():可以为元素添加多个事件处理程序，触发时会按照添加顺序依次调用。 1234var btn = document.getElementById(&quot;btn”) btn.addEventListener(&quot;click&quot;,function()&#123; alert(this.id) &#125;,false) `removeEventListener`只能移除有事件名的，匿名函数将无法移除 事件模型原始事件模型 DOM0级：事件发生后没有传播的概念，没有事件流。事件发生，马上处理 优点：所有浏览器都兼容 缺点： 1 逻辑与显示没有分离；2 相同事件的监听函数只能绑定一个，后绑定的会覆盖掉前面的，如：a.onclick = func1; a.onclick = func2;将只会执行func2中的内容。3 无法通过事件的冒泡、委托等机制（后面系列会讲到）完成更多事情。 IE事件模型绑定监听函数的方式：attachEvent(“eventType”,”handler”) 其中eventType表示事件类型，如onclick，须在事件类型前加“on”。 解除事件监听的方式：detachEvent(“eventType”,”handler”); 优点: 实现逻辑和显示分离；能够绑定多个监听函数；有事件冒泡和委托机制。 缺点：IE事件模型只适用于IE浏览器，不兼容其他浏览器。 DOM2事件模型addEventListener(“eventType”,”handler”,true|false) 其中eventType表示事件类型，如click，注意事件类型前面不用加“on”，true|false表示绑定的事件监听器在哪个阶段触发。true表示捕获阶段触发，false表示在冒泡阶段触发 阻止事件冒泡标准规范中的方法为event.stopPropagation()IE中的方法为event.cancelBubble=true 阻止浏览器默认行为123456789 function stopDefault(e) &#123; //阻止默认浏览器动作(W3C) if (e &amp;&amp; e.preventDefault) e.preventDefault(); //IE中阻止函数器默认动作的方式 else window.event.returnValue = false; return false;&#125; 事件处理IE事件处理1234.attachEvent(“onclick”,handler).detachEvent(“onclick”,handler) DOM2事件处理1234.addEventListener(“click”,handler,false) 第三个参数false表示冒泡阶段处理，true表示捕获阶段处理.removeEventListener(“click”,handler,false) 跨浏览器事件处理程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var EventUtil = &#123; getEvent: function(event) &#123; return event ? event : window.event &#125;, getTarget:function(event)&#123; return event.target || event.srcElement &#125;, addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false) &#125; else if (element.attachEvent) &#123; element.attachEvent(\"on\" + type, handler) &#125; else &#123; element[\"on\" + type] = handler &#125; &#125;, removeHandler: function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false) &#125; else if (element.detachEvent) &#123; element.detachEvent(\"on\" + type, handler) &#125; else &#123; element[\"on\" + type] = null &#125; &#125;, preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault() &#125; else &#123; event.returnValue = false &#125; &#125;, stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation() &#125; else &#123; event.cancelBubble = false &#125; &#125;&#125;var test = document.querySelector('.test')EventUtil.addHandler(test,\"click\",function()&#123; alert(\"2333\")&#125;) 事件委托技术 靠事件的冒泡机制来实现 事件委托技术能让你避免对特定的每个节点添加事件监听器；相反，事件监听器是被添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件 优点 可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒 可以实现当新增子对象时无需再次对其绑定事件，对于动态内容部分尤为合适 // 获取父节点，并为它添加一个click事件 document.getElementById(&quot;parent-list&quot;).addEventListener(&quot;click&quot;,function(e) { // 检查事件源e.targe是否为Li if(e.target &amp;&amp; e.target.nodeName.toUpperCase == &quot;LI&quot;) { // 真正的处理过程在这里 console.log(&quot;List item &quot;,e.target.id.replace(&quot;post-&quot;),&quot; was clicked!&quot;); } }); //javascript是区分大小写的语言，HTML并不区分大小写 手写委托解决浏览器兼容性的方法就是检测浏览器类型 先判断DOM2再判断IE最后DOM0 12345678910111213141516171819202122232425262728293031323334353637383940414243// 跨浏览器事件处理var eventUtil=&#123; // 添加句柄 addHandler:function(element,type,handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type,handler,false); &#125;else if(element.attachEvent)&#123; element.attachEvent('on'+type,handler); &#125;else&#123; // element.'on'+type // 连接属性时可以用.的时候都可以用中括号 // 不能用.连接字符串 element['on'+type]=handler; &#125; &#125;, // 删除句柄 removeHandler:function(element,type,handler)&#123; if(element.addEventListener)&#123; element.removeEventListener(type,handler,false); &#125;else if(element.attachEvent)&#123; element.detachEvent('on'+type,handler); &#125;else&#123; // element.'on'+type // 连接属性时可以用.的时候都可以用中括号 // 不能用.连接字符串 element['on'+type]=null; &#125; &#125;&#125;参数解析： parent：需要绑定事件的父元素 type：绑定的事件类型 Node：事件目标 handler：事件回调函数 function delegateEvent(parent, type, Node, handler) &#123; eventUtils.addHandler(parent, type, function() &#123; var event = arguments[0] || window.event, // 判断IE兼容性 target = event.target || event.srcElement; if (target &amp;&amp; target.tagName === Node.toUpperCase()) &#123; handler.call(target, event); &#125; &#125;); &#125; 触发DOM上的事件时都会产生一个事件对象Event触发事件的参数为event 常见属性 Event.type 获取事件类型 Event.target stopPropagation（）方法 用于阻止事件冒泡preventDefault 阻止事件的默认行为例如 阻止a标签的跳转 IE中事件对象 type srcELement 获取事件目标 cancelBubble属性 阻止事件冒泡 设置true表示阻止冒泡 设置false不阻止冒泡 returnValue属性 用于阻止事件默认行为 设置为false表示阻止事件默认行为 event loop JavaScript语言的一大特点就是单线程event loop是实现异步的一种机制主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。 自己实现一个事件机制，js自定义事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138var EventTarget = function() &#123; this._listener = &#123;&#125;;&#125;;EventTarget.prototype = &#123; constructor: this, addEvent: function(type, fn) &#123; if (typeof type === \"string\" &amp;&amp; typeof fn === \"function\") &#123; if (typeof this._listener[type] === \"undefined\") &#123; this._listener[type] = [fn]; &#125; else &#123; this._listener[type].push(fn); &#125; &#125; return this; &#125;, addEvents: function(obj) &#123; obj = typeof obj === \"object\" ? obj : &#123;&#125;; var type; for (type in obj) &#123; if (type &amp;&amp; typeof obj[type] === \"function\") &#123; this.addEvent(type, obj[type]); &#125; &#125; return this; &#125;, fireEvent: function(type) &#123; if (type &amp;&amp; this._listener[type]) &#123; var events = &#123; type: type, target: this &#125;; for (var length = this._listener[type].length, start = 0; start &lt; length; start += 1) &#123; this._listener[type][start].call(this, events); &#125; &#125; return this; &#125;, fireEvents: function(array) &#123; if (array instanceof Array) &#123; for (var i = 0, length = array.length; i &lt; length; i += 1) &#123; this.fireEvent(array[i]); &#125; &#125; return this; &#125;, removeEvent: function(type, key) &#123; var listeners = this._listener[type]; if (listeners instanceof Array) &#123; if (typeof key === \"function\") &#123; for (var i = 0, length = listeners.length; i &lt; length; i += 1) &#123; if (listeners[i] === key) &#123; listeners.splice(i, 1); break; &#125; &#125; &#125; else if (key instanceof Array) &#123; for (var lis = 0, lenkey = key.length; lis &lt; lenkey; lis += 1) &#123; this.removeEvent(type, key[lenkey]); &#125; &#125; else &#123; delete this._listener[type]; &#125; &#125; return this; &#125;, removeEvents: function(params) &#123; if (params instanceof Array) &#123; for (var i = 0, length = params.length; i &lt; length; i += 1) &#123; this.removeEvent(params[i]); &#125; &#125; else if (typeof params === \"object\") &#123; for (var type in params) &#123; this.removeEvent(type, params[type]); &#125; &#125; return this; &#125;&#125;;function EventTarget() &#123; this.handlers = &#123;&#125;; //存储事件处理程序,由n个键值对组成,键表示事件名,值是一个由事件处理程序组成的数组&#125;EventTarget.prototype = &#123; constructor: EventTarget, //添加事件 addHandler: function(type, handler) &#123; if (typeof this.handlers[type] == \"undefined\") &#123; this.handlers[type] = []; &#125; this.handlers[type].push(handler); &#125;, //触发事件 fire: function(event) &#123; if (!event.target) &#123; event.target = this; &#125; if (this.handlers[event.type] instanceof Array) &#123; var handlers = this.handlers[event.type]; for (var i = 0, len = handlers.length; i &lt; len; i++) &#123; //将event传递给事件处理程序,event.target代表对象本身, event.type代表事件名, 你可以根据情况为添加event属性 handlers[i](event); &#125; &#125; &#125;, //移除事件 removeHandler: function(type, handler) &#123; if (this.handlers[type] instanceof Array) &#123; var handlers = this.handlers[type]; for (var i = 0, len = handlers.length; i &lt; len; i++) &#123; if (handlers[i] == handler) &#123; break; &#125; &#125; handlers.splice(i, 1); &#125; &#125;&#125;;","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"事件","slug":"事件","permalink":"http://wiki.haoqiao.me/tags/事件/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"JS代码片段","date":"2017-07-12T02:58:50.000Z","path":"wiki/前端/基础/Ecmascript/JS代码片段/","text":"用原生js实现复选框选择以及全选非全选功能123456789101112131415161718192021222324252627282930313233&lt;input type=\"checkbox\" id=\"checkItem\"&gt;全选/全不选 &lt;h3&gt;爱好&lt;/h3&gt; &lt;input type=\"checkbox\" name=\"item\"&gt;看书 &lt;input type=\"checkbox\" name=\"item\"&gt;听音乐 &lt;input type=\"checkbox\" name=\"item\"&gt;打球 &lt;input type=\"checkbox\" name=\"item\"&gt;散步 &lt;input type=\"checkbox\" name=\"item\"&gt;写代码 var checkItem = document.getElementById(\"checkItem\").onclick = function() &#123; var itemsElement = document.getElementsByName(\"item\"); for (var i = 0; i &lt; itemsElement.length; i++) &#123; var itemElement = itemsElement[i]; if (this.checked) &#123; itemElement.checked = \"checked\"; &#125; else &#123; itemElement.checked = null; &#125; &#125; &#125; 实现一个querySelectorAll的功能，函数长这样querySelect(el, className)123456789101112131415function querySelect(el,className)&#123; var children = el.children; var result = []; if(el.classList.contains(className))&#123; result.push(el); &#125; for(var i; i&lt;children.length; i++)&#123; var child = children[i]; var arr = querySelect(child,className); result.push.apply(result, arr); &#125; return result;&#125; 实现一个暴露内部变量，而且外部可以访问修改的函数（get和set，闭包实现）1234567891011121314151617181920212223242526var person = function()&#123; //变量作用域为函数内部，外部无法访问 var name = \"default\"; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125; &#125;(); print(person.name);//直接访问，结果为undefined print(person.getName()); person.setName(\"abruzzi\"); print(person.getName()); 得到结果如下： undefined default abruzzi 对于页面上的任意元素，当鼠标指针位于其上时，在元素旁边显示该元素的class属性（可以使用任意库）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .tip&#123; position: absolute; background-color: red; color: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;/h1&gt; Hello, this is a snippet. &lt;p class=\"p\"&gt;hover op&lt;/p&gt; &lt;div class=\"test\"&gt;hover test&lt;/div&gt; &lt;div class=\"ul\"&gt; &lt;h1&gt;hover ul&lt;/h1&gt; &lt;li class=\"li\"&gt; hover li &lt;/li&gt; &lt;/div&gt; &lt;div class=\"tip\"&gt;vvv&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://libs.baidu.com/jquery/1.9.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; /* 对于页面上的任意元素，当鼠标指针位于其上时，在元素旁边显示该元素的class属性（可以使用任意库） */ document.addEventListener(\"mouseover\",function(e)&#123; console.log(e) var tip = document.querySelector('.tip'); tip.innerHTML = e.target.className; tip.style.left = e.x + \"px\"; tip.style.top = e.y + \"px\"; &#125;,false) &lt;/script&gt;&lt;/html&gt; 写一个递归。就是每隔5秒调用一个自身，一共100次12345678910111213(function () &#123; var z = 0 var j = 0 var timer = setTimeout(function() &#123; if (j &lt; 100)&#123; timer = setTimeout(arguments.callee, 5000) z++; console.log(z) &#125; &#125;, 5000)&#125;)() 原生JS实现addClass,removeClass,toggleClass.1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style type=\"text/css\"&gt; div.testClass&#123; background-color:gray; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; function hasClass(obj, cls) &#123; return obj.className.match(new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)')); &#125; function addClass(obj, cls) &#123; if (!this.hasClass(obj, cls)) obj.className += \" \" + cls; &#125; function removeClass(obj, cls) &#123; if (hasClass(obj, cls)) &#123; var reg = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)'); obj.className = obj.className.replace(reg, ' '); &#125; &#125; function toggleClass(obj,cls)&#123; if(hasClass(obj,cls))&#123; removeClass(obj, cls); &#125;else&#123; addClass(obj, cls); &#125; &#125; function toggleClassTest()&#123; var obj = document. getElementById('test'); toggleClass(obj,\"testClass\"); &#125; &lt;/script&gt; &lt;body&gt; &lt;div id = \"test\" style = \"width:250px;height:100px;\"&gt; sssssssssssss &lt;/div&gt; &lt;input type = \"button\" value = \"toggleClassTest\" onclick = \"toggleClassTest();\" /&gt; &lt;/body&gt; js轮播实现思路定义一个轮播组件，给用户使用时需要提供哪些对外API和属性 1234567891011121314151617181920interval 自动轮播间隔direction 从左到右还是从右到左pause 如果设置为“悬停”，请暂停鼠标滚轮上的旋转木马循环，并在鼠标滚轮上恢复轮播的循环。如果设置为null，则在盘旋盘上悬停不会暂停。keyboard 是否接受键盘事件而且它可以作为触发器进行事件触发，比如：.carousel(&apos;prev&apos;)Cycles to the previous item..carousel(&apos;next&apos;)Cycles to the next item..carousel(&apos;pause&apos;)Stops the carousel from cycling through items. 日历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859body,html&#123;padding: 0;margin: 0;font-size: 14px;color:#000;&#125;table &#123;border-collapse: collapse;width: 100%;table-layout: fixed;&#125;td,th &#123;border: 1px solid #e1e1e1;padding: 0;height: 20px;line-height: 20px;text-align: center;&#125;.current&#123;color:red;&#125;&lt;table&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;一&lt;/th&gt;&lt;th&gt;二&lt;/th&gt;&lt;th&gt;三&lt;/th&gt;&lt;th&gt;四&lt;/th&gt;&lt;th&gt;五&lt;/th&gt;&lt;th&gt;六&lt;/th&gt;&lt;th&gt;日&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;// 获取指定年-月 有多少天function getDaysInOneMonth(year, month)&#123; month = parseInt(month, 10); var d= new Date(year, month, 0); return d.getDate(); &#125; // return Mon Tue Wed Thu Fri Sat Sun// 获取第一天星期几function getWeek(year,month)&#123; var day = new Date(year,month-1,1) var map = &#123; \"Mon\" : 1, \"Tue\" : 2, \"Wed\" : 3, \"Thu\" : 4, \"Fri\" : 5, \"Sat\" : 6, \"Sun\" : 7, &#125; return map[day.toString().split(\" \")[0]]&#125;function calendar(year, month) &#123; var tds = document.querySelectorAll('tbody td'), i; var start = getWeek(year,month) -1 var j = 0 var d = new Date() for(i = 0; i &lt; tds.length; ++i) &#123; if(i &gt;= start &amp;&amp; j&lt;getDaysInOneMonth(year,month))&#123; j++ tds[i].innerHTML = j; if(j == d.getDate())&#123; tds[i].className = \"current\" &#125; &#125; &#125;&#125;calendar(2017,4); 编写一个元素拖拽的插件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;body&gt; &lt;div id=\"box\"&gt; &lt;div id=\"head\"&gt;我是可拖拽区域&lt;/div&gt; &lt;div id=\"body\"&gt;我是主体部分&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;// target 拖拽目标id， moveTarget 移动目标id// how to use// drag(targetId, moveTargetId)// targetId: 触发拖拽操作的区域id// moveTargetId: 拖拽需要移动的区域id// ----- 注意 ------// 会给moveTarget节点添加user-select属性，值为nonevar drag = function(target, moveTarget) &#123; target = document.getElementById(target); target.style.cursor = 'all-scroll'; moveTarget = document.getElementById(moveTarget); //拖拽区域可以选中文字会产生影响，所以设置无法选中文字 ['-moz-','-webkit-','-ms-','-khtml-',''].map(function(prefix) &#123; moveTarget.style[prefix + 'user-select'] = 'none'; &#125;); // 设置position:absolute moveTarget.style.position = 'absolute'; var fnDown = function(e) &#123; e = e || window.event; var disX = e.clientX - moveTarget.offsetLeft, disY = e.clientY - moveTarget.offsetTop; // 防止如果其他功能也设置了onmousemove和onmouseup,先保存起来，drag结束再重新恢复 var previousOnmousemove = document.onmousemove, previousOnmouseup = document.onmouseup; document.onmousemove = function(e) &#123; e = e || window.event; fnMove(e, disX, disY); &#125;; document.onmouseup = function() &#123; console.log('mouseup'); document.onmousemove = previousOnmousemove; document.onmouseup = previousOnmouseup; &#125;; console.log('mousedown'); &#125;; var fnMove = function(e, disX, disY) &#123; var l = e.clientX - disX, t = e.clientY - disY, // 这里踩了一个大坑，以为document.documentElement.clientHeight和document.body.clientHeight是一样的 // 都是获取浏览器视窗的高度。但不一样， // document.documentElement.clientHeight获取浏览器窗口高度 // document.body.clientHeight 获取body的高度，这时如果body高度比较低就会出错了 // 所以把document.documentElement.clientHeight放到前面 winW = document.documentElement.clientWidth||document.body.clientWidth, winH = document.documentElement.clientHeight||document.body.clientHeight, maxW = winW - moveTarget.offsetWidth, maxH = winH - moveTarget.offsetHeight; // console.log(document.documentElement.clientHeight + ' ' + document.body.clientHeight); if (l &lt; 0) &#123; l = 0; &#125; else if (l &gt; maxW) &#123; l = maxW; &#125; if (t &lt; 0) &#123; t = 0; &#125; else if (t &gt; maxH) &#123; t = maxH; &#125; moveTarget.style.left = l + 'px'; moveTarget.style.top = t + 'px'; &#125;; target.onmousedown = fnDown;&#125;;&lt;/script&gt;&lt;script&gt;drag('head', 'box');&lt;/script&gt;#box &#123; width: 400px; height: 300px; background-color: lightgray; position: absolute; top: 100px; left: 400px; &#125; #head &#123; text-align: center; line-height: 50px; height: 50px; background-color: rgb(196, 94, 227); &#125; #body &#123; text-align: center; margin-top: 10px; &#125; 编写一个contextmenu的插件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290html:&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Context Menu&lt;/title&gt; &lt;style&gt; /* Page */ html &#123; width: 100%; height: 100%; background: radial-gradient(circle, #fff 0%, #a6b9c1 100%) no-repeat; &#125; .container &#123; left: 0; margin: auto; position: absolute; top: 20%; width: 100%; text-align: center; &#125; h1, h2 &#123; color: #555; &#125; /* Menu */ .menu &#123; position: absolute; width: 200px; padding: 2px; margin: 0; border: 1px solid #bbb; background: #eee; background: -webkit-linear-gradient(to bottom, #fff 0%, #e5e5e5 100px, #e5e5e5 100%); background: linear-gradient(to bottom, #fff 0%, #e5e5e5 100px, #e5e5e5 100%); z-index: 100; border-radius: 3px; box-shadow: 1px 1px 4px rgba(0, 0, 0, .2); opacity: 0; -webkit-transform: translate(0, 15px) scale(.95); transform: translate(0, 15px) scale(.95); transition: transform 0.1s ease-out, opacity 0.1s ease-out; pointer-events: none; &#125; .menu-item &#123; display: block; position: relative; margin: 0; padding: 0; white-space: nowrap; &#125; .menu-btn &#123; display: block; color: #444; font-family: 'Roboto', sans-serif; font-size: 13px; cursor: pointer; border: 1px solid transparent; white-space: nowrap; padding: 6px 8px; border-radius: 3px; &#125; button.menu-btn &#123; background: none; line-height: normal; overflow: visible; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; width: 100%; text-align: left; &#125; a.menu-btn &#123; outline: 0 none; text-decoration: none; &#125; .menu-text &#123; margin-left: 25px; &#125; .menu-btn .fa &#123; position: absolute; left: 8px; top: 50%; -webkit-transform: translateY(-50%); transform: translateY(-50%); &#125; .menu-item:hover &gt; .menu-btn &#123; color: #fff; outline: none; background-color: #2E3940; background: -webkit-linear-gradient(to bottom, #5D6D79, #2E3940); background: linear-gradient(to bottom, #5D6D79, #2E3940); border: 1px solid #2E3940; &#125; .menu-item.disabled &#123; opacity: .5; pointer-events: none; &#125; .menu-item.disabled .menu-btn &#123; cursor: default; &#125; .menu-separator &#123; display: block; margin: 7px 5px; height: 1px; border-bottom: 1px solid #fff; background-color: #aaa; &#125; .menu-item.submenu::after &#123; content: \"\"; position: absolute; right: 6px; top: 50%; -webkit-transform: translateY(-50%); transform: translateY(-50%); border: 5px solid transparent; border-left-color: #808080; &#125; .menu-item.submenu:hover::after &#123; border-left-color: #fff; &#125; .menu .menu &#123; top: 4px; left: 99%; &#125; .show-menu, .menu-item:hover &gt; .menu &#123; opacity: 1; -webkit-transform: translate(0, 0) scale(1); transform: translate(0, 0) scale(1); pointer-events: auto; &#125; .menu-item:hover &gt; .menu &#123; -webkit-transition-delay: 300ms; transition-delay: 300ms; &#125; &lt;/style&gt;&lt;/head&gt;&lt;menu class=\"menu\"&gt; &lt;li class=\"menu-item\"&gt; &lt;button type=\"button\" class=\"menu-btn\"&gt; &lt;i class=\"fa fa-folder-open\"&gt;&lt;/i&gt; &lt;span class=\"menu-text\"&gt;Open&lt;/span&gt; &lt;/button&gt; &lt;/li&gt; &lt;li class=\"menu-item disabled\"&gt; &lt;button type=\"button\" class=\"menu-btn\"&gt; &lt;span class=\"menu-text\"&gt;Open in New Window&lt;/span&gt; &lt;/button&gt; &lt;/li&gt; &lt;li class=\"menu-separator\"&gt;&lt;/li&gt; &lt;li class=\"menu-item\"&gt; &lt;button type=\"button\" class=\"menu-btn\"&gt; &lt;i class=\"fa fa-reply\"&gt;&lt;/i&gt; &lt;span class=\"menu-text\"&gt;Reply&lt;/span&gt; &lt;/button&gt; &lt;/li&gt; &lt;li class=\"menu-item\"&gt; &lt;button type=\"button\" class=\"menu-btn\"&gt; &lt;i class=\"fa fa-star\"&gt;&lt;/i&gt; &lt;span class=\"menu-text\"&gt;Favorite&lt;/span&gt; &lt;/button&gt; &lt;/li&gt; &lt;li class=\"menu-item submenu\"&gt; &lt;button type=\"button\" class=\"menu-btn\"&gt; &lt;i class=\"fa fa-users\"&gt;&lt;/i&gt; &lt;span class=\"menu-text\"&gt;Social&lt;/span&gt; &lt;/button&gt; &lt;menu class=\"menu\"&gt; &lt;li class=\"menu-item\"&gt; &lt;button type=\"button\" class=\"menu-btn\"&gt; &lt;i class=\"fa fa-comment\"&gt;&lt;/i&gt; &lt;span class=\"menu-text\"&gt;Comment&lt;/span&gt; &lt;/button&gt; &lt;/li&gt; &lt;li class=\"menu-item submenu\"&gt; &lt;button type=\"button\" class=\"menu-btn\"&gt; &lt;i class=\"fa fa-share\"&gt;&lt;/i&gt; &lt;span class=\"menu-text\"&gt;Share&lt;/span&gt; &lt;/button&gt; &lt;menu class=\"menu\"&gt; &lt;li class=\"menu-item\"&gt; &lt;button type=\"button\" class=\"menu-btn\"&gt; &lt;i class=\"fa fa-twitter\"&gt;&lt;/i&gt; &lt;span class=\"menu-text\"&gt;Twitter&lt;/span&gt; &lt;/button&gt; &lt;/li&gt; &lt;li class=\"menu-item\"&gt; &lt;button type=\"button\" class=\"menu-btn\"&gt; &lt;i class=\"fa fa-facebook-official\"&gt;&lt;/i&gt; &lt;span class=\"menu-text\"&gt;Facebook&lt;/span&gt; &lt;/button&gt; &lt;/li&gt; &lt;li class=\"menu-item\"&gt; &lt;button type=\"button\" class=\"menu-btn\"&gt; &lt;i class=\"fa fa-google-plus\"&gt;&lt;/i&gt; &lt;span class=\"menu-text\"&gt;Google Plus&lt;/span&gt; &lt;/button&gt; &lt;/li&gt; &lt;li class=\"menu-item\"&gt; &lt;button type=\"button\" class=\"menu-btn\"&gt; &lt;i class=\"fa fa-envelope\"&gt;&lt;/i&gt; &lt;span class=\"menu-text\"&gt;Email&lt;/span&gt; &lt;/button&gt; &lt;/li&gt; &lt;/menu&gt; &lt;/li&gt; &lt;/menu&gt; &lt;/li&gt; &lt;li class=\"menu-separator\"&gt;&lt;/li&gt; &lt;li class=\"menu-item\"&gt; &lt;button type=\"button\" class=\"menu-btn\"&gt; &lt;i class=\"fa fa-download\"&gt;&lt;/i&gt; &lt;span class=\"menu-text\"&gt;Save&lt;/span&gt; &lt;/button&gt; &lt;/li&gt; &lt;li class=\"menu-item\"&gt; &lt;button type=\"button\" class=\"menu-btn\"&gt; &lt;i class=\"fa fa-edit\"&gt;&lt;/i&gt; &lt;span class=\"menu-text\"&gt;Rename&lt;/span&gt; &lt;/button&gt; &lt;/li&gt; &lt;li class=\"menu-item\"&gt; &lt;button type=\"button\" class=\"menu-btn\"&gt; &lt;i class=\"fa fa-trash\"&gt;&lt;/i&gt; &lt;span class=\"menu-text\"&gt;Delete&lt;/span&gt; &lt;/button&gt; &lt;/li&gt;&lt;/menu&gt;&lt;div class=\"container\"&gt; &lt;h1&gt;Context Menu&lt;/h1&gt; &lt;h2&gt;(right-click anywhere)&lt;/h2&gt;&lt;/div&gt;&lt;script src=\"./two.js\"&gt; &lt;/script&gt;&lt;/html&gt;js:var menu = document.querySelector('.menu');function showMenu(x, y)&#123; menu.style.left = x + 'px'; menu.style.top = y + 'px'; menu.classList.add('show-menu');&#125;function hideMenu()&#123; menu.classList.remove('show-menu');&#125;function onContextMenu(e)&#123; e.preventDefault(); showMenu(e.pageX, e.pageY); document.addEventListener('mousedown', onMouseDown, false);&#125;function onMouseDown(e)&#123; hideMenu(); document.removeEventListener('mousedown', onMouseDown);&#125;document.addEventListener('contextmenu', onContextMenu, false); 一个字符串hello(world(ni(hao(shijie)))),找出第n个括号中的内容123456str = &quot;hello(world(ni(hao(shijie))))&quot;.match(/([^()]+)/gi);str[n](?:[a-z]*\\()&#123;3&#125;([a-z]*\\))&#123;3&#125; 懒加载 对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载当访问一个页面的时候，先把img元素或是其他元素的背景图片路径替换成loading图片地址（这样就只需请求一次） 等到一定条件（这里是页面滚动到一定区域），用实际存放img地址的laze-load属性的值去替换src属性，即可实现’懒加载’。//即使img的src值为空，浏览器也会对服务器发送请求。所以平时做项目的时候，如果img没有用到src，就不要出现src这个属性 1234567891011121314151617181920var num = document.getElementsByTagName('img').length; var img = document.getElementsByTagName(\"img\"); var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 lazyload(); //页面载入完毕加载可是区域内的图片 window.onscroll = lazyload; function lazyload() &#123; //监听页面滚动事件 var seeHeight = document.documentElement.clientHeight; //可见区域高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (var i = n; i &lt; num; i++) &#123; if (img[i].offsetTop ... seeHeight + scrollTop) &#123; if (img[i].getAttribute(\"src\") == \"default.jpg\") &#123; img[i].src = img[i].getAttribute(\"data-src\"); &#125; n = i + 1; &#125; &#125; &#125; js实现一个图片懒加载插件 高性能滚动 scroll 及页面渲染优化原理与实例 给定一个元素获取它相对于视图窗口的坐标(?)实现一个常见的移动端三栏布局。上下定高且固定fix，中间栏自适应高度且可以滚动(?)百度的自动补全的搜索框，需要实现用鼠标和键盘上下键都能选取补全列表中的item(?)仿百度实时下拉搜索框,源码在这里 瀑布流(?) 瀑布流布局主要分为两部分： 1) 数据块排列，算法步骤简述下:初始化时，对容器中已有数据块元素进行第一次计算，需要用户给定:a，容器元素 — 以此获取容器总宽度；b，列宽度；最终列数取的是容器宽度/列宽度；获得列数后，需要保存每个列的当前高度，这样在添加每个数据块时，才知道起始高度是多少；依次取容器中的所有数据块，先寻找当前高度最小的某列，之后根据列序号，确定数据块的left，top值，left 为所在列的序号乘以列宽，top 为所在列的当前高度，最后更新所在列的当前高度加上这个数据块元素的高度，至此，插入一个元素结束。 异步加载数据，前面讲的是如何对容器中已有元素进行排列，但很多情况下，还需要不断加载新数据块，仅包含两个步骤: 绑定滚动事件，并确定预加载线高度值，即滚动到哪个高度后，需要去加载数据，其实这个就是列的最小高度值，这样当前滚动值和最小高度值比较一下即可判断出来，是否要触发加载数据 直播点赞按钮的冒泡功能如何实现(?)聊天室的实现(?)实现新闻订阅功能(?)实现一个前端模板引擎(?)去除代码里面所有的空格和换行(?)node.js实现CORS(?)100行简单实现AMD异步模块加载器（JS设计模式这本书上有样例代码）(?)flex怎么实现一个直径100px的圆放在屏幕中间(?)web socket 心跳(?)前端路由实现方式HashHistory原理以 hash 形式（也可以使用 History API 来处理）为例，当 url 的 hash 发生变化时，触发 hashchange 注册的回调，回调中去进行不同的操作，进行不同的内容的展示 思路 init 监听浏览器 url hash 更新事件 route 存储路由更新时的回调到回调数组routes中，回调函数将负责对页面的更新 refresh 执行当前url对应的回调函数，更新页面利用HTML5新特性需要注意的是：pushState()和replaceState()方法存在安全方面的限制，本地测试是无效的，会报错，可以简单放到任何服务端测试，或者使用http-server开启简单服务器代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function Router() &#123; this.routes = &#123;&#125;; this.currentUrl = '';&#125;Router.prototype.route = function(path, callback) &#123; this.routes[path] = callback || function()&#123;&#125;;&#125;;Router.prototype.refresh = function() &#123; this.currentUrl = location.hash.slice(1) || '/'; this.routes[this.currentUrl]();&#125;;Router.prototype.init = function() &#123; window.addEventListener('load', this.refresh.bind(this), false); window.addEventListener('hashchange', this.refresh.bind(this), false);&#125;window.Router = new Router();window.Router.init(); &lt;ul&gt; &lt;li&gt;&lt;a href=\"#/\"&gt;turn white&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#/blue\"&gt;turn blue&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#/green\"&gt;turn green&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; var content = document.querySelector('body');// change Page anythingfunction changeBgColor(color) &#123; content.style.backgroundColor = color;&#125;Router.route('/', function() &#123; changeBgColor('white');&#125;);Router.route('/blue', function() &#123; changeBgColor('blue');&#125;);Router.route('/green', function() &#123; changeBgColor('green');&#125;);&lt;script&gt; var currentPage = 5; // prefilled by server！！！！ function go(d) &#123; setupPage(currentPage + d); history.pushState(currentPage, document.title, '?x=' + currentPage); &#125; onpopstate = function(event) &#123; setupPage(event.state); &#125; function setupPage(page) &#123; currentPage = page; document.title = 'Line Game - ' + currentPage; document.getElementById('coord').textContent = currentPage; document.links[0].href = '?x=' + (currentPage+1); document.links[0].textContent = 'Advance to ' + (currentPage+1); document.links[1].href = '?x=' + (currentPage-1); document.links[1].textContent = 'retreat to ' + (currentPage-1); &#125;&lt;/script&gt; History APIhistory.pushStatehistory.replaceState相同之处是两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。 不同之处在于，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"代码片段","slug":"代码片段","permalink":"http://wiki.haoqiao.me/tags/代码片段/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"考点","date":"2017-07-12T02:58:50.000Z","path":"wiki/前端/基础/Ecmascript/考点/","text":"如果需要手动写动画，你认为最小时间间隔是多久，为什么 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms 点击a标签发生了啥 触发a的click事件 读取href属性的值 如果是URI则跳转 如果是javascript代码则执行该代码 websocket相关，轮询，polling 传统轮询 通常采取setInterval或者setTimeout实现，循环ajax获取 程序在每次请求时都会新建一个HTTP请求，然而并不是每次都能返回所需的新数据。当同时发起的请求达到一定数目时，会对服务器造成较大负担 长轮询(Long Polling) Server接收到Client的请求之后，如果没有数据更新，则连接保持一段时间，直到有数据更新或者连接超时，这样可以减少无效的Client与Server之间的交互 服务器发送事件(Server-Sent Event) 服务器发送事件（以下简称SSE）是HTML 5规范的一个组成部分，可以实现服务器到客户端的单向数据通信。通过SSE，客户端可以自动获取数据更新，而不用重复发送HTTP请求。一旦连接建立，“事件”便会自动被推送到客户端 WebSocket 其本质是先通过HTTP/HTTPS协议进行握手后创建一个用于交换数据的TCP连接，此后服务端与客户端通过此TCP连接进行实时通信 CSS/JS对DOM渲染的影响 CSS（外链或内联）会阻塞整个DOM的渲染（Rendering），然而DOM解析（Parsing）会正常进行很多浏览器中，CSS会延迟脚本执行和DOMContentLoaded事件 JS（外链或内联）会阻塞后续DOM的解析（Parsing），后续DOM的渲染（Rendering）也将被阻塞 JS前的DOM可以正常解析（Parsing）和渲染（Rendering） 前端页面有哪三层构成,分别是什么?作用是什么 结构层: 结构层(structural layer)由 HTML 或 XHTML之类的标记语言负责创建。 表示层: 表示层(presentation layer)由 CSS 负责创建。 CSS对“如何显示有关内容”的问题做出了回答 行为层: 行为层(behaviorlayer)负责回答“内容应该如何对事件做出反应”这一问题。这是 Javascript 语言和 DOM主宰的领域 什么叫优雅降级和渐进增强 优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。 如：border-shadow 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验； 负载均衡你了解吗？ 负载平衡（Load balancing）是一种计算机网络技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最佳化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 解决并发压力，提高应用处理性能（增加吞吐量，加强网络处理能力）； 提供故障转移，实现高可用； 通过添加或减少服务器数量，提供网站伸缩性（扩展性）； 安全防护；（负载均衡设备上做一些过滤，黑白名单等处理） DNS负载均衡 利用域名解析实现负载均衡，在DNS服务器，配置多个A记录，这些A记录对应的服务器构成集群 可以支持基于地址的域名解析，解析成距离用户最近的服务器地址，可以加快访问速度 HTTP负载均衡（?）webapp和native app的优缺点Native App 优点 能够访问手机的所有功能（GPS，相机等）更好的运行速度、性能和总体的用户体验支持离线工作（因为是在设备上运行而非Web）支持丰富的图形和动画 缺点 开发成本较高范围限制较多（只能访问在特定操作系统上运行的设备）未知的部署时间（应用商店审批程序）内容限制（应用商店限制）用户必须手动下载更新最新版本 Web App 优点 适用范围广（覆盖所有智能手机）开发成本较低方便、快捷地部署（无需提交到应用商店）无内容限制用户总能访问到最新版本（没有手动更新需求） 缺点 较差的和较慢的性能体验（大部分需要链接互联网）用户体验较差*支持图形和动画效果较差无法离线使用限制用户使用功能（比如，相机、GPS等） 模块化，组件化模块 编程语言所提供的代码组织机制，利用此机制可将程序拆解为独立且通用的代码单元。模块”指代码单元，其意义偏向静态的代码结构 在ES6之前，并没有语言内置的模块机制，但我们用一些方式自制了某种模块机制，像CommonJS / AMD甚至建立了普遍接受的社区标准。虽然它们都是模块机制，但会有一些重大或微妙的差异。故当我们提到JS模块时，如果没有足够的上下文，有时需要明确是CommonJS module或AMD module或ES6 module。 JS实现的算法和数据单元，封装的是算法和数据，暴露的是接口 组件组件指功能单元，其意义偏向运行时的结构，并有更复杂的控制（如组件实例的生命周期管理） 单向数据流 和 双向数据流123456单向数据流:事件分发器 (dispatcher),开发者必须显式地通过这个统一的事件机制做数据变更通知这样做的好处是所有状态变化都可以被记录、跟踪，状态变化通过手动调用通知，源头易追溯，使得程序更直观更容易理解,有利于应用的可维护性。缺点则是代码量会相应的上升单向数据绑定的实现思路: 所有数据只有一份一旦数据变化,就去更新页面(data-页面)如果用户在页面上做了变动,那么就手动收集起来(双向是自动),合并到原有的数据中. 双向绑定在一些需要实时反应用户输入的场合会非常方便 表单交互较多的场景下，会简化大量业务无关的代码 缺点 无法追踪局部状态的变化； “暗箱操作”，增加了出错时 debug 的难度； 由于组件数据变化来源入口变得可能不止一个，数据流转方向易紊乱，若再缺乏“管制”手段，血崩。 优点 用户在视图上的修改会自动同步到数据模型中去，数据模型中值的变化也会立刻同步到视图中去； 无需进行和单向数据绑定的那些CRUD（Create，Retrieve，Update，Delete）操作； 在表单交互较多的场景下，会简化大量业务无关的代码。 .和[]的区别 一般情况下我们使用点调用属性的方式，但是当obj的某个属性是一个变量时(比如一个字符串)，这种点调用的方式就行不通了，想想看obj.’property’这样的方式不对； 所以，如果对象内的属性是一个变量，只能使用[]调用 。只适合访问的属性名是合法的标识符，需要知道访问属性的名字。如果属性名称是保留字或包含空格和标点符号，必须用方括号。 运算符加法123456781 + &#123;&#125; // 1[object Object]true + true // 22 + null //2 null转为02 + undefined // NAN undefined转为NAN后做加法 逻辑与&amp;&amp; 首先计算左操作数的值，计算&amp;&amp;左侧表达式，如果为假，整个表达式为假，直接返回假，不对右操作数计算.如果为真，以右表达式真值为主 javascript垃圾回收引用计数垃圾收集 对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存 标记-清除算法 这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。 new关键字的过程 创建一个新的对象，这个对象的类型是object； 设置这个新的对象的内部、可访问性和[[prototype]]属性为构造函数（指prototype.construtor所指向的构造函数）中设置的；执行构造函数，当this关键字被提及的时候，使用新创建的对象的属性；返回新创建的对象（除非构造方法中返回的是‘无原型’）。 在创建新对象成功之后，如果调用一个新对象没有的属性的时候，JavaScript会延原型链向止逐层查找对应的内容。这类似于传统的‘类继承’。(1)创建一个空对象，并且 this变量引用该对象，同时还继承了该函数的原型。(2)属性和方法被加入到 this引用的对象中。(3)新创建的对象由 this所引用，并且最后隐式的返回 this。 函数节流 某些代码不可以在没有间断的情况连续重复执行，第一次调用函数创建一个计时器，第二次调用会清除第一次设置的并设置另外一个。目的是为了让执行函数的请求过了一段时间才执行。节流函数，只允许一个函数在 X 毫秒内执行一次 1234567891011121314151617181920212223242526272829// 简单的节流函数function throttle(func, wait, mustRun) &#123; var timeout, startTime = new Date(); return function() &#123; var context = this, args = arguments, curTime = new Date(); clearTimeout(timeout); // 如果达到了规定的触发时间间隔，触发 handler if(curTime - startTime &gt;= mustRun)&#123; func.apply(context,args); startTime = curTime; // 没达到触发间隔，重新设定定时器 &#125;else&#123; timeout = setTimeout(func, wait); &#125; &#125;;&#125;;// 实际想绑定在 scroll 事件上的 handlerfunction realFunc()&#123; console.log(\"Success\");&#125;// 采用了节流函数window.addEventListener('scroll',throttle(realFunc,500,1000)); 函数防抖 防抖技术即是可以把多个顺序地调用合并成一次，也就是在一定时间内，规定事件被触发的次数。 123456789101112131415161718192021222324// 防抖动函数function debounce(func, wait, immediate) &#123; var timeout; return function() &#123; var context = this, args = arguments; var later = function() &#123; timeout = null; if (!immediate) func.apply(context, args); &#125;; var callNow = immediate &amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); &#125;;&#125;;var myEfficientFn = debounce(function() &#123; // 滚动中的真正的操作&#125;, 250);// 绑定监听window.addEventListener('resize', myEfficientFn); 观察者模式(自定义事件)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function EventTarget() &#123; this.handlers = &#123;&#125;&#125;EventTarget.prototype = &#123; constructor: EventTarget, addHandler: function(type, handler) &#123; if (typeof this.handlers[type] == \"undefined\") &#123; this.handlers[type] = [] &#125; this.handlers[type].push(handler) &#125;, fire: function(event) &#123; if (!event.target) &#123; event.target = this &#125; if (this.handlers[event.type] instanceof Array) &#123; var handlers = this.handlers[event.type] for (var i = 0, len = handlers.length; i&lt; len; i++) &#123; handlers[i](event) &#125; &#125; &#125;, removeHandler: function(type, handler) &#123; if (this.handlers[type] instanceof Array) &#123; var handlers = this.handlers[type] for (var i = 0, len = handlers.length; i&lt; len; i++) &#123; if (handlers[i] === handler) &#123; break; &#125; &#125; handlers.splice(i, 1) &#125; &#125;&#125;function handledMessage(event) &#123; console.log(event.message)&#125;var target = new EventTarget()target.addHandler(\"message\", handledMessage)target.fire(&#123; type: \"message\", message: \"Hi,2333\" &#125;)target.removeHandler(\"message\", handledMessage)target.fire(&#123; type: \"message\", message: \"Hi,2333\" &#125;) 函数curry化12345678910111213141516function curry(fn)&#123; var args = Array.prototype.slice.call(arguments,1) return function()&#123; var inner = Array.prototype.slice.call(arguments) var final = args.concat(inner) return fn.apply(null,final) &#125;&#125;function add(n1,n2)&#123; return n1+n2&#125;var c = curry(add,5)console.log(c(3))// 8 怎么判断属性来自对象自身还是原型链 hasOwnProperty()方法会返回一个布尔值，其用来判断某个对象是否含有指定的属性。如果在原型链上返回false,不存在也false 函数声明和和函数表达式的区别 变量声明被提升（hoisting）的机制，也就是说变量（函数）的声明会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被提升至最前面。函数表达式则不会被提升。函数优先提升，然后才是变量var声明一个变量时，创建的这个属性是不可配置的，变量无法通过delete删除 js延迟加载的方式有哪些直接将script节点放置在之前，这样js脚本就会在页面显示出来之后再加载 defer和asyncdefer属性为延迟加载，是在页面渲染完成之后再进行加载的，而async属性则是和文档并行加载 defer和async的相同和区别 相同加载文件时不阻塞页面渲染如果一个script加了defer属性，即使放在head里面，它也会在html页面解析完毕之后再去执行，也就是类似于把这个script放在了页面底部 区别async:遇到async，开始下载脚本，并继续解析。脚本文件下载完毕，立即执行onload处理函数，不按顺序执行，谁先下载完执行谁。defer:遇到defer之后，停止解析等待下载。脚本文件下载完毕后，并不立即执行该脚本文件的onload处理函数，而是等页面全部加载之后才按顺序执行。脚本文件的onload处理函数在浏览器的onload处理之前执行，因为它们属于外部文件下载，属于整个页面加载工作中的一部分 Cookie跨域请求能不能带上 cookie一般情况下是没法跨域的，甚至POST请求一般情况下都是无法跨域的。但经过特殊处理后就可以了，这个处理需要客户端服务器的配合。 1234解决方案 客户端请求的时候带上withCredentials参数 $.ajax(&#123; type: &quot;POST&quot;, url: &quot;http://xxx.com/api/test&quot;, dataType: &apos;jsonp&apos;, xhrFields: &#123; withCredentials: true &#125;, crossDomain: true, success:function()&#123;&#125;, error:function()&#123;&#125; &#125;) xhr.withCredentials = true; //支持跨域发送cookies setTimeout和setInterval区别setTimeout (表达式,延时时间) setInterval(表达式,交互时间) 延时时间/交互时间是以豪秒为单位的(1000ms=1s) setTimeout 在执行时,是在载入后延迟指定时间后,去执行一次表达式,仅执行一次 setInterval 在执行时,它从载入后,每隔指定的时间就执行一次表达式 setTimeout可以传入第三个参数、第四个参数….，它们表示神马呢？其实是用来表示第一个参数（回调函数）传入的参数 setTimeout(function(a, b){ console.log(a); // 3 console.log(b); // 4 },0, 3, 4); 区别浏览器和版本 通过分析浏览器的userAgent属性来判断 navigator.userAgent Object.create 的具体用处12Object.create(proto [, propertiesObject ]) 是E5中提出的一种新的对象创建方式，第一个参数是要继承的原型，如果不是一个子函数，可以传一个null，第二个参数是对象的属性描述符，这个参数是可选的。 Object.create() 方法创建一个拥有指定原型和若干个指定属性的对象。 Object.create(Object.prototype, &#123; a: &#123; value: 1, writable: true, configurable: true &#125; &#125;); 创建一个继承自Object.prototype的对象，有一个属性a，其可写，可配置，不可枚举，值为1 什么是浅复制和深复制，有什么区别浅复制：浅拷贝就是复制一份引用，所有引用对象都指向一份数据，并且都可以修改这份数据123object.assign()var newobj = Object.assign(&#123;&#125;,myObject) 深复制：深拷贝则是复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制1234567891011121314151617181920212223242526 使用JSON.parse()方法 function deepClone(initalObj) &#123; var obj = &#123;&#125;; try &#123; obj = JSON.parse(JSON.stringify(initalObj)); &#125; return obj; &#125; function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) &#123; continue; &#125; if (typeof prop === &apos;object&apos;) &#123; obj[i] = (prop.constructor === Array) ? [] : &#123;&#125;; arguments.callee(prop, obj[i]); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj;&#125; 使用Object.create()方法 前端异常监测如何实现前端SDK需要实现，主要是错误拦截，代理监控，上报策略，API设计，以及日志接口。上报的日志实现实时查询。监控日志可视化管理后台的开发。压缩后的单行文件如何定位源码错误。 window.onerror的方案有如下特点： 可以捕捉语法错误，也可以捕捉运行时错误； 可以拿到出错的信息，堆栈，出错的文件、行号、列号； 只要在当前页面执行的js脚本出错都会捕捉到，例如：浏览器插件的javascript、或者flash抛出的异常等。 跨域的资源需要特殊头部支持。 link SPA如何管理内存优化代码 事件绑定不用要取消。 手机webApp如何与原生App通信 H5与Native交互的桥梁为Webview，“联系”的方式以url schema的方式，在用户安装app后，app可以自定义url schema，并且把自定义的url注册在调度中心。App调用H5:将一组API绑定在webView的window对象上，App通过iOS原生方法调用window对象中的js方法。H5与App通信：App实现对Webview URL的观察者模式，H5 通过改变URL的哈希值，通过解析哈希值的变化执行相应的操作。 JSBridge技术实现 重写WebView中WebChromeClient类的onJsPrompt()方法来进行js和java的通信。 浏览器发送Cookie服务器接收不到什么原因跨域，不是cookie指定域cookie过长，超过限制 cookie设置了secure为true，服务器不是https协议的 Webpack 怎么实现不同模块规范的互转 webpack有多种加载器Loader,可以处理各种需要被处理的静态文件 智能解析器 可以解析任何第三方库 无论他们的模块形式是CommonJS AMD还是原生的JS模块 Session 的实现原理 session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构(也可能就是使用散列表)来保存信息。 但程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否包含了一个session标识－称为session id,如果已经包含一个session id则说明以前已经为此客户创建过session，服务器就按照session id把这个session检索出来使用(如果检索不到，可能会新建一个，这种情况可能出现在服务端已经删除了该用户对应的session对象，但用户人为地在请求的URL后面附加上一个JSESSION的参数)。 如果客户请求不包含session id，则为此客户创建一个session并且生成一个与此session相关联的session id，这个session id将在本次响应中返回给客户端保存。 对前后端同构化的了解对于以后的Web来说，不需要分离，而是需要合并的。这种趋势在Nodejs出来后显得越来越显著。目前已经有很多Nodejs的库是前后端共通的，也就是所谓的前后端统一或者同构（即英文里的isomorphic js）。 当有象JS这种前后端两栖的语言出现时就促成了前后端的同构。 Web Assembly将会进一步促进前后端同构 由于新技术Web Assembly的推出，未来会有更多的语言可以在浏览器端执行，所以支持前后端同构的方案与语言将会越来越丰富。 面向Web的二进制格式。该格式名为WebAssembly，可以作为任何编程语言的编译目标，使应用程序可以运行在浏览器或其它代理中。 怎么解决 SEO 问题前后端同构方案，即一套代码在浏览器端和node端都可以运行，从而可以先在node端请求数据渲染模板，然后将渲染结果返回给浏览器最终呈现，是目前最完美的前后端分离+SEO解决方案，目测没有之一。 后端渲染服务 二维码扫描登录的实现，包括业务以及技术实现(?)","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"考点","slug":"考点","permalink":"http://wiki.haoqiao.me/tags/考点/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"javascript异步编程","date":"2017-07-12T02:58:50.000Z","path":"wiki/前端/基础/Ecmascript/javascript异步编程/","text":"回调函数setTimeout 函数generator 当你在执行一个函数的时候，你可以在某个点暂停函数的执行，并且做一些其他工作，然后再返回这个函数继续执行，甚至是携带一些新的值，然后继续执行。 当我们调用一个生成器函数的时候，它并不会立即执行， 而是需要我们手动的去执行迭代操作（next方法）。也就是说，你调用生成器函数，它会返回给你一个迭代器。迭代器会遍历每个中断点 1234567891011121314151617* function* foo () &#123; var index = 0; while (index ... 2) &#123; yield index++; //暂停函数执行，并执行yield后的操作 &#125; &#125; var bar = foo(); // 返回的其实是一个迭代器 console.log(bar.next()); // &#123; value: 0, done: false &#125; console.log(bar.next()); // &#123; value: 1, done: false &#125; console.log(bar.next()); // &#123; value: undefined, done: true &#125; Promises对象Promise 对象用于异步调用返回值的集中处理。 Promise 对象表示一个现在、将来或永不可用的值。 特点 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的 Promise 本质是一个状态机。每个 promise 只能是 3 种状态中的一种：pending、fulfilled 或 rejected。状态转变只能是 pending -&gt; fulfilled 或者 pending -&gt; rejected。状态转变不可逆。then 方法可以被同一个 promise 调用多次。then 方法必须返回一个 promise。规范里没有明确说明返回一个新的 promise 还是复用老的 promise（即 return this），大多数实现都是返回一个新的 promise，而且复用老的 promise 可能改变内部状态，这与规范也是相违背的。值穿透。 12345678910111213141516* var myFirstPromise = new Promise(function(resolve, reject)&#123; //当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...) //在本例中，我们使用setTimeout(...)来模拟异步代码，实际编码时可能是XHR请求或是HTML5的一些API方法. setTimeout(function()&#123; resolve(\"成功!\"); //代码正常执行！ &#125;, 250); &#125;); myFirstPromise.then(function(successMessage)&#123; //successMessage的值是上面调用resolve(...)方法传入的值. //successMessage参数不一定非要是字符串类型，这里只是举个例子 console.log(\"Yay! \" + successMessage); &#125;); asyncawait考题1.代码运行结果12345678910111213141516(function test() &#123; setTimeout(function() &#123;console.log(4)&#125;, 0); new Promise(function executor(resolve) &#123; console.log(1); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(2); &#125;).then(function() &#123; console.log(5); &#125;); console.log(3);&#125;)() 当前task运行，执行代码。首先setTimeout的callback被添加到tasks queue中； 实例化promise，输出 1; promise resolved；输出 2; promise.then的callback被添加到microtasks queue中； 输出 3; 已到当前task的end，执行microtasks，输出 5; 执行下一个task，输出4。 每个浏览器环境，至多有一个event loop。 一个event loop可以有1个或多个task queue。 一个task queue是一列有序的task，用来做以下工作：Events task，Parsing task， Callbacks task， Using a resource task， Reacting to DOM manipulation task等。 每个(task source对应的)task queue都保证自己队列的先进先出的执行顺序，但event loop的每个turn，是由浏览器决定从哪个task source挑选task。这允许浏览器为不同的task source设置不同的优先级，比如为用户交互设置更高优先级来使用户感觉流畅。 micro-task在ES2015规范中称为Job。 其次，macro-task代指task。 Event Loop（事件循环）是怎么来处理task和microtask的 每个线程有自己的事件循环，所以每个web worker有自己的，所以它才可以独立执行。然而，所有同属一个origin的windows共享一个事件循环，所以它们可以同步交流。 事件循环不间断在跑，执行任何进入队列的task。 一个事件循环可以有多个task source，每个task source保证自己的任务列表的执行顺序，但由浏览器在（事件循环的）每轮中挑选某个task source的task。 tasks are scheduled，所以浏览器可以从内部到JS/DOM，保证动作按序发生。在tasks之间，浏览器可能会render updates。从鼠标点击到事件回调需要schedule task，解析html，setTimeout这些都需要。 microtasks are scheduled，经常是为需要直接在当前脚本执行完后立即发生的事，比如async某些动作但不必承担新开task的弊端。microtask queue在回调之后执行，只要没有其它JS在执行中，并且在每个task的结尾。microtask中添加的microtask也被添加到microtask queue的末尾并处理。microtask包括mutation observer callbacks和promise callbacks。","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"异步编程","slug":"异步编程","permalink":"http://wiki.haoqiao.me/tags/异步编程/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"Node","date":"2017-07-11T12:56:16.000Z","path":"wiki/前端/基础/Ecmascript/Node/","text":"前置知识基础 Node是采用单线程，异步式I/O，事件驱动式的让javascript运行在服务器端的开发平台 Node.js在执行中会维护一个事件队列，每个异步式I/O请求完成后会被推送到事件队列，等待程序进程处理。利用事件循环的处理能力:Node.js适用于应用程序处理大量并发的I/O。 核心模块EventEmitter EventEmitter是node中一个实现观察者模式的类，主要功能是监听和发射消息，用于处理多模块交互问题 所有能触发事件的对象都是EventEmitter类的实例。 这些对象开放了一个eventEmitter.on()函数，允许将一个或多个函数附加到会被对象触发的命名事件上 1234567891011121314151617实现一个eventEmitter var util = require('util'); var EventEmitter = require('events').EventEmitter; function MyEmitter() &#123; EventEmitter.call(this); &#125; // 构造函数 util.inherits(MyEmitter, EventEmitter); // 继承 var em = new MyEmitter(); em.on('hello', function(data) &#123; console.log('收到事件hello的数据:', data); &#125;); // 接收事件，并打印到控制台 em.emit('hello', 'EventEmitter传递消息真方便!'); Buffer Buffer对象是Node处理二进制数据的一个接口。它是Node原生提供的全局对象 JavaScript比较擅长处理字符串，对于处理二进制数据（比如TCP数据流），就不太擅长。Buffer对象就是为了解决这个问题而设计的。 Stream stream是基于事件EventEmitter的数据管理模式．由各种不同的抽象接口组成，主要包括可写，可读，可读写，可转换等几种类型 Stream是Node中一个非常重要的概念，被大量对象实现，尤其是Node中的I/O操作 Stream是一个抽像的接口，一般不会直接使用，需要实现内部的某些抽象方法(例如_read、_write、_transform) Stream是EventEmitter的子类，实际上Stream的数据传递内部依然是通过事件(data)来实现的 Stream分为四种：readable、writeable、Duplex、transform http模块123456789101112* 实现一个简单的http服务器 * 代码 * var http = require('http'); // 加载http模块 http.createServer(function(req, res) &#123; res.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); // 200代表状态成功, 文档类型是给浏览器识别用的 res.write('&lt;meta charset=\"UTF-8\"&gt; &lt;h1&gt;我是标题啊！&lt;/h1&gt; &lt;font color=\"red\"&gt;这么原生，初级的服务器，下辈子能用着吗?!&lt;/font&gt;'); // 返回给客户端的html数据 res.end(); // 结束输出流 &#125;).listen(3000); // 绑定3ooo, 查看效果请访问 http://localhost:3000 * 加载http模块，创建服务器，监听端口 cluster 模块 CPU都是多核的背景下.它可以通过一个父进程管理子进程的方式来实现集群的功能。每个worker进程通过使用child_process.fork()函数，基于IPC（Inter-Process Communication，进程间通信），实现与master进程间通信。 当worker使用server.listen（…）函数时 ，将参数序列传递给master进程。如果master进程已经匹配workers，会将传递句柄给工人。如果master没有匹配好worker，那么会创建一个worker，再传递并句柄传递给worker。 Nodejs中的Stream和Buffer有什么区别 buffer 为数据缓冲对象，是一个类似数组结构的对象，可以通过指定开始写入的位置及写入的数据长度，往其中写入二进制数据 stream 是对buffer对象的高级封装，其操作的底层还是buffer对象，stream可以设置为可读、可写，或者即可读也可写，在nodejs中继承了EventEmitter接口，可以监听读入、写入的过程 node有哪些定时功能 process.nextTick setTimeout/clearTimeout setInterval/clearInterval setImmediate/clearImmediate, 优先级在每一轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。 process.nextTick每次调用，只会将回调函数放入队列，在下一轮tick时取出执行。时间复杂度o(1) 属于IDLE观察者 setTimeoutsetTimeout需要使用红黑树，且after设置为0，其实会被node强制转换为1，存在性能上的问题，建议替换为setImmediate。时间复杂度o(lg(n)) setImmediate将函数延迟执行，属于check观察者。 node中的异步和同步怎么理解 同步与异步 同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)。 所谓同步，就是在发出调用时， 在没有得到结果之前，调用不返回。 一旦调用返回，即得到返回值。换句话说，就是由调用者主动等待这个调用的结果。 异步则是相反，调用在发出之后，调用就直接返回，但没有返回结果。 换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。 node是单线程的，异步是通过一次次的循环事件队列来实现的． 同步则是说阻塞式的IO,这在高并发环境会是一个很大的性能问题，所以同步一般只在基础框架的启动时使用，用来加载配置文件，初始化程序什么的 express特点 精简 可扩展 可以配合多页和单页应用 express中如何获取路由的参数 users/:name使用req.params.name来获取; req.body.username则是获得表单传入参数username express路由支持常用通配符 ?, +, *, and () Mongodb NoSQL（Not Only SQL）泛指非关系型数据库 MongoDB数据库是面向文档的数据库，该数据库是非阻塞型数据库，内部查询支持javascript。 和SQL区别 SQL数据存在特定结构的表中；而NoSQL则更加灵活和可扩展，存储方式可以省是JSON文档、哈希表或者其他方式 在SQL中，必须定义好表和字段结构后才能添加数据，例如定义表的主键(primary key)，索引(index),触发器(trigger),存储过程(stored procedure)等。表结构可以在被定义之后更新，但是如果有比较大的结构变更的话就会变得比较复杂。 在NoSQL中，数据可以在任何时候任何地方添加，不需要先定义表。 SQL数据库被称为关系型数据库（RDBMS），而NoSQL数据库被称为非关系型数据库或分布式数据库。 SQL数据库是基于表的数据库，而NoSQL数据库则有基于文档的，键值对的，图形的或基于列式存储的数据库。 SQL数据库的数据结构必须事先先定义好，而NoSQL数据库的数据是动态无结构的。 SQL数据库的负载能力是以增加硬件配置的垂直扩展方式来增加的，而NoSQL数据库的负载能力可以通过增加数据库服务器的数量来增加（属于水平扩展）。 5.对于复杂的查询：SQL非常的擅长，而NoSQL则不擅长 mongoose是什么？有支持哪些特性? mongoose是mongodb的文档映射模型．主要由Schema, Model和Instance三个方面组成． Schema就是定义数据类型， Model就是把Schema和js类绑定到一起，Instance就是一个对象实例． 常见mongoose操作有,save, update, find. findOne, findById, static方法等 koa 处理客户端请求的函数。内部封装一个NEXT回调函数。 中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。 如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。 完美解决了异步组合问题，并解决了异步异常捕获问题（并且 koa 框架在最外层 catch 了异常，应用不会因为异常而中断进程，所以不需要 forever 来重启应用） 阅读node的http模块和Stream模块源码(?)libuv的底层实现(?)","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wiki.haoqiao.me/tags/Javascript/"},{"name":"Node","slug":"Node","permalink":"http://wiki.haoqiao.me/tags/Node/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Ecmascript","slug":"前端/基础/Ecmascript","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Ecmascript/"}]},{"title":"布局","date":"2017-07-11T06:46:00.000Z","path":"wiki/前端/基础/Css/布局/","text":"前置知识浮动 浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 设置了浮动的元素仍旧处于标准文档流中。会占据标准文档流空间，对其他元素有影响。 使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围 clear语法：clear : none | left | right | both取值： none : 默认值。允许两边都可以有浮动对象 left : 不允许左边有浮动对象 right : 不允许右边有浮动对象 both : 不允许有浮动对象 清楚浮动 浮动元素脱离文档流（out of normal flow）之后，其他的元素在定位的时候会当做没看见它，两者位置重叠都是可以的 引起的问题 （1）父元素的高度无法被撑开，影响与父元素同级的元素 （2）与浮动元素同级的非浮动元素（内联元素）会跟随其后 （ (3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 清除浮动其实就一个目的，就是解决高度塌陷的问题 塌陷原因是：元素含有浮动属性 – 破坏inline box – 破坏line box高度 – 没有高度 – 塌陷 1.额外标签法，在浮动元素后使用一个空元素如《div style=”clear:both;”》《/div》（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。） 2.使用after伪类 给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。 .clearfix:after{ content:”.”; height:0; visibility:hidden; display:block; clear:both; } 3.浮动外部元素：给浮动元素的容器也添加上浮动属性即可清理内部浮动。同overflow法一样无须添加额外的class，使用方便但是会对下面的文档造成影响。 闭合浮动 如果“闭合浮动”指的是避免“float无法撑高父容器的默认行为”的话， 只要触发了BFC的属性值都可以闭合浮动 通过设置父元素 overflow 或者display：table 属性来闭合浮动 margin负值作用 当元素margin的top和left是负值时会引起元素的向上或向左位置移动。而当元素margin的bottom和right是负值时会影响右边和下边相邻元素的参考线,即其右边和下边的相邻元素会进入覆盖它的一部分 如果没有设定width属性，设定负margin-left/right会将元素拖向对应的方向，并增加宽度 margin-top为负值不会增加高度，只会产生向上位移 负margin会改变浮动元素的显示位置 居中居中对齐 上级容器中设置text-align:center 使用margin-left:auto,margin:auto,并设置width:+value 可以创建居中对齐的设定尺寸型元素 对绝对元素，可设置right:0,left:0使元素对齐到左右两边 将margin-left和margin-right设置为相同值，可以创建居中对齐的拉伸型元素 水平居中元素 margin + 定宽 Javascript Array Syntax12345678910111213&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; width: 100px; margin: 0 auto; &#125;&lt;/style&gt; table + margin Javascript Array Syntax12345678910111213141516&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: table; margin: 0 auto; &#125;&lt;/style&gt;display: table 在表现上类似 block 元素，但是宽度为内容宽。无需设置父元素样式 （支持 IE 8 及其以上版本）兼容 IE 8 一下版本需要调整为 &lt;table&gt; inline-block + text-align Javascript Array Syntax12345678910111213141516&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: inline-block; &#125; .parent &#123; text-align: center; &#125;&lt;/style&gt; 兼容性佳（甚至可以兼容 IE 6 和 IE 7） absolute + transform Javascript Array Syntax12345678910111213141516171819&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; position: relative; &#125; .child &#123; position: absolute; left: 50%; transform: translateX(-50%); &#125;&lt;/style&gt; 绝对定位脱离文档流，不会对后续元素的布局造成影响。 transform 为 CSS3 属性，有兼容性问题 flex + justify-content Javascript Array Syntax1234567891011121314&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt; .parent &#123; justify-content: center; display: flex; &#125; * 只需设置父节点属性，无需设置子元素* flex有兼容性问题* text-center法 父容器container加css属性 text-align:center;子容器center加css属性display:inline-block;并设置Line-height 垂直居中对齐 将行内元素的line-height:value设置为父元素相同的数值，要求父元素必须设定尺寸 对绝对元素:设置绝对元素的尺寸，top:0,bottom:0将其对齐到上下边，margin-top:0,margin-bottom:0对齐到中间。 将margin-left和margin-right设置为相同值。再top:0,bottom:0将其对齐到上下边 单行文本水平居中只要让line-height 值等于 height值。水平居中的话加上text-align:center即可 多行内容居中 只要给div设置上下相同的padding就行了 绝对定位 absolute + 定位高度 top + margin-top 法 这种方法主要是针对多行元素来进行元素的垂直居中，而并非是此元素的内容垂直居中。 给容器设置绝对定位position:absolute定位高度（top:50%）和margin-top:-height/2 元素进行绝对定位后脱离文档流，其宽度是根据元素内容所占宽度来计算的，为这能让其视觉效果更好，最好给元素定义一个宽度值. 如果需要指定容器宽度，为了让它能够水平居中，我们还需给一个宽度width,并且加上margin-left:-width/2 table法 div模拟表格效果，外部div设置display为table，内部div设置display为table-cell,并且将vertical-align设为middle 但是这样只做到了垂直居中，水平居中需要外度div设置宽度，可以是100%,然后内部添加text-align: center; 两列自适应布局 右侧固定宽度 左侧自适应 flex 左列不定宽，右列自适应 float + BFC 三栏布局 position+margin（两侧定宽，中间自适应） 中间自适应的三列布局的：子列和附加列分别浮动到左边和右边，主列设置左右外边距即可,需要注意的是子列和附加列要写在主列的前面，顺序不能变。 圣杯布局 使主要内容列先加载。 允许任何列是最高的。 没有额外的div。 需要的hack很少。 分别浮动main、sub、extra三列， 然后利用负外边距把sub列和extra列定位到左右两边sub和extra列已经到了正确的位置，但是sub和extra列却覆盖了main的两边，对于这个问题，圣杯布局的解决办法是给容器container添加左、右内边距，从而让main列定位到正确的位置 sub、extra列也受到容器左右内边距的影响位置发生了移动。为了解决这个问题，圣杯布局使用相对定位使sub、extra列回到正确的位置 Javascript Array Syntax123456789101112131415161718192021222324252627282930313233343536373839&lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;div class=\"sub\"&gt;&lt;/div&gt; &lt;div class=\"extra\"&gt;&lt;/div&gt;&lt;/div&gt; body &#123; min-width: 600px; /* 2*sub + extra */&#125;.container &#123; padding-left: 210px; padding-right: 190px;&#125;.main &#123; float: left; width: 100%; height: 300px; background-color: rgba(255, 0, 0, .5);&#125;.sub &#123; position: relative; left: -210px; float: left; width: 200px; height: 300px; margin-left: -100%; background-color: rgba(0, 255, 0, .5);&#125;.extra &#123; position: relative; right: -190px; float: left; width: 180px; height: 300px; margin-left: -180px; background-color: rgba(0, 0, 255, .5);&#125; 双飞翼布局 DOM按照主、子、附加列的顺序加载，实现了重要内容先加载。 main部分是自适应宽度的，很容易在定宽布局和流体布局中切换。 在浏览器上的兼容性非常好，IE5.5以上都支持。 实现了内容与布局的分离，即Eric提到的Any-Order Columns.任何一栏都可以是最高栏，不会出问题。需要的hack非常少 Javascript Array Syntax123456789101112131415161718192021222324252627282930313233&lt;div class=\"main-wrapper\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"sub\"&gt;&lt;/div&gt;&lt;div class=\"extra\"&gt;&lt;/div&gt;.main-wrapper &#123; float: left; width: 100%;&#125;.main &#123; height: 300px; margin-left: 210px; margin-right: 190px; background-color: rgba(255, 0, 0, .5);&#125;.sub &#123; float: left; width: 200px; height: 300px; margin-left: -100%; background-color: rgba(0, 255, 0, .5);&#125;.extra &#123; float: left; width: 180px; height: 300px; margin-left: -180px; background-color: rgba(0, 0, 255, .5);&#125; 多栏布局 使用float或postion属性的特点 两个div元素是各自独立的，如果在其中一个加入一些内容，会使两个元素的底部不能对齐，导致页面出现一块空白区域。column-count 配合 -webkit-column-width 将一个元素里的内容分为两栏或多栏显示，但是缩放都是一致的，不存在两边不变中间自适应 盒布局display: -webkit-box;可以自定义每个栏的宽度 flex 使用order可以改变显示顺序 多列等高 首先把列的padding-bottom设为一个足够大的值，再把列的margin-bottom设一个与前面的padding- bottom的正值相抵消的负值，父容器设置超出隐藏，这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任 一列高度增加了，则父容器的高度被撑到它里面最高那列的高度，其他比这列矮的列则会用它们的padding-bottom来补偿这部分高度差。因为背景是 可以用在padding占用的空间里的，而且边框也是跟随padding变化的，所以就成功的完成了一个障眼法。 此时运用的是padding可以撑开外层标签而margin不用来撑开外层标签。即当padding-bottom:10000px时撑开外层标签的高度增加10000px,外层标签用overflow:hidden;隐藏掉多余的高，这样可以让高度与最高的那一栏对齐；而margin关乎模块布局，margin:-10000px可以抵消掉padding撑开的盒子使布局能够从内容部分开始。 流式布局 简单说呢就针对不同的屏幕分辨率应用不同的CSS样式。比如在电脑、Pad设备上，屏幕比较宽，就可以一行放2个Div。到了手机上，或者Pad竖着拿的的时候，一行就只放1个Div。这里有2个关键点：一是如何在不修改Dom结构的前提下调整布局。二是如何判断屏幕分辨率并应用对应的CSS。以上两点都应该不依赖与JS。实现第一点依靠的是流式布局。就是所有参与布局的DIV都用float:left，宽度都用百分比表示。比如下图，黄色部分的宽度是60%，橘色宽度是40%。 Flex 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Css","slug":"Css","permalink":"http://wiki.haoqiao.me/tags/Css/"},{"name":"布局","slug":"布局","permalink":"http://wiki.haoqiao.me/tags/布局/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Css","slug":"前端/基础/Css","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Css/"}]},{"title":"基础","date":"2017-07-11T06:46:00.000Z","path":"wiki/前端/基础/Css/基础/","text":"css的引入有哪些方式 内联引用CSS &lt;td style=&quot;color:#c00; font-size:15px; line-height:18px;&gt; &lt;/td&gt; 内部引用CSS 将样式规则写在&lt;style&gt;...&lt;/style&gt;标签之中 外部引用 link 标签引用CSS &lt;link rel=stylesheet type=&quot;text/css&quot; href=&quot;example.css&quot;&gt; 外部引用 @import 引用CSS &lt;style type=&quot;text/css&quot;&gt; &lt;!-- @import url(css/example.css); --&gt; &lt;/STYLE&gt; CSS中 link 和@import 的区别是? (1) link属于HTML标签，而@import是CSS提供的; (2) 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; (3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题; (4) link方式的样式的权重 高于@import的权重. CSS中src和href的区别 src src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。 herf href用于在当前文档和引用资源之间确立联系href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加 那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。 css3新特性 animation 动画 animation 则是属于关键帧动画的范畴 box-shadow 向方框添加一个或多个阴影 Transform 2D/3D 转换属性 Transition 过渡属性 transition 是令一个或多个可以用数值表示的css属性值发生变化时产生过渡效果 text-shadow 文字特效 border-radius 圆角 CSS选择符 1.id选择器（ # maid） 2.类选择器（.myclassname） 3.标签选择器（div, h1, p） 4.相邻选择器（h1 + p） 5.子选择器（ul 》 li） 只管儿子 6.后代选择器（li a） 所有后代 儿子 孙子都管 7.通配符选择器（ * ） 8.属性选择器（a[rel = “external”]） 9.伪类选择器（a:hover, li:nth-child） root选择器将样式绑定到页面的根目录中。 first - child单独指定第一个元素 last - child指定最后一个子元素 nth - child指定父元素顺序指定序号的子元素 nth - child(odd)所有正数下来第奇数个子元素 nth - last - child指定父元素倒叙指定序号的子元素 nth - last - child(even)所有倒数上去第偶数个子元素 nth - of - type用来避免交叉元素用nth - child失效在计算子元素是奇数个还是偶数个时， 只针对同类型的元素计算 通用兄弟元素选择器~div~p选择所有和div同级的p元素 优先级!important &gt;id &gt; class &gt; tag important 比 内联优先级高 display:none和visibility:hidden的区别 display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢， 就当他从来不存在。 visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 隐藏元素的其它方法 opacity:0; .hide { position: absolute; top: -9999px; left: -9999px; } .hide_2 { clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px); } transform: scale(0,0)/ 占据空间，无法点击 / 缩放 什么是CSS reset1234567891011121314早期的浏览器支持和理解的CSS规范不同，导致渲染页面时效果不一致，会出现很多兼容性问题css reset就是重置样式。 CSS reset的作用是让各个浏览器的CSS样式有一个统一的基准，而这个基准一般认为就是“清零”为什么要初始化因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异Normalize.css 与传统的 CSS Reset区别 Normalize 相对「平和」，注重通用的方案，重置掉该重置的样式，保留有用的 user agent 样式，同时进行一些 bug 的修复Reset 相对「暴力」，不管你有没有用，统统重置成一样的效果，且影响的范围很大，讲求跨浏览器的一致性。对性能有影响 css预处理 基于 CSS 扩展了一套属于自己的 DSL，来解决我们书写 CSS 时难以解决的问题： 语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器； 没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。在 CSS 中使用变量、简单的程序逻辑、函数等等在编程语言中的一些基本技巧，可以让你的 CSS 更见简洁，适应性更强，代码更直观 标准的CSS的盒子模型 盒模型内容(content)、填充(padding)、边框(border)、边界(margin) ； IE 盒子模型总宽度 = margin-left + width + margin-right W3C模型总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right 区 别： IE的content部分把 border 和 padding计算了进去 box-sizing属性(主要用来控制元素的盒模型的解析模式) content-box 让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高 *border-box 让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content Display的值 block 块类型元素一样显示。 none 缺省值。象行内元素类型一样显示。 inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示 inherit 规定应该从父元素继承 flex grid position的值 absolute 生成绝对定位的元素，相对于值不为static的第一个父元素进行定位。 fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明） inherit 规定从父元素继承 position 属性的值 CSS 定位机制 标准文档流(Normal flow) 从左到右，从上向下，输出文档内容 由块级元素(从左到右撑满页面，独占一行，触碰到页面边缘时自动换行的元素, 如div, ul, li, dl, dt, p)和行级元素组成(能在同一行内显示并且不会改变HTML文档结构，如span, input) 浮动(Floats) 设置为浮动的元素将会往左(float:left)或者往右(float:right)漂移, 直到遇到阻挡 - 其他浮动元素或者父元素的边框。同处于文档流中的文字实体不会与浮动元素重叠 *绝对定位(Absolute positioning) 设置为绝对定位的元素(posistion:absolute)将从标准文档流中删除，其所占据的标准流空间也不存在。然后通过top,left,right,bottom属性对其相对父元素进行定位。 纯CSS创建一个三角形12345678910把上、左、右三条边隐藏掉（颜色设为 transparent） #demo &#123; width: 0; height: 0; border - width: 20 px; border - style: solid; border - color: transparent transparent red transparent;&#125; bootstrap是怎么实现grid系统的 媒体查询，屏幕宽度大于或等于分界点大小的设备，并且针对小屏幕设备覆盖栅格类 通过设置内距（padding）从而创建列与列之间的间距。然后通过为第一列和最后一列设置负值的外距（margin）来抵消内距(padding)的影响。设置padding是为了使内容不会紧贴在浏览器边界上，列之间有了padding才不会互相紧贴在一起 行(row)必须包含在.container(固定宽度)中，以便为其赋予合适的排列(alignment)和内补(padding)。 在行(.row)中可以添加列(.column)，但列数之和不能超过平分的总列数，比如12 具体内容应当放置在列容器（column）之内，而且只有列（column）才可以作为行容器(.row)的直接子元素 使用 浮动与宽度百分比 实现 列组合 画一条0.5px的直线1-webkit-transform:scale(0.5); transform:scale(0.5); css3硬件加速 为动画DOM元素添加CSS3样式-webkit-transform:transition3d(0,0,0)或-webkit-transform:translateZ(0);，这两个属性都会开启GPU硬件加速模式，从而让浏览器在渲染动画时从CPU转向GPU，其实说白了这是一个小伎俩，也可以算是一个Hack，-webkit-transform:transition3d和-webkit-transform:translateZ其实是为了渲染3D样式，但我们设置值为0后，并没有真正使用3D效果，但浏览器却因此开启了GPU硬件加速模式。 通过-webkit-transform:transition3d/translateZ开启GPU硬件加速之后，有些时候可能会导致浏览器频繁闪烁或抖动，可以尝试以下办法解决之： -webkit-backface-visibility:hidden; -webkit-perspective:1000; float和display：inline-block；的区别 Inline-block是元素display属性的一个值。这个名字的由来是因为，display设置这个值的元素，兼具行内元素（ inline elements）跟块级元素（block elements）的特征。 块级元素（block elements）,来源于CSS盒子模型。块级元素包含width height,padding,border与margin，他们的排列方式是从上到下排列。 行内元素，排列方式是水平排列。行内元素（inline elements）排列方式是水平排列。行内块元素（inline-block elements）在内部他的表现类似block元素，比如他拥有block元素的width height,padding,border与margin，而外部的排列方式有类似行内元素，即水平排列，而不是像块级元素一样从上到下排列 内部表现为块级元素，水平排列这种需求，浮动跟inline-block都适合实现 文档流（Document flow）:浮动元素会脱离文档流，并使得周围元素环绕这个元素。而inline-block元素仍在文档流内。因此设置inline-block不需要清除浮动。当然，周围元素不会环绕这个元素，你也不可能通过清除inline-block就让一个元素跑到下面去。水平位置（Horizontal position）：很明显你不能通过给父元素设置text-align:center让浮动元素居中。事实上定位类属性设置到父元素上，均不会影响父元素内浮动的元素。但是父元素内元素如果设置了display：inline-block，则对父元素设置一些定位属性会影响到子元素。（这还是因为浮动元素脱离文档流的关系）。垂直对齐（Vertical alignment）：inline-block元素沿着默认的基线对齐。浮动元素紧贴顶部。你可以通过vertical属性设置这个默认基线，但对浮动元素这种方法就不行了。这也是我倾向于inline-block的主要原因。空白（Whitespace）：inline-block包含html空白节点。如果你的html中一系列元素每个元素之间都换行了，当你对这些元素设置inline-block时，这些元素之间就会出现空白。而浮动元素会忽略空白节点，互相紧贴什么时候使用inline-block，什么时候使用float 什么时候使用，取决于你的设计稿跟解决方法。如果你需要文字环绕容器，那浮动是不二选择。如果你需要居中对齐元素，inline-block是个好选择。 最终，这可以归结为float跟inline-block的两种属性作用后的区别，你需要对其作出选择。 使用inline-block：当你需要控制元素的垂直对齐跟水平排列时，使用inline-block。使用浮动：当你需要让元素环绕某一个元素时，或者需要支持旧版本ie，或者不想处理inline-block带来的空白问题时，使用浮动。 transition的属性值和应用 property name | duration | timing function | delaytransition: margin-left 4s ease-in-out 1s; CSS transitions 提供了一种在更改CSS属性时控制动画速度的方法。 其可以让属性变化成为一个持续一段时间的过程，而不是立即生效的。比如，将一个元素的颜色从白色改为黑色，通常这个改变是立即生效的，使用 CSS transitions 后该元素的颜色将逐渐从白色变为黑色，按照一定的曲线速率变化。这个过程可以自定义。","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Css","slug":"Css","permalink":"http://wiki.haoqiao.me/tags/Css/"},{"name":"基础","slug":"基础","permalink":"http://wiki.haoqiao.me/tags/基础/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Css","slug":"前端/基础/Css","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Css/"}]},{"title":"考点","date":"2017-07-11T06:46:00.000Z","path":"wiki/前端/基础/Css/考点/","text":"css单词断词，换行1234567891011121314151617181920212223242526272829word-break: normal | break-all | keep-all;normal 使用浏览器默认的换行规则。 break-all 允许在单词内换行。 keep-all 只能在半角空格或连字符处换行。word-wrap: normal | break-word;normal 只在允许的断字点换行（浏览器保持默认处理）。 break-word 在长单词或 URL 地址内部进行换行。1. word-break 当行尾放不下一个单词时，决定单词内部该怎么摆放。 break-all: 强行上，挤不下的话剩下的就换下一行显示呗。霸道型。 keep-all: 放不下我了，那我就另起一行展示，再放不下，我也不退缩。傲骄型。2. word-wrap 当行尾放不下时，决定单词内是否允许换行 normal: 单词太长，换行显示，再超过一行就溢出显示。 break-word: 当单词太长时，先尝试换行，换行后还是太长，单词内还可以换行。3. 上面这些换行神马的都是针对英文单词white-space: normal | nowrap | pre | pre-wrap | pre-line 我们重点关注pre开头的几个属性。pre是preserve(保留)的缩写。没错，它就跟保留空格有关系。pre: 保留所有的空格和回车，且不允许折行。 pre-wrap: 保留所有的空格和回车，但是允许折行。 pre-line: 会合并空格，且允许折行solution：word-break: keep-all;word-wrap: break-word;white-space: pre-wrap; css优化 加载性能 不要用 import ，压缩，主要是从减少文件体积、减少阻塞加载、提高并发 选择器性能 避免使用通用选择器避免使用多层标签选择器。使用 class 选择器替换，减少css查找 渲染性能 看看是不是大量使用了 text-shadow？是不是开了字体抗锯齿？CSS 动画怎么实现的？合理利用 GPU 加速了吗 可维护性、健壮性 命名合理吗？结构层次设计是否足够健壮？对样式进行抽象复用了吗？优雅的 CSS 不仅仅会影响后期的维护成本，也会对加载性能等方面产生影响 BFC前置知识 用于决定块盒子的布局及浮动相互影响范围的一个区域。 在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。 它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用 创建了 BFC的元素就是一个独立的盒子，独立盒子里的布局不受外部影响，当然它也不会影响到外面的元素。 出现条件下列情况将创建一个块格式化上下文： 根元素或其它包含它的元素 浮动 (元素的 float 不为 none) 绝对定位元素 (元素的 position 为 absolute 或 fixed) 行内块 inline-blocks (元素的 display: inline-block) overflow 的值不为 visible的元素 弹性盒子 flex boxes (元素的 display: flex 或 inline-flex) 作用 清除内部浮动 我们在布局时经常会遇到这个问题：对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden。 解决margin叠加问题 外边距重叠就是margin-collapse。 在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠结果遵循下列计算规则： - 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 - 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 - 两个外边距一正一负时，折叠结果是两者的相加的和。 用于布局 元素的左外边距会触碰到包含块容器的做外边框，就算存在浮动也会如此","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Css","slug":"Css","permalink":"http://wiki.haoqiao.me/tags/Css/"},{"name":"考点","slug":"考点","permalink":"http://wiki.haoqiao.me/tags/考点/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Css","slug":"前端/基础/Css","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Css/"}]},{"title":"基础","date":"2017-07-10T11:02:31.000Z","path":"wiki/前端/基础/Html/基础/","text":"Doctype作用？标准模式与兼容(怪异)模式各有什么区别? 1.告知浏览器的解析器用什么文档标准解析这个文档2.标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容(怪异)模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作 常见元素 行内元素:默认display属性值为“inline”，是“行内”元素 a b span img input select strong 块级元素:默认display默认值为“block”，则为“块级”元素 p div ul ol li dl dt dd h1 h2 h3 h4… 空元素 br hr img input link meta 什么是 “use strict”? 使用它的好处和坏处是什么 优点 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全，比如: 修复局部css 不允许if/while/for 里面定义函数 去除了with(){} 定义变量必须加var 3 提高编译器效率，增加运行速度； 缺点 *在一个全局环境下使用严格模式，会使得非严格模式下的代码merge后可能出现问题 img元素中alt和title区别 alt是给搜索引擎识别，在图像无法显示时的替代文本 title 关于元素的注释信息，主要是给用户解读。当鼠标放到文字或是图片上时有title文字显示 input的disabled 和readonly的区别 disabled 对于所有的表单元素都有效，包括select, radio, checkbox, buttoninput的字段当为diabled时时无法获取数值不能编辑和获取焦点使用表单post或get传递时不会被传递出去。但是被disabled掉的按钮就无法使用了不管上面有没有事件. readonly 只针对input(text / password)和textarea有效不能编辑和获取焦点使用表单post或get传递时会被传递出去。点击被readonly掉的按钮照样可以触发事件 HTML语义化 用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的 data-xxx的作用 data-属性用于存储页面或应用程序的私有自定义数据。data-属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。 请描述一下 cookies，sessionStorage 和 localStorage 的区别 cookie:如果不设置过期时间，默认关闭浏览器消失。cookie可存储大小不能超过4k.cookie每次随HTTP一起发送，浪费带宽 localStorage:存储持久数据，浏览器关闭后数据不丢失除非主动删除数据.储存数据可达5M.数据保存在硬盘。 来源限制localStorage对来源的认定是根据以下规则：协议+域名+端口协议http:// 里面的数据和 https:// 里面的是分离的所以http://www.demo-domain.com/下面localStorage里面的数据，在https://www.demo-domain.com/里面是没法访问到的域名域名是必须完全一致的，下属的二级，三级域名都是没法访问根域名下面的数据的。所以http://t.www.demo-domain.com/是没法访问到http://www.demo-domain.com/页面里面localStorage的数据 sessionStrage(属于Localstorage一种)： session即会话的意思，在这里的session是指用户浏览某个网站时，从进入网站到关闭网站这个时间段，session对象的有效期就只有这么长 form表单当前页面无刷新提交 form Target属性： _blank在新窗口/选项卡中打开。 _self在同一框架中打开。*（默认）_parent在父框架中打开。 _top在整个窗口中打开。 framename在指定的框架中打开。 定义一个 div 或者 iframe ,设置为 hidden , form 的 target 设置为 该 div 或者 iframe 的id 给form的submit事件绑定函数 做异步提交 iframe的优缺点 优点 跨域通信用iframe实现无刷新文件上传，在FormData不可用时作为替代方案创建一个全新的独立的宿主环境 缺点 iframe会阻塞主页面的Onload事件iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。多框架的页面会增加服务器的http请求使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript 动态给iframe添加src属性值，这样可以绕开以上两个问题。","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"基础","slug":"基础","permalink":"http://wiki.haoqiao.me/tags/基础/"},{"name":"Html","slug":"Html","permalink":"http://wiki.haoqiao.me/tags/Html/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Html","slug":"前端/基础/Html","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Html/"}]},{"title":"LocalStorage","date":"2017-07-10T11:02:31.000Z","path":"wiki/前端/基础/Html/LocalStorage/","text":"概述","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Html","slug":"Html","permalink":"http://wiki.haoqiao.me/tags/Html/"},{"name":"LocalStorage","slug":"LocalStorage","permalink":"http://wiki.haoqiao.me/tags/LocalStorage/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Html","slug":"前端/基础/Html","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Html/"}]},{"title":"cookie","date":"2017-07-10T11:02:31.000Z","path":"wiki/前端/基础/Html/Cookie/","text":"概述时效期cookie默认的有效期很短，只能持续在web浏览器会话期间，一旦用户关闭浏览器，保存的数据就丢失了。因此要明确告诉浏览器cookie的有效期是多长，一旦设置了有效期，浏览器就会将cookie存储在一个文件中，直到过了指定有效期才会删除。 浏览器在发送cookie时会发送哪几个部分[面试考点] expires expires 选项用来设置 Cookie 什么时间内有效，expires 其实是 Cookie 失效日期。expires 必须是 GMT 格式的时间 max-age expires 是 http/1.0 协议中的选项，在新的 http/1.1 协议中 expires 已经由 max-age 选项代替，两者的作用都是限制 Cookie 的有效时间。expires 的值是一个时间点 (Cookie 失效时刻 = expires)，而 max-age 的值是一个以秒为单位时间段 (Cookie 失效时刻 = 创建时刻 + max-age) domain 和 path name、domain 和 path 可以标识一个唯一的 Cookie。domain 和 path 两个选项共同决定了 Cookie 何时被浏览器自动添加到请求头部中发送出去。 如果没有设置这两个选项，则会使用默认值。domain 的默认值为设置该 Cookie 的网页所在的域名，path 默认值为设置该 Cookie 的网页所在的目录。 Cookie 的作用域和作用路径 只要满足作用域和作用路径，请求就会带上 Cookie，就算端口号不一样。 在子路径内可以访问访问到父路径的 Cookie，反过来就不行。 securesecure选项用来设置cookie只在确保安全的请求中才会发送。当请求是HTTPS或者其他安全协议时，包含secure选项的cookie才能被发送至服务器。 response头的set-cookie字段 一个 Set-Cookie 字段只能设置一个 Cookie，当你要想设置多个 Cookie，需要添加同样多的 Set-Cookie 字段 服务端可以设置 Cookie 的所有选项：expires、domain、path、secure、HttpOnly 作用通过使用Set－Cookie头，一个HTTP服务器可以传递name/value键值对以及相对应的元数据（所谓的cookies）到user agent。当user agent向服务器发送后续请求时，user agent会根据元数据和其他信息来决定是否要在Cookie头中返回name/value键值对。 为了存储状态，源服务器在HTTP响应中包含了一个Set-Cookie头。在后续的请求中，user agent将回传一个Cookie请求头到源服务器。Cookie头包含了user agent在前面Set-Cookie头中包含的cookie。源服务器可以选择忽略Cookie头或将Cookie用于应用所定义的目的。 为了移除一个cookie，服务器要返回一个把过期时间设置在过去的Set-Cookie字段。服务器只有在Set-Cookie头中Path和Domain属性与创建cookie时相符时，才能成功删除cookie。 cookie操作Javascript Array Syntax1234567891011121314151617181920212223242526272829303132333435363738394041424344var CookieUtil = &#123; get: function(name) &#123; var cookieName = encodeURIComponent(name) + '=', cookieStart = document.cookie.indexOf(cookieName), cookieValue = null; if (cookieStart》 - 1) &#123; var cookieEnd = document.cookie.indexOf(';', cookieStart); if (cookieEnd == -1) &#123; cookieEnd = document.cookie.length; &#125; cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); &#125; return cookieValue; &#125;, set: function(name, value, expires, path, domain, secure) &#123; var cookieText = encodeURIComponent(name) + '=' + encodeURIComponent(value); if (expires instanceof Date) &#123; cookieText += '; expires=' + expires.toGMTString(); &#125; if (path) &#123; cookieText += '; path=' + path; &#125; if (domain) &#123; cookieText += '; domain=' + domain; &#125; if (secure) &#123; //secure在这里是布尔值 cookieText += '; secure'; &#125; document.cookie = cookieText; &#125;, unset: function(name, path, domain, secure) &#123; this.set(name, '', new Date(0), path, domain, secure); &#125;&#125;;CookieUtil.set(\"name\", \"Nicholas\");CookieUtil.set(\"book\", \"Professional JavaScript\");//读取 cookie 的值console.log(CookieUtil.get(\"name\")); //\"Nicholas\"console.log(CookieUtil.get(\"book\")); //\"Professional JavaScript\" cookie的名/值 键中是不允许包含分号，逗号，空白符，因此用encodeURLComponent编码 缺点 Cookie会被附加在每个HTTP请求中，所以无形中增加了流量由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Html","slug":"Html","permalink":"http://wiki.haoqiao.me/tags/Html/"},{"name":"Cookie","slug":"Cookie","permalink":"http://wiki.haoqiao.me/tags/Cookie/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Html","slug":"前端/基础/Html","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Html/"}]},{"title":"HTML5","date":"2017-07-10T11:02:31.000Z","path":"wiki/前端/基础/Html/HTML5/","text":"HTML5新特性 1.绘画 canvas; 用于媒介回放的 video 和 audio 元素; 2.本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; 语意化更好的内容元素，比如 article、footer、header、nav、section; 表单控件，calendar、date、time、email、url、search; 新的技术webworker, websocket, Geolocation; 详细划分离线Application cacheLocal storageIndexed DB在线/离线事件离线应用manifest文件 前置知识 1234web应用程序的本地缓存是通过每个页面的manifest文件来管理的，它是一个文本文件，以清单的形式列举了需要缓存或不需要被缓存的资源文件的文件名称真正运行或测试离线应用时，需要让服务器支持text/cache-manifest 存储Application cacheLocal storageIndexed DB 连接Web sockets Server-sent事件 文件访问File ApiFile SystemFileWriterProgressEvents 语义Mediastructural 国际化Link relation 属性form类型microdata 音频和视频Html5 VideoWeb AudioWebRTCVideo track3D和图形Canvas 2D3D css转换WEBGLSVG 展示Css3 2D/3D 变换转换transitionWebFonts 性能Web WorkerHTTP caching 其它触控和鼠标Shadow DOMCSS masking 兼容IE8/IE7/IE6支持通document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式。 使用polyfill","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"Html","slug":"Html","permalink":"http://wiki.haoqiao.me/tags/Html/"},{"name":"HTML5","slug":"HTML5","permalink":"http://wiki.haoqiao.me/tags/HTML5/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"基础","slug":"前端/基础","permalink":"http://wiki.haoqiao.me/categories/前端/基础/"},{"name":"Html","slug":"前端/基础/Html","permalink":"http://wiki.haoqiao.me/categories/前端/基础/Html/"}]},{"title":"算法面试考点","date":"2017-07-10T03:44:26.000Z","path":"wiki/数据结构与算法/算法/算法面试考点/","text":"","tags":[{"name":"算法","slug":"算法","permalink":"http://wiki.haoqiao.me/tags/算法/"},{"name":"面试考点","slug":"面试考点","permalink":"http://wiki.haoqiao.me/tags/面试考点/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/"},{"name":"算法","slug":"数据结构与算法/算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/"}]},{"title":"选择排序","date":"2017-07-10T03:44:26.000Z","path":"wiki/数据结构与算法/算法/排序算法/选择排序/","text":"概述找到数组中最小的那个元素，将它和数组的第一个元素交换位置，如果第一个元素就是最小的那么就和自己交换然后，在剩下的数组中找到最小的元素，将它和数组的第二个元素交换循环直到排序完成。内循环只比较大小，交换代码在内循环之外每次交换都排定一个元素，交换的总次数为N javascript实现Javascript Array Syntax123456789101112131415161718192021222324var tools = require('../tools.js')var newArr = tools.getRandomArr()console.log(\"选择排序\")function SelectionSort(arr) &#123; var n = arr.length console.log(\"原数组:\" + \"\\n\") tools.show(arr) for (var i = 0; i &lt; n; i++) &#123; var min = i // 最小元素的索引 for (var j = i + 1; j &lt; n; j++) &#123; if (tools.less(arr[j], arr[min])) &#123; min = j &#125; &#125; tools.exch(arr, i, min) &#125; console.log(\"排序后:\" + \"\\n\") tools.show(arr)&#125;SelectionSort(newArr)","tags":[{"name":"算法","slug":"算法","permalink":"http://wiki.haoqiao.me/tags/算法/"},{"name":"排序算法","slug":"排序算法","permalink":"http://wiki.haoqiao.me/tags/排序算法/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/"},{"name":"算法","slug":"数据结构与算法/算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/"},{"name":"排序算法","slug":"数据结构与算法/算法/排序算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/排序算法/"}]},{"title":"插入排序","date":"2017-07-10T03:44:26.000Z","path":"wiki/数据结构与算法/算法/排序算法/插入排序/","text":"概述 插入排序它将数组分成“已排序”和“未排序”两部分，一开始的时候，“已排序”的部分只有一个元素，然后将它后面一个元素从“未排序”部分插入“已排序”部分，从而“已排序”部分增加一个元素，“未排序”部分减少一个元素。以此类推，完成全部排序。 插入排序有两种处理，普通的是直接交换，优化的是将内循环中较大的元素都向右移动而不是交换。 索引左边都是已排序的，但最终位置不确定，当索引到达数组最右端，数组排序完成。 javascript实现Javascript Array Syntax123456789101112131415161718192021222324252627282930313233343536373839404142434445var tools = require('../tools.js')var newArr = tools.getRandomArr()// 用less是升序，用more降序// 直接交换法function InsertionSort(arr) &#123; var len = arr.length console.log(\"原数组:\" + \"\\n\") tools.show(arr) for (var i = 0; i &lt; len; i++) &#123; // 将arr[i]插入到a[i-1] a[i-2] a[i-3]..之中 // 内循环从i位置出发，往左走，将arr[i]插入到合适位置 for (var j = i; j &gt; 0 &amp;&amp; tools.less(arr[j], arr[j - 1]); j--) &#123; tools.exch(arr, j, j - 1) &#125; &#125; console.log(\"排序后:\" + \"\\n\") tools.show(arr)&#125;// 元素右移法function insertion(arr) &#123; var len = arr.length console.log(\"原数组:\" + \"\\n\") tools.show(arr) for (var i = 0; i &lt; len; i++) &#123; // 内循环先指定插入项 var insertion = arr[i]; var j = i; // 依旧从i位置出发,往左走,大于插入项的都右,此时插入项已经被覆盖 while (j &gt; 0 &amp;&amp; tools.less(insertion,arr[j - 1])) &#123; arr[j] = arr[j - 1]; j--; &#125; // 找到合适位置重置该内容为插入项。 arr[j] = insertion; &#125; console.log(\"排序后:\" + \"\\n\") tools.show(arr)&#125;InsertionSort(newArr)insertion(newArr)","tags":[{"name":"算法","slug":"算法","permalink":"http://wiki.haoqiao.me/tags/算法/"},{"name":"排序算法","slug":"排序算法","permalink":"http://wiki.haoqiao.me/tags/排序算法/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/"},{"name":"算法","slug":"数据结构与算法/算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/"},{"name":"排序算法","slug":"数据结构与算法/算法/排序算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/排序算法/"}]},{"title":"二叉堆","date":"2017-07-10T03:44:26.000Z","path":"wiki/数据结构与算法/数据结构/二叉堆/","text":"概述二叉堆能实现优先队列的基本操作。二叉堆的数组中，每个元素要保证大于等于另两个特定位置的元素。这些元素又至少要大于等于数组中的另外两个元素。将其转为树结构。(这称为最大堆,也有最小堆。) 在堆有序的二叉树中，每个节点都小于等于它的父节点。根节点是堆有序的二叉树中的最大节点。 二叉堆 是一组能够用堆有序的完全二叉树排序的元素。并在数组中按照层级储存。(不使用数组的第一个元素)在一个二叉堆中，位置k的结点的父结点的位置为[k/2] 它的两个子节点的位置分别为2k和2k+1可以通过计算数组的索引在树种上下移动从a[k]向上一层就令k等于k/2，向下一层就令k等于2k或2k+1 用N+1长度的数组表示一个大小为N的二叉堆，不使用数组第一个元素Array[0] 堆的有序化为:打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复。 由下至上的堆有序化(上浮)：如果一个子节点比它父节点大了，那么交换它和它父节点的位置。如果交换后又比现在的父节点大，那么持续这个动作直到条件不符。位置k的节点的父节点的位置是[k/2] 由上至下的堆有序化(下沉)某个父节点变得比它两个子节点或是其中一个更小，通过将它和它的两个子节点中较大者交换来恢复堆。交换可能还比子节点小，不断用相同方式将其修复。 javascript实现Javascript Array Syntax123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104var tools = require('../tools.js')var newArr = tools.getRandomArr()function heapSort2(arr) &#123; function less(a, b) &#123; return a &lt; b &#125; function exch(arr, a, b) &#123; var temp = arr[a] arr[a] = arr[b] arr[b] = arr[a] &#125; // 上浮 function swim(k) &#123; while (k &gt; 1 &amp;&amp; less(k / 2, k)) &#123; exch(k / 2, k) k = k / 2 &#125; &#125; // 下沉 function sink(arr, k, N) &#123; while (2 * k &lt;= N) &#123; var j = 2 * k if (j &lt; N &amp;&amp; less(j, j + 1)) &#123; j++ &#125; if (!less(k, j)) break; exch(k, j) k = j &#125; &#125;&#125;// 具体实现function heapSort(array) &#123; function swap(array, i, j) &#123; var temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; function maxHeapify(array, index, heapSize) &#123; var iMax, iLeft, iRight; while (true) &#123; iMax = index; iLeft = 2 * index + 1; iRight = 2 * (index + 1); if (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) &#123; iMax = iLeft; &#125; if (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123; iMax = iRight; &#125; if (iMax != index) &#123; swap(array, iMax, index); index = iMax; &#125; else &#123; break; &#125; &#125; &#125; function buildMaxHeap(array) &#123; var i, iParent = Math.floor(array.length / 2) - 1; for (i = iParent; i &gt;= 0; i--) &#123; maxHeapify(array, i, array.length); &#125; &#125; function sort(array) &#123; buildMaxHeap(array); for (var i = array.length - 1; i &gt; 0; i--) &#123; swap(array, 0, i); maxHeapify(array, 0, i); &#125; return array; &#125; return sort(array);&#125;console.log(\"原数组是:\" + newArr)console.log(\"排序后:\" + \"\\n\")tools.show(heapSort(newArr))console.log(\"该数组是否已经排序完成:\" + tools.binaryHeadChecker(heapSort(newArr), \"up\"))","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://wiki.haoqiao.me/tags/数据结构/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/"},{"name":"数据结构","slug":"数据结构与算法/数据结构","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/数据结构/"}]},{"title":"栈","date":"2017-07-10T03:44:26.000Z","path":"wiki/数据结构与算法/数据结构/栈/","text":"javascript实现栈Javascript Array Syntax1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function Stack() &#123; this.items = []&#125;Stack.prototype = &#123; constructor: Stack, //重写整个Prototype的时候不会有constructor，因此要自己重写指向 push: function(data) &#123; this.items[this.items.length] = data return this.items &#125;, pop: function() &#123; return this.items.pop() &#125;, clear: function() &#123; this.items = [] &#125;, peek: function() &#123; // 这个方法主要是在Java里，查看栈顶的元素但是不移动它 return this.items[this.items.length - 1] &#125;, empty: function() &#123; return this.items.length === 0 &#125;, length: function() &#123; return this.items.length+1 &#125;&#125;var stack = new Stack();stack.push('k');stack.push('b');console.log(stack.peek()); //输出bstack.pop();console.log(stack.peek()); //输出k//链表实现function Stack() &#123; this.top = null; this.size = 0;&#125;Stack.prototype = &#123; constructor: Stack, push: function(data) &#123; var node = &#123; data: data, next: null &#125;; node.next = this.top; this.top = node; this.size++; &#125;, pop: function() &#123; if (this.top === null) &#123; return null; &#125; var out = this.top; this.top = this.top.next; if (this.size &gt; 0) &#123; this.size--; &#125; return out.data; &#125;, perk: function() &#123; return this.top === null ? null : this.top.data; &#125;, clear: function() &#123; this.top = null; this.size = 0; &#125;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://wiki.haoqiao.me/tags/数据结构/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/"},{"name":"数据结构","slug":"数据结构与算法/数据结构","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/数据结构/"}]},{"title":"链表","date":"2017-07-10T03:44:26.000Z","path":"wiki/数据结构与算法/数据结构/链表/","text":"javascript实现栈Javascript Array Syntax1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586var LinkedList = function() &#123; this.Node = function(element) &#123; this.element = element; this.next = null; &#125;; this.head = new this.Node('head');&#125;;/** * Searches our linked list for a given item * * @param item The value of the node we're looking for * @return &#123;Node&#125; The matching node */LinkedList.prototype.find = function(item) &#123; var currNode = this.head; while (currNode.element !== item) &#123; currNode = currNode.next; &#125; return currNode;&#125;;/** * Instantiates a new node, and adds it to our linked list * * @param element The data to store in the node * @param previous The value of the node after which we want to add our new one */LinkedList.prototype.insert = function(element, previous) &#123; var newNode = new this.Node(element), prev = this.find(previous); newNode.next = prev.next; prev.next = newNode;&#125;;/** * Displays the list's full contents, in the form of an array * * @return &#123;Array&#125; The contents of the list, starting from head */LinkedList.prototype.seeAll = function() &#123; var currNode = this.head, contents = []; while (currNode.next !== null) &#123; contents.push(currNode.next.element); currNode = currNode.next; &#125; return contents;&#125;;/** * Finds the node *before* another node, to allow for deletion * * @param item The value of the node we're interested in * @return &#123;Node&#125; The node that precedes it */LinkedList.prototype.findPrevious = function(item) &#123; var currNode = this.head; while (currNode.next !== null &amp;&amp; currNode.next.element !== item) &#123; currNode = currNode.next; &#125; return currNode;&#125;;/** * Removes a node * * @param item The value of the node we want to remove */LinkedList.prototype.remove = function(item) &#123; var prevNode = this.findPrevious(item); if (prevNode.next !== null) &#123; prevNode.next = prevNode.next.next; &#125;&#125;;module.exports = LinkedList;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://wiki.haoqiao.me/tags/数据结构/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/"},{"name":"数据结构","slug":"数据结构与算法/数据结构","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/数据结构/"}]},{"title":"二分查找","date":"2017-07-10T03:44:26.000Z","path":"wiki/数据结构与算法/算法/二分查找实现/","text":"Javascript Array Syntax12345678910111213141516171819202122232425262728293031323334353637function start(key, arr) &#123; // 二分查找是有序查找，如果无序需要排序 arr.sort() return rank(key, arr, 0, arr.length - 1)&#125;function rank(key, arr, lo, hi) &#123; if (lo &gt; hi) &#123; return -1 &#125; var mid = Math.floor(lo + (hi - lo) / 2) //向下取整 console.log(lo) console.log(hi) console.log(mid) if (key &lt; arr[mid]) &#123; // 如果目标值比现阶段中间值小，继续在左半边查找 return rank(key, arr, lo, mid - 1) &#125; else if (key &gt; arr[mid]) &#123; // 如果目标值比现阶段中间值大，继续在右半边查找 return rank(key, arr, mid + 1, hi) &#125; else &#123; console.log(arr) return mid &#125;&#125;start(6, [2, 3, 4, 6, 3, 7])","tags":[{"name":"算法","slug":"算法","permalink":"http://wiki.haoqiao.me/tags/算法/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/"},{"name":"算法","slug":"数据结构与算法/算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/"}]},{"title":"算法基础","date":"2017-07-10T03:44:26.000Z","path":"wiki/数据结构与算法/算法/算法基础/","text":"复杂度 排序方法 最好时间复杂度 平均时间 最坏时间 辅助空间 稳定性(数组) 描述 插入排序 $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ 稳定 （有序区，无序区）。把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。 希尔排序 $O(n log^2n)$ $O(n^2)$ $O(1)$ 不稳定 每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 有序区，无序区）。在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少。 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(1)$ 不稳定 （最大堆，有序区）。从堆顶把根卸出来放在有序区之前，再恢复堆。 冒泡排序 $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ 稳定 （无序区，有序区）。从无序区通过交换找出最大元素放到有序区前端 快速排序 $O(nlogn)$ $O(n^2)$ $O(logn)$ 不稳定 （小数，基准元素，大数）。在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。 归并排序 $O(nlog^2n)$ $O(nlog^2n)$ $O(1)$ 稳定 把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。可从上到下或从下到上进行 基数排序 $O(k*n)$ $O(k*n)$ $O(n^2)$ 稳定 一种多关键字的排序算法，可用桶排序实现。 不稳定：快选堆希 稳定：插冒归基快慢比较快速 = 归并 = 堆排序 &gt; 希尔 &gt; 冒泡 = 插入 = 选择","tags":[{"name":"算法","slug":"算法","permalink":"http://wiki.haoqiao.me/tags/算法/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/"},{"name":"算法","slug":"数据结构与算法/算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/"}]},{"title":"冒泡排序","date":"2017-07-10T03:44:26.000Z","path":"wiki/数据结构与算法/算法/排序算法/冒泡排序/","text":"概述冒泡排序就是从最开始的位置或结尾的位置反方向对比，如果比它大/小,就交换然后继续走，第一遍走完,最后一个位置是最大值或者最小值 根据上面我的描述很容易明白冒泡排序的时间复杂度是O(n^2),因为它是双重循环 而且它是稳定的。稳定的含义是：稳定排序算法会让原本有相等键值的纪录维持相对次序. javascript实现Javascript Array Syntax1234567891011121314151617181920212223242526272829303132function exch(a, b, arr) &#123; var temp = arr[a] arr[a] = arr[b] arr[b] = temp&#125;function less(a, b) &#123; return a &lt; b&#125;function more(a, b) &#123; return a &gt; b&#125;function bubbleSort(arr) &#123; var len = arr.length for (var i = 0; i &lt; len ; i++) &#123; for (var j = 0; j &lt; len - i ; j++) &#123; if (more(arr[j],arr[j+1])) &#123; exch(j, j + 1, arr) &#125; &#125; &#125; return arr&#125;var nums = [2, 3, 4, 3, 1, 5, 7, 122, 341, -1]console.log(bubbleSort(nums))// [-1, 1, 2, 3, 3, 4, 5, 7, 122, 341] 算法优化对冒泡排序的优化主要是减少交换次数。如果一次扫描中元素没有发生交换，那么排序就可以结束了。为此可设置一标志量flag，默认为false，如果扫描中发生交换了则把flag置为true，下轮扫描前先检查这个变量，如果flag=false则排序结束。更进一步，可以记录每次扫描中最后一次交换的位置，下次扫描的时候只要扫描到上次的最后交换位置就行了，因为后面的都是已经排好序的，无需再比较。 Javascript Array Syntax123456789101112131415161718192021222324251. var temp,bool,m=0;2. var array=[9,8,7,6,5,4,3,2,1];3. for(var i=0;i&lt;array.length-1;i++)&#123;4. //开闭原则中的开关5. bool = true;6. for(var j=0;j&lt;array.length-1-i;j++)&#123;7. if(array[j]]]&gt;array[j+1])&#123;8. //交换两个变量9. temp=array[j];10. array[j]=array[j+1];11. array[j+1]=temp;12. bool=false;//将开关关闭13. &#125;14. &#125;15. //如果内循环中的if没有被执行（开关关闭，执行下面的语句）;16. if(bool)&#123;17. break;18. &#125;19. m++;20. &#125;21. console.log(array+\",比较\"+m+\"轮\");","tags":[{"name":"算法","slug":"算法","permalink":"http://wiki.haoqiao.me/tags/算法/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/"},{"name":"算法","slug":"数据结构与算法/算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/"},{"name":"排序算法","slug":"数据结构与算法/算法/排序算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/排序算法/"}]},{"title":"堆排序","date":"2017-07-10T03:44:26.000Z","path":"wiki/数据结构与算法/算法/排序算法/堆排序/","text":"概述在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作： 最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点 创建最大堆（Build_Max_Heap）：将堆所有数据重新排序 堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 通常堆是通过一维数组来实现的。在数组起始位置为0的情形中： 父节点i的左子节点在位置(2*i+1); 父节点i的右子节点在位置(2*i+2); 子节点i的父节点在位置floor((i-1)/2); javascript实现Javascript Array Syntax123456789101112131415161718192021222324252627282930313233343536373839Array.prototype.heap_sort = function() &#123; var arr = this.slice(0); function swap(i, j) &#123; var tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; function max_heapify(start, end) &#123; //建立父節點指標和子節點指標 var dad = start; var son = dad * 2 + 1; if (son &gt;= end)//若子節點指標超過範圍直接跳出函數 return; if (son + 1 &lt; end &amp;&amp; arr[son] &lt; arr[son + 1])//先比較兩個子節點大小，選擇最大的 son++; if (arr[dad] &lt;= arr[son]) &#123;//如果父節點小於子節點時，交換父子內容再繼續子節點和孫節點比較 swap(dad, son); max_heapify(son, end); &#125; &#125; var len = arr.length; //初始化，i從最後一個父節點開始調整 for (var i = Math.floor(len / 2) - 1; i &gt;= 0; i--) max_heapify(i, len); //先將第一個元素和已排好元素前一位做交換，再從新調整，直到排序完畢 for (var i = len - 1; i &gt; 0; i--) &#123; swap(0, i); max_heapify(0, i); &#125; return arr;&#125;;var a = [3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6];console.log(a.heap_sort());","tags":[{"name":"算法","slug":"算法","permalink":"http://wiki.haoqiao.me/tags/算法/"},{"name":"排序算法","slug":"排序算法","permalink":"http://wiki.haoqiao.me/tags/排序算法/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/"},{"name":"算法","slug":"数据结构与算法/算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/"},{"name":"排序算法","slug":"数据结构与算法/算法/排序算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/排序算法/"}]},{"title":"希尔排序","date":"2017-07-10T03:44:26.000Z","path":"wiki/数据结构与算法/算法/排序算法/希尔排序/","text":"概述 对于大规模乱序数组插入排序很慢，因为它之后交换相邻的元素。 基于插入排序而加快排序速度的希尔排序，可以交换不相邻的元素以对数组局部排序。 并最终用插入排序将局部有序数组排序为整体有序。 数组越大，希尔排序的优势越大 希尔排序的思想是使数组中任意间隔为h的元素都是有序的，一个h有序数组就是h个互相独立的有序数组 编制在一起组成的数组。 在排序时，h如果很大，我们就能将元素移到很远的地方(这样大规模乱序就很排序的很快) 然后不断缩小h，最后以1结尾的h能将数组整体排序。 H一般情况是 N/3 开始递减到1 javascript实现Javascript Array Syntax1234567891011121314151617181920212223242526var tools = require('../tools.js')var newArr = tools.getRandomArr()function ShellSort(arr) &#123; var len = arr.length console.log(\"原数组:\" + \"\\n\") tools.show(arr) var h = 1 // 如果数组比较大，那么按照N/3的规则将其划分 while (h &lt; len / 3) &#123; h = 3 * h + 1 &#125; // 外循环是不断减小h直到1 while (h &gt;= 1) &#123; //内循环是对每个间隔h的数组分别进行插入排序 for (var i = h; i &lt; len; i++) &#123; for (var j = i; j &gt;= h &amp;&amp; tools.less(arr[j], arr[j - h]); j = j - h) &#123; tools.exch(arr, j, j - h) &#125; &#125; h = Math.floor(h / 3) &#125; console.log(\"排序后:\" + \"\\n\") tools.show(arr)&#125;ShellSort(newArr)","tags":[{"name":"算法","slug":"算法","permalink":"http://wiki.haoqiao.me/tags/算法/"},{"name":"排序算法","slug":"排序算法","permalink":"http://wiki.haoqiao.me/tags/排序算法/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/"},{"name":"算法","slug":"数据结构与算法/算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/"},{"name":"排序算法","slug":"数据结构与算法/算法/排序算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/排序算法/"}]},{"title":"快速排序","date":"2017-07-10T03:44:26.000Z","path":"wiki/数据结构与算法/算法/排序算法/快速排序/","text":"概述快速排序,讲一个数组分为两个子数组,将两部分独立排序,当两个子数组都有序了，整个数组就有序了。 在归并排序中，递归调用在处理整个数组之前 在快速排序中，递归调用在处理整个数组之后 在归并排序中，一个数组被等分为两半 在快速排序中，切分的位置决定于数组的内容。 快排就是一开始找个中介，然后把比它小的放左边，比它大的放右边，然后重新对中介两边的数据各自重新找个中介,如此循环 javascript实现Javascript Array Syntax1234567891011121314151617181920212223242526272829303132333435var tools = require('../tools.js')var newArr = tools.getRandomArr() function QuickSort(arr)&#123; if (arr.length &lt;= 1) &#123; return arr &#125; var midIndex = Math.floor(arr.length / 2) var mid = arr.splice(midIndex, 1)[0] var left = [] var right = [] //console.log(\"将中介提取出来后数组是:\" + arr) for (var i = 0 ; i &lt; arr.length ; i++)&#123; //console.log(\"此刻中介是:\" + mid + \"当前元素是:\" + arr[i]) if (arr[i] &lt; mid) &#123; left.push(arr[i]) //console.log(\"移动\" + arr[i] + \"到左边\") &#125; else &#123; right.push(arr[i]) //console.log(\"移动\" + arr[i] + \"到右边\") &#125; &#125; //concat() 先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，然后返回新构建的数组 return QuickSort(left).concat(mid,QuickSort(right))&#125;console.log(\"原数组是:\" + newArr)console.log(\"排序后:\" + \"\\n\")tools.show(QuickSort(newArr))console.log(\"该数组是否已经排序完成:\" + tools.isSorted(QuickSort(newArr),\"up\"))","tags":[{"name":"算法","slug":"算法","permalink":"http://wiki.haoqiao.me/tags/算法/"},{"name":"排序算法","slug":"排序算法","permalink":"http://wiki.haoqiao.me/tags/排序算法/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/"},{"name":"算法","slug":"数据结构与算法/算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/"},{"name":"排序算法","slug":"数据结构与算法/算法/排序算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/排序算法/"}]},{"title":"归并排序","date":"2017-07-10T03:44:26.000Z","path":"wiki/数据结构与算法/算法/排序算法/归并排序/","text":"概述归并操作：将两个有序的数组归并成一个更大的有序数组归并排序: 可以先递归的将一个待排序的数组分成两半分别排序，然后将结果归并。主要优势是能讲任意长度为N的数组排序所需时间和NlogN成正比缺点是所需额外空间和N成正比。 原地归并思想：先将前半部分排序，然后将后半部分排序 javascript实现Javascript Array Syntax1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var tools = require('../tools.js')var newArr = tools.getRandomArr()/* merge部分还不是很理解，待补充。 */function merge(arr, lo, mid, hi) &#123; //将arr[lo...mid] 和 arr[mid+1...hi]归并 var i = lo, j = mid + 1 // 用temp空数组作为额外空间 for (var k = lo; k &lt;= hi; k++) &#123; temp[k] = arr[k] &#125; // 归并到arr[lo,hi] for (var k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) &#123; // 左半边用尽(取右半边元素) arr[k] = temp[j++] &#125; else if (j &gt; hi) &#123; // 右半边用尽(取左半边元素) arr[k] = temp[i++] &#125; else if (tools.less(temp[j], temp[i])) &#123; // 右半边的当前元素小于左半边的当前元素(取右半边的当前元素) arr[k] = temp[j++] &#125; else &#123; //右半边的当前元素大于左半边的当前元素(取左半边的当前元素) arr[k] = temp[i++] &#125; &#125;&#125;var temp = []function MergeSort(arr) &#123; console.log(\"原数组:\" + \"\\n\") tools.show(arr) sort(arr, 0, arr.length - 1) console.log(\"排序后:\" + \"\\n\") tools.show(arr) console.log(\"该数组是否已经排序完成:\" + tools.isSorted(arr,\"up\"))&#125;// 自顶向下的归并排序function sort(arr, lo, hi) &#123; if (hi &lt;= lo) &#123; return &#125; var mid = Math.floor(lo + (hi - lo) / 2) sort(arr, lo, mid) sort(arr, mid + 1, hi) merge(arr, lo, mid, hi)&#125;MergeSort(newArr)","tags":[{"name":"算法","slug":"算法","permalink":"http://wiki.haoqiao.me/tags/算法/"},{"name":"排序算法","slug":"排序算法","permalink":"http://wiki.haoqiao.me/tags/排序算法/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/"},{"name":"算法","slug":"数据结构与算法/算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/"},{"name":"排序算法","slug":"数据结构与算法/算法/排序算法","permalink":"http://wiki.haoqiao.me/categories/数据结构与算法/算法/排序算法/"}]},{"title":"","date":"2017-07-07T17:55:57.000Z","path":"wiki/index/","text":"关于该Wiki 支持多级分类 方便修改和更新内容 部署简单 分类目录可展开和收缩 展开分类时可查看该分类下所有文章 / 词条的标题 每篇文章 / 词条能添加多个分类 / 标签 Wiki 可支持引用内部链接 使用 Markdown 书写文章 / 词条 支持全文搜索（可搜索内容和标题） Demo文章开头开启toc: true 文章右上角有个小目录 1234567---title: Titletoc: falsedate: 2017-05-06 00:37:50tags: [前端]--- 一些MarkDown标记版本使用 使用版本 gulp : v3.9.1 gulp-imagemin : v3.1.1 123- **gulp** : v3.9.1- **gulp-imagemin** : v3.1.1 引用内容&gt; TitleType: Attr 123456&gt;&gt; #### Title&gt;&gt; Type: `Attr`&gt; 代码12345function test()&#123; var a=\"\"; let b = \"\"&#125; 1234567bashfunction test()&#123; var a=&quot;&quot;; let b = &quot;&quot;&#125; 12345&#123;% codeblock Javascript Array Syntax lang:js http://j.mp/pPUUmW MDN Documentation %&#125;var arr1 = new Array(arrayLength);var arr2 = new Array(element0, element1, ..., elementN);&#123;% endcodeblock %&#125; Javascript Array SyntaxMDN Documentation12var arr1 = new Array(arrayLength);var arr2 = new Array(element0, element1, ..., elementN); 参考资料 haoqiao 12&gt; - [haoqiao](http://haoqiao.me) 表格 排序方法 平均时间 最坏时间 辅助空间 稳定性 冒泡排序 $O(n^2)$ $O(n^2)$ $O(1)$ 稳定 简单选择排序 $O(n^2)$ $O(n^2)$ $O(1)$ 稳定 12345| 排序方法 | 平均时间 | 最坏时间 | 辅助空间 | 稳定性 || :----: | :-----------: | :-----------: | :-----------: | :--: || 冒泡排序 | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 稳定 || 简单选择排序 | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 稳定 | Htmljsfiddle 12&#123;% jsfiddle fv61zk81 %&#125; codepen","tags":[],"categories":[]},{"title":"React环境搭配","date":"2017-07-07T16:20:50.000Z","path":"wiki/前端/框架/React/React环境搭配/","text":"环境版本 gulp : v3.9.1 gulp-imagemin : v3.1.1","tags":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/tags/前端/"},{"name":"React","slug":"React","permalink":"http://wiki.haoqiao.me/tags/React/"},{"name":"环境搭配","slug":"环境搭配","permalink":"http://wiki.haoqiao.me/tags/环境搭配/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://wiki.haoqiao.me/categories/前端/"},{"name":"框架","slug":"前端/框架","permalink":"http://wiki.haoqiao.me/categories/前端/框架/"},{"name":"React","slug":"前端/框架/React","permalink":"http://wiki.haoqiao.me/categories/前端/框架/React/"}]}]}