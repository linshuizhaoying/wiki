<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>临水照影&#39;s Wiki</title>
  <subtitle>我们需要不断回顾才能真正记忆。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wiki.haoqiao.me/"/>
  <updated>2018-02-23T06:00:34.000Z</updated>
  <id>http://wiki.haoqiao.me/</id>
  
  <author>
    <name>linshuizhaoying</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>睡眠革命:如何让睡眠更高效</title>
    <link href="http://wiki.haoqiao.me/wiki/%E9%98%85%E8%AF%BB/%E7%9D%A1%E7%9C%A0%E9%9D%A9%E5%91%BD:%E5%A6%82%E4%BD%95%E8%AE%A9%E7%9D%A1%E7%9C%A0%E6%9B%B4%E9%AB%98%E6%95%88/"/>
    <id>http://wiki.haoqiao.me/wiki/阅读/睡眠革命:如何让睡眠更高效/</id>
    <published>2018-02-23T03:56:40.000Z</published>
    <updated>2018-02-23T06:00:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间对睡眠质量不太满意，因此在看到书的时候果断加入到阅读序列。</p>
<p>除去睡眠常识，这本书最重要的其实是做出了一些科学的设定。</p>
<h1 id="睡眠周期了解一下"><a href="#睡眠周期了解一下" class="headerlink" title="睡眠周期了解一下"></a>睡眠周期了解一下</h1><p>书中有个设定就是R90，他将人类睡眠时间以90分钟为周期划分。</p>
<p>也就是你可以选择睡几个完整的睡眠周期。</p>
<p>如果睡眠时间不足你可以在午后，对应晚上的时间去补一个睡眠周期或者 30分钟的休息时间。</p>
<p><img src="http://haoqiao.qiniudn.com/WechatIMG160.jpeg" alt="imgn"></p>
<p><img src="http://haoqiao.qiniudn.com/WechatIMG161.jpeg" alt="imgn"></p>
<h1 id="睡眠习惯了解一下"><a href="#睡眠习惯了解一下" class="headerlink" title="睡眠习惯了解一下"></a>睡眠习惯了解一下</h1><p>常见的睡眠手段包括老生常谈的禁止玩手机：</p>
<p>在天黑以后，蓝光就成了一种不良光线。如果你在入夜之后使用一些电子产品，或者在夜深人静时还对着一片蓝光，就会引发各种健康问题。它将导致克里斯·艾德辛科斯基教授所称的“垃圾睡眠”——受干扰和不充足的睡眠。这是因为，我们的生活方式和各种小玩意儿的出现，妨碍了褪黑素的分泌，并推迟了我们的生物钟。</p>
<p>每个人根据自己情况分为早睡星人和晚睡星人。</p>
<p>感觉这和生活环境与习惯其实有很大关系。现代年轻人大部分都是晚睡党。</p>
<p>对于晚睡星人来说，如果想调整自己的生物钟，让自己能跟上早起星人的节奏，那么早晨的日光极为关键。你可以去买一台模拟日出自然唤醒灯，它能在卧室中模拟日出，从而把你从睡梦中唤醒。这点实测真的可以。晚上12点睡。早睡7点多，房间朝阳，阳光把你唤醒。同理可以想想学校的宿舍其实也是这样。</p>
<p>少喝咖啡：</p>
<p>咖啡因是一种容易让人上瘾的药物，如果每天大量摄入咖啡因，就会对咖啡因产生耐受力。你会需要越来越多的咖啡因才能达到想要的效果。一旦过量摄入咖啡因成为一种常规，那么，当你以为你在超常发挥时，实际情况往往并非如此。你会经常落后那几步，兴奋过度，变成自己的一个影子。因为，你虽然摄入了咖啡因，却只能达到你平时的水平。</p>
<p>也就是在不是很必要的情况下不要喝咖啡。<br>真的困可以调整自己的作息。比如多加30分钟的休息时间。</p>
<p>工作状态中可能在不该困的时间犯困：</p>
<p>每隔90分钟一次的“大脑休息”，能让你再度回到办公桌后的表现大幅提升，并让你的压力水平大幅降低。</p>
<p>当然最关键的是：如果你没有睡好，你的身体会嗜恋甜食。<br>也就是你会胖。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间对睡眠质量不太满意，因此在看到书的时候果断加入到阅读序列。&lt;/p&gt;
&lt;p&gt;除去睡眠常识，这本书最重要的其实是做出了一些科学的设定。&lt;
    
    </summary>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="自我提升" scheme="http://wiki.haoqiao.me/tags/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="读书笔记" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读后感" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>明朝那些事儿-上</title>
    <link href="http://wiki.haoqiao.me/wiki/%E9%98%85%E8%AF%BB/%E6%98%8E%E6%9C%9D%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-%E4%B8%8A/"/>
    <id>http://wiki.haoqiao.me/wiki/阅读/明朝那些事儿-上/</id>
    <published>2017-10-27T11:14:30.000Z</published>
    <updated>2017-10-27T12:17:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很早以前就知道《明朝那些事儿》挺火，从头火到现在，但那个时候呢，对唐朝比较感兴趣.因为有千古一帝-唐太宗。而且风云人物特别多，八卦也多~对明朝的印象好像就是以前那部穿越电视剧,对朱元璋的印象就是来人，把xxx拉出去砍了(然而历史上朱元璋还真的是和秦始皇有点像，万般难题只有一解:杀)。</p>
<p>《明朝那些事儿》还是很长的，一周看了大概二分之一,整体感官就是作者做到了大部分的不偏不倚,将明朝从朱元璋到朱棣再到后来者,每个人物都有血有肉，尤其是对历史上名不见传却起到重要作用的人物描述的很到位~</p>
<p>基本上可以作为一本有考据的历史读物.</p>
<p>之所以从小说读物入手，而不去直接读史记，读正史，是因为我觉得历史需要有趣，只有当你觉得足够有趣才会去深究，这到底是不是这样。不然很容易有倦怠性。因此我给自己列的书单都是从小说到正史。</p>
<h2 id="朱元璋"><a href="#朱元璋" class="headerlink" title="朱元璋"></a>朱元璋</h2><blockquote>
<p>长期的困难生活，最能磨练一个人的意志，有很多人在遇到困难后，只能怨天尤人，得过且过，而另外一些人虽然也不得不在困难面前低头，但他们的心从未屈服，他们不断的努力，相信一定能够取得最后的胜利</p>
<p>对于我们很多人来说，心是最柔弱的地方，它特别容易被伤害，爱情的背叛，亲情的失去，友情的丢失，都将是重重的一击。然而对于朱重八来说，还有什么不可承受的呢？他已经失去一切，还有什么比亲眼看着父母死去而无能为力，为了活下去和狗抢饭吃、被人唾骂，鄙视更让人痛苦！我们有理由相信，就在某一个痛苦思考的夜晚，朱重八把这个最脆弱的地方变成了最强大的力量的来源。</p>
</blockquote>
<p>朱元璋是从最底层出身，这非常励志。但这励志的背后是无人走过的艰辛。</p>
<p>从一个只想活着好好种地的农民，到只想避开战争好好活下去的和尚，再到起义的将领。</p>
<p>可以看到逼上梁山的无奈，水浒还可能是设计让人为贼，而朱元璋是真的硬生生被民不聊生的统治给逼迫造反。</p>
<blockquote>
<p>朱重八将他的名字改成了朱元璋，所谓璋，是一种尖锐的玉器，这个朱元璋实际上就是诛元璋，朱重八把他自己比成诛灭元朝的利器，而这一利器正是元朝的统治者自己铸造出来的。在今后的二十年里，他们都将畏惧这个名字。</p>
</blockquote>
<p>我觉得这个典故很有意思，改名朱元璋。灭元是朱元璋一生心愿，也是他活下去的动力。可以说元朝一手打造出来的造反皇帝。</p>
<blockquote>
<p>朱元璋从小就被官府欺压，自己的悲惨遭遇很大程度上是贪官污吏造成的，这也使得他很不喜欢这些当官的，即使官员们为他干活，在他的内心中对这些人也存在着极大的不信任感。这种不信任感一旦遇到某些因素的触发，就会迅速扩大，进而蔓延到对整个群体的信心缺失。 正如俗话所说“一朝被蛇咬，十年怕草绳”，朱元璋就是这样一个被蛇咬过的人，他被官吏们欺压了几十年，怎么会信任这些人。所以如空印案、郭桓案这样的案件一发生，朱元璋就会迅速将风潮扩大，在他看来，官员都是不可信的。</p>
</blockquote>
<p>童年的阴影造成不信任，这就造成朱元璋对待官员有一点点不爽都凡事都杀杀杀，杀不干净就继续杀，杀的没人了，戴罪当官。毕竟没几个人对小时候父母兄弟全饿死在自己面前而无动于衷。</p>
<p>可以说历史上如此强势的皇帝没几个，杀官杀的相当多，基本上自从朱元璋当上皇帝，他把功高盖主的，作死的，对后代有威胁的，全部都在他挂掉之前带走，顺便还亲自出征带走了一批不老实的元朝遗留。可以说是杀性最强的一个皇帝，这也看出开国皇帝都有一个特征，强势。一旦新朝建立，从农民翻身作为皇帝，好像就会很自然的代入这个角色，这也是一路马上打天下打出来的个性。因为性格偏软的基本都已经作为垫脚石化为白骨。</p>
<blockquote>
<p>对大臣们来说，朱元璋可能不是个好君主，但是对朱元璋的子孙们来说，朱元璋是个好父亲、好祖父。其实朱元璋的这种行为反差的理由也很简单，就如同今天独生子女的家长，特别是那些当年曾经挨过饿的人，自然不忍心让孩子受自己那样的苦，他们恨不得代替子女去承担来他们将来要经受的苦难。 朱元璋确确实实是一个好父亲，他希望自己的子孙能够团结一致，共同辅佐他选定的继承人朱允炆。但就如今天的所谓“代沟”一样，子孙们有自己的打算，特别是皇族的子孙，他们是无法体会朱元璋这种深厚的父爱的，在他们看来，这个白发苍苍的老者早就应该领退休金走人了。他们关注的只是这个老者所坐的那把椅子.</p>
</blockquote>
<h2 id="朱棣"><a href="#朱棣" class="headerlink" title="朱棣"></a>朱棣</h2><p>在父亲把皇位传给兄长的儿子，以后要向一个小屁孩俯首称臣，朱棣就开始想搞事情了.</p>
<p>在皇位面前，人人<code>平等</code>，这个<code>平等</code>是指没人性，没辈分，没怜悯。</p>
<blockquote>
<p>   这一罕见现象的缔造者正是朱棣的死对头朱允炆，正是他的那道不能伤害朱棣性命的旨意使得朱棣数次死里逃生。而那些打仗的士兵们并不是傻瓜，他们十分了解其中的利害关系。 朱棣和朱允炆是叔侄俩，虽然现在刀兵相见，属于敌我矛盾，但万一哪天两人决定不打了，来一场认亲大会，再来个和解，转化为了人民内部矛盾，那可就大大的不妙了。朱棣没准还能当个王爷，闲来无事的时候写本回忆录，记忆起某年某月某日，某某人在某场战役中砍我一刀或者射我一箭，虽然那时朱棣可能仕途上并不得意，但要整个把小兵还是很容易的。</p>
<p>正是出于士兵们的这种考虑，朱棣才得以在乱军之中得以幸免，朱允炆的这道指令最厉害的地方并不在于所谓不得伤害朱棣的命令本身，而是在于无数的南军的将领和士兵们从此命令中看到了两人和解的可能性，面前的这个敌人将来有一天甚至可能会成为自己的主人，所以动手杀朱棣这种费力不讨好的事情实在是没有多少人会去做的。 </p>
</blockquote>
<p>朱允炆不是一个合格的皇帝就在于他面对其它藩王都下得去手，而面对朱棣却乌龙频繁，一个只许活捉不可伤害犹如给朱棣反向奶了一口，而且还加了无敌buff，最终朱棣这个大流氓就靠这个敌人加的正向Buff在敌军中身先士卒多进多出毫发无损。朱棣的成功就告诉我们，人不要脸真的能无敌~</p>
<p>这里还要提到一个人就是<code>姚广孝</code>,明朝的风风雨雨都逃不过和尚，作为一个不合格的和尚姚广孝一心想搞事情来证明自己，后面的历史也说明了，当一个和尚真心想搞事情的时候谁也拦不住。</p>
<p>而且在朱棣后来开始清洗周围人的时候，姚广孝是不多能善终的。(主要不要钱，不要赏赐，不要房子，一心搞事，搞完就跑。)这也可见其智慧。</p>
<p>之所以对其印象深刻还是因为以前看的《雪中悍刀行》里有个<code>杨太岁</code>角色就是以他为原型。</p>
<blockquote>
<p>“世上怎么会有你这样奇异的和尚！长得一双三角眼，就像生病的老虎，你这样的人天性嗜好杀戮，将来你一定会成为刘秉忠那样的人！”</p>
</blockquote>
<p>历史中有很多看相然后使其出名的，当然不乏一些想搞事情的先自己造假，但是也说明了，历史中想搞点事情，你必须先搞定舆论(封建迷信)，当你把大部分人糊弄住了，你才有搞事情的基础。</p>
<p>而且就有现成的例子:</p>
<blockquote>
<p>张信的母亲帮助他做出了抉择，她老人家一听说要逮捕燕王，立刻制止了张信，并说道：“千万不可以这样做（逮捕燕王），我经常听人说，燕王将来必定会取得天下，他这样的人是不会死的，也不是你能够抓住的。”</p>
<p>   我们可能会觉得纳闷，这位老太太平日大门不出，二门不入，她怎么知道这样的“天机”？综合各种情况分析，这位老太太很可能是受到那些散布街头和菜市场的算命先生们传播的谣言影响，得出了这样一个结论。 如此重大的决策，竟然受一个如此可笑的理由和论据影响并最终做出，实在让人觉得啼笑皆非。</p>
</blockquote>
<p>在上帝视角我们可以觉得这很戏剧性，觉得历史很多都是巧合造成的。虽然巧合有，但是这些算命的也是朱棣自己放出去的。<code>这说明想成做成一件事情，你不光需要运气，你还需要自己去制造运气。</code></p>
<blockquote>
<p>太子的悲哀也就在此，无数太子就是这样被自己的父亲玩残的，自古以来，一把手和二把手的关系始终是处理不好的，在封建社会，皇帝就是一把手，太子就是二把手，自然逃脱不了这个规则的制约。 你积极肯干，说你有野心，你消极怠工，说你没前途。 干多了也不行，干少了也不行，其实只是要告诉你，不服我是不行的。 让你干，你就不得休息，不让你干，你就不得好死。 这似乎是很难理解的，到底是什么使得这一滑稽现象反复发生呢？ 答案很简单：权力。 谁分我的权，我就要谁的命！（儿子也不例外）朱棣很明白，他最终是要将权力交给太子的，而在此之前，太子必须有一定的办事能力，为了帝国的未来，无能的废物是不能成为继承人的，所以必须给太子权力和锻炼的机会，但他更明白，要想得一个善终，权利必须在自己手上。</p>
<p>   儿子是不能相信的，老婆是不能相信的，天下人都是不能相信的。 这就是皇帝的悲哀</p>
</blockquote>
<p>每一个皇帝做上那个位置都开始朝着另一个生物进化，而且只有一个人能进化。当<code>种族</code>不同了，以前的同伴，信任的谋士。甚至是亲人。都成了不同<code>种族</code>的。想要培养下一个能进化的人，一边要防着他背叛，一边还要防止他无能.这是一个自相矛盾却又无解的问题。在皇权没有那么集中的年代，<code>种族</code>划分还没有那么明显，当一个统治者是件辛苦的事情。但是到了后来，权利越大，当统治者变成了一件可以将欲望无限放大的事情。<code>进化</code>的机会就一个，培养继承人如同炼蛊。活下来那个最强，也最残暴。</p>
<h2 id="郑和"><a href="#郑和" class="headerlink" title="郑和"></a>郑和</h2><blockquote>
<p>在经过一番整顿后，逐渐稳住阵脚，开始与北军作战，几十万人奋死拼命厮杀，打得天昏地暗，血流成河。战局陷入僵持状态对朱棣是不利的，因为他并不适合打消耗战，为了能够尽快解决战斗，他向身边的人征求作战意见。 此时一个叫马三保的人明确指出，南军的要害就在于李景隆的中军，只要李景隆移动位置，便可趁其立足未稳之机以奇兵左右夹击，定可获胜。朱棣经过思考，采纳了马三保的意见，并任命马三保为部将，一同参加战斗。此时已经天黑，李景隆果然按捺不住，亲自带领中军前来作战，朱棣立刻派出奇兵从其两翼发动猛烈攻击，李景隆果然抵挡不住，败下阵来</p>
<p>马三保的人也因在此战中的优秀表现为朱棣所重用，并引为心腹，此人出生时父母为世道平和，平安成长之意，曾给他取名为和，又由于他在郑村立下大功，被朱棣赐姓“郑”，此后他便改名为郑和。</p>
<p>郑和是一名虔诚的伊斯兰教徒，他的祖父和父亲都信奉伊斯兰教，而所有的伊斯兰教徒心底都有着一个最大的愿望——去圣城麦加朝圣</p>
</blockquote>
<p>这是觉得有意思的地方，以前觉得郑和下西洋就是奉旨。没想到人家是一个有信仰的人~</p>
<p>他一生最后一次下西洋终于完成他的人生目标，去圣城麦加朝圣，虽然回程一半年老衰死。但是他用一生告诉我们一个人，只要倾尽其一生精力，即使是在那个封建的年代，人也可以完成自己的梦想。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>只简单的记了几个人物，但是从他们的经历中，提炼出来的是坚持。每一个完成自己目标的人，期间可能想过放弃，但是他们没有其他选择，放弃就是死亡。在这种只有一条路的选择中，他们选择了坚持。我们现在能看到的是历史记载一瞥而过的文字，而对他们是几年几十年如一日的浓缩。</p>
<p>我们可以从明朝这些历史中看到非常值得敬佩的人，力挽狂澜的于谦，送人头送经验的李景隆。有品德高尚入圣人，也有无耻刷新人底线的。</p>
<p>我们可以看到不同性格不同样的人在不同的相同的环境下做的不同选择，从而一步步演化成历史上的一幕幕。</p>
<p>这很有意思。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;很早以前就知道《明朝那些事儿》挺火，从头火到现在，但那个时候呢，对唐朝比较感兴趣.因为有千古一帝-唐太宗。而且风云人物特别多，八卦也多~对明
    
    </summary>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="自我提升" scheme="http://wiki.haoqiao.me/tags/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="读书笔记" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读后感" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>Lodash源码阅读</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/Lodash/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/框架/Lodash/源码阅读/</id>
    <published>2017-10-14T14:27:13.000Z</published>
    <updated>2017-10-31T02:09:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以前读源码都虎头蛇尾，一心想着用什么工具提高效率啊，用什么方式读更容易啊，要不要先去看看别人的源码注解啊什么的。但是发现源码,Just read it.</p>
<p>正如每日坚持锻炼，去做就好了。先用最”笨”的方法去做。等以后读多了，找到规律了，效率自然上来了。</p>
<p>这次打算读Lodash，和以前的underscore类似，但是这是公司部门有一直使用的基础库，以前没用过，因此在我的计划中排队了好久，现在抽出时间，打算一点点啃完。</p>
<p>Go~</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="chunk"><a href="#chunk" class="headerlink" title="_.chunk"></a>_.chunk</h3><blockquote>
<p>_.chunk(array, [size=1])</p>
</blockquote>
<p>数组中的块函数，通过第二个参数传递将数组分割成指定数量的块，如果数组不够分，那么最后的块就打包剩余的元素。</p>
<p>在看源码之前用以前历史公开课学到的<br>方法来思辨一下。就是代入自己，如果我说作者我需要怎么做，我需要考虑哪些。</p>
<p>像这种成熟的库，一般都会类型检查。因此第一件事情我觉得是<br><code>isArray(arg1)</code></p>
<p>然后是具体功能的解析，那就是如何将数组拆分。那么想到的就是原生的<code>slice</code>函数。</p>
<p>接下来去看源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function chunk(array, size) &#123;</div><div class="line">  size = Math.max(size, 0) // 判断了第二个参数非负数</div><div class="line">  </div><div class="line">  const length = array == null ? 0 : array.length // 判断非空</div><div class="line">  </div><div class="line">  if (!length || size &lt; 1) &#123;</div><div class="line">    return [] // 如果输入非法返回空</div><div class="line">  &#125;</div><div class="line">  let index = 0</div><div class="line">  let resIndex = 0</div><div class="line">  const result = new Array(Math.ceil(length / size)) // 创建最大数量的数组，ceil是向上求整数</div><div class="line"></div><div class="line">  while (index &lt; length) &#123; // 将字符按照size填充填充</div><div class="line">    result[resIndex++] = slice(array, index, (index += size))</div><div class="line">  &#125;</div><div class="line">  return result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中还引用了<code>slice方法</code>.</p>
<p>这之前我就试过把字符串传进去，依旧被当做数组处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function slice(array, start, end) &#123;</div><div class="line">  let length = array == null ? 0 : array.length // 先判断是否为空,字符串会通过检测</div><div class="line">  if (!length) &#123;</div><div class="line">    return []</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  start = start == null ? 0 : start</div><div class="line">  end = end === undefined ? length : end</div><div class="line"></div><div class="line">  // 判断越界情况</div><div class="line">  if (start &lt; 0) &#123;</div><div class="line">    start = -start &gt; length ? 0 : (length + start)</div><div class="line">  &#125;</div><div class="line">  end = end &gt; length ? length : end</div><div class="line">  if (end &lt; 0) &#123;</div><div class="line">    end += length</div><div class="line">  &#125;</div><div class="line">  length = start &gt; end ? 0 : ((end - start) &gt;&gt;&gt; 0)</div><div class="line">  start &gt;&gt;&gt;= 0 //把num变成一个无符号的32位的整数,JavaScript的数组的最大长度是2^32-1，所以这样做也避免了数组的索引超出界限。</div><div class="line"></div><div class="line">  let index = -1</div><div class="line">  const result = new Array(length) // 重新生成一个数组</div><div class="line">  while (++index &lt; length) &#123;</div><div class="line">    result[index] = array[index + start]</div><div class="line">  &#125;</div><div class="line">  return result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可以看到lodash自己封装了一个slice.网上查了下说是比原生快。顺便我做了个最新版本和原生的对比的例子<a href="https://jsperf.com/new-lodash-slice-vs-native-slice" rel="external nofollow noopener noreferrer" target="_blank">slice-vs-slice</a><br>测试后发现比原生的快60%</p>
<p>有兴趣可以去看下原生slice的实现方法</p>
<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="external nofollow noopener noreferrer" target="_blank">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice</a></p>
</blockquote>
<h3 id="compact"><a href="#compact" class="headerlink" title="_.compact"></a>_.compact</h3><blockquote>
<p>_.compact(array)</p>
</blockquote>
<p>返回一个新数组，移除原先数组中无效的值：<code>false, null, 0, &quot;&quot;, undefined, and NaN</code></p>
<p>我想的是直接一个循环过滤掉无效值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function compact(array) &#123;</div><div class="line">  let resIndex = 0</div><div class="line">  const result = []</div><div class="line"></div><div class="line">  if (array == null) &#123;</div><div class="line">    return result</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  for (const value of array) &#123;</div><div class="line">    if (value) &#123;</div><div class="line">      result[resIndex++] = value</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return result</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default compact</div></pre></td></tr></table></figure>
<p>看源码是用for of取值，那么我想了下换成for循环会怎么样？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function compact2(array) &#123;</div><div class="line">  let resIndex = 0</div><div class="line">  const result = []</div><div class="line"></div><div class="line">  if (array == null) &#123;</div><div class="line">    return result</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  for (var i=0 , len &lt; array.length; i&lt; len;i++) &#123;</div><div class="line">    if (array[i]) &#123;</div><div class="line">      result[resIndex++] = array[i]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是一样的结果。</p>
<p>至于效率，看网上文章说居然还是 for 循环比较高…</p>
<blockquote>
<p><a href="https://dailc.github.io/2016/11/25/baseKnowlenge_javascript_jsarrayGoThrough.html" rel="external nofollow noopener noreferrer" target="_blank">数组遍历效率对比</a></p>
</blockquote>
<p>但是在这个例子中经过测试，却是<code>_.compact</code>更快，当然这肯定有chrome更新后对es6的优化有一定影响。</p>
<blockquote>
<p><a href="https://jsperf.com/forof-vs-for" rel="external nofollow noopener noreferrer" target="_blank">forof-vs-for</a></p>
</blockquote>
<h3 id="concat"><a href="#concat" class="headerlink" title="_.concat"></a>_.concat</h3><blockquote>
<p>_.concat(array, [values])</p>
</blockquote>
<p>创建一个新数组，来连接旧数组和新数组或者新值。</p>
<p>在实际例子中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var array = [1];</div><div class="line">var other = _.concat(array, 2, [3], [[4]]);</div><div class="line"> </div><div class="line">console.log(other);</div><div class="line">// =&gt; [1, 2, 3, [4]]</div><div class="line"> </div><div class="line">console.log(array);</div><div class="line">// =&gt; [1]</div></pre></td></tr></table></figure>
<p>可以看到它是不限制后面有多少个数据，如果是数组包含数组，它当做值处理。而且不改变传入的数组。</p>
<p>这肯定需要做一个拷贝。而且需要对传入参数做一个遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function concat() &#123;</div><div class="line">   var length = arguments.length;</div><div class="line">   if (!length) &#123;</div><div class="line">     return [];</div><div class="line">   &#125;</div><div class="line">   var args = Array(length - 1), //去掉第一个参数</div><div class="line">       array = arguments[0],</div><div class="line">       index = length;</div><div class="line"></div><div class="line">   while (index--) &#123;</div><div class="line">     args[index - 1] = arguments[index];</div><div class="line">   &#125;</div><div class="line">   return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>返回的时候有两个函数我们需要进一步看一下</p>
<p><code>copyArray</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function copyArray(source, array) &#123;</div><div class="line">      var index = -1,</div><div class="line">          length = source.length;</div><div class="line"></div><div class="line">      array || (array = Array(length));</div><div class="line">      while (++index &lt; length) &#123;</div><div class="line">        array[index] = source[index];</div><div class="line">      &#125;</div><div class="line">      return array;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>是做了一个浅拷贝。</p>
<p><code>baseFlatten(args, 1))</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function baseFlatten(array, depth, predicate, isStrict, result) &#123;</div><div class="line">     var index = -1,</div><div class="line">         length = array.length;</div><div class="line"></div><div class="line">     predicate || (predicate = isFlattenable);//如果没有传入判断方法，这判断方法为isFlattenable(只有可以执行扁平化就执行)</div><div class="line">     result || (result = []);</div><div class="line"></div><div class="line">     while (++index &lt; length) &#123;</div><div class="line">       var value = array[index];</div><div class="line">       if (depth &gt; 0 &amp;&amp; predicate(value)) &#123;</div><div class="line">         if (depth &gt; 1) &#123;//如果深度大于1（还需要扁平化），递归调用自身，并且depth-1,否则将这个元素值添加到结果数组</div><div class="line">           // Recursively flatten arrays (susceptible to call stack limits).</div><div class="line">           baseFlatten(value, depth - 1, predicate, isStrict, result);</div><div class="line">         &#125; else &#123;</div><div class="line">           arrayPush(result, value);</div><div class="line">         &#125;</div><div class="line">       &#125; else if (!isStrict) &#123;</div><div class="line">         result[result.length] = value;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">     return result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这就是数组包含数组扁平化的秘密。</p>
<h3 id="difference"><a href="#difference" class="headerlink" title="_.difference"></a>_.difference</h3><blockquote>
<p>_.difference(array, [values])</p>
</blockquote>
<p>创建并返回一个不包含在其他给定数组中的数组值的数组，以进行相似性比较。返回数组的顺序和值的引用都由第一个数组决定。</p>
<p>example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.difference([2, 1], [2, 3]);</div><div class="line">// =&gt; [1]</div></pre></td></tr></table></figure>
<p>感觉是取交集，然后从第一个数组中剔除。</p>
<p>肯定会用两个循环，但是应该不是N^2的复杂度，不然会慢死。</p>
<p>看源码的注释：<br><code>* @see union, unionBy, unionWith, without, xor, xorBy, xorWith,</code></p>
<p>计算方式应该是类似的。</p>
<p>通过源码，发现还是要看另一个base引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function difference(array, ...values) &#123;</div><div class="line">  return isArrayLikeObject(array)</div><div class="line">    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))</div><div class="line">    : []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>isArrayLikeObject</code> Returns <code>true</code> if <code>value</code> is an array-like object. 返回判断类数组对象。</p>
<p>在这个函数的源码中可以看到非常直接的判断方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function isArrayLikeObject(value) &#123;</div><div class="line">  return isObjectLike(value) &amp;&amp; isArrayLike(value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>突然领悟到了颗粒化函数的优势，在命名非常直白的情况下，阅读源码和阅读注释都相差不大。</p>
<p>判读对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function isObjectLike(value) &#123;</div><div class="line">  return typeof value == &apos;object&apos; &amp;&amp; value !== null</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>判断数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function isArrayLike(value) &#123;</div><div class="line">  return value != null &amp;&amp; typeof value != &apos;function&apos; &amp;&amp; isLength(value.length)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>数组的特性是length字段。判断length是否存在的函数也挺有学习意义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function isLength(value) &#123;</div><div class="line">  return typeof value == &apos;number&apos; &amp;&amp;</div><div class="line">    value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= MAX_SAFE_INTEGER</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们再回过头来看<code>baseDifference</code></p>
<p>这才是真正的处理函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function baseDifference(array, values, iteratee, comparator) &#123;</div><div class="line">  // arrayIncludes 是es6de includes的polyfill</div><div class="line">  let includes = arrayIncludes </div><div class="line">  </div><div class="line">  let isCommon = true</div><div class="line">  const result = []</div><div class="line">  const valuesLength = values.length</div><div class="line"></div><div class="line">  if (!array.length) &#123; //如果数组为空</div><div class="line">    return result </div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  // 迭代，传进来的参数是 baseFlatten(values, 1, isArrayLikeObject, true)，扁平化后的数组</div><div class="line">  </div><div class="line">  // 如果有遍历器，先对过滤数组进行遍历操作</div><div class="line">  </div><div class="line">  if (iteratee) &#123; </div><div class="line">    values = map(values, (value) =&gt; iteratee(value))</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  // 如果有比较器，includes就引用arrayIncludesWith，并且不正常过滤</div><div class="line">  if (comparator) &#123;</div><div class="line">    includes = arrayIncludesWith</div><div class="line">    isCommon = false</div><div class="line">  &#125;</div><div class="line">  else if (values.length &gt;= LARGE_ARRAY_SIZE) &#123;</div><div class="line">    includes = cacheHas</div><div class="line">    isCommon = false</div><div class="line">    values = new SetCache(values) //过滤数组等于缓存之后的数组</div><div class="line">  &#125;</div><div class="line">  // 处理内容</div><div class="line">  outer:</div><div class="line">   // 每次遍历的原数组中的元素</div><div class="line">  for (let value of array) &#123;  </div><div class="line">  </div><div class="line">  //如果有遍历器，对该元素调用一次，得到计算后的cumputed，否则computed和value一样</div><div class="line">  </div><div class="line">    const computed = iteratee == null ? value : iteratee(value)</div><div class="line"></div><div class="line">    value = (comparator || value !== 0) ? value : 0</div><div class="line">    // 正常过滤并且computed不为NaN</div><div class="line">    if (isCommon &amp;&amp; computed === computed) &#123;</div><div class="line">      let valuesIndex = valuesLength</div><div class="line">      while (valuesIndex--) &#123;</div><div class="line">        // 如果这个元素在过滤数组中存在，跳过</div><div class="line">        if (values[valuesIndex] === computed) &#123;</div><div class="line">          continue outer</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      // 如果不存在，添加添加进结果数组中</div><div class="line">      result.push(value)</div><div class="line">    &#125;</div><div class="line">    // 非正常过滤，调用includes方法，如果通过比较器的规则不包含，将该元素添加进结果数组</div><div class="line">    else if (!includes(values, computed, comparator)) &#123;</div><div class="line">      result.push(value)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  // 返回结果</div><div class="line">  return result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>中间对<code>outer:</code>关键词有点疑问，查了一下，可使用一个标签来唯一标记一个循环，然后使用 break 或 continue 语句来指示程序是否中断循环或继续执行。在这里是 continue 之后跳回到上一层，继续下一步循环.</p>
<blockquote>
<p><a href="https://segmentfault.com/q/1010000002541243" rel="external nofollow noopener noreferrer" target="_blank">请问大家是如何在实践中使用label语句的</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label" rel="external nofollow noopener noreferrer" target="_blank">label</a></p>
</blockquote>
<h3 id="drop"><a href="#drop" class="headerlink" title="_.drop"></a>_.drop</h3><blockquote>
<p>_.drop(array, [n=1])</p>
</blockquote>
<p>创建一个数组，返回从头开始丢弃n个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.drop([1, 2, 3]);</div><div class="line">// =&gt; [2, 3]</div><div class="line"> </div><div class="line">_.drop([1, 2, 3], 2);</div><div class="line">// =&gt; [3]</div></pre></td></tr></table></figure>
<p>这个常规想法也是<code>splice</code>。</p>
<p>但是<code>splice</code>会改变原数组，如果用还需要做个拷贝。</p>
<p>所以直接看源码是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function drop(array, n=1) &#123;</div><div class="line">  const length = array == null ? 0 : array.length</div><div class="line">  return length</div><div class="line">    ? slice(array, n &lt; 0 ? 0 : n, length)</div><div class="line">    : []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>源码里调用了库自带的<code>slice</code></p>
<h3 id="dropRight"><a href="#dropRight" class="headerlink" title="_.dropRight"></a>_.dropRight</h3><blockquote>
<p>_.dropRight(array, [n=1])</p>
</blockquote>
<p>创建一个数组，返回从右边起开始丢弃n个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.dropRight([1, 2, 3]);</div><div class="line">// =&gt; [1, 2]</div><div class="line"> </div><div class="line">_.dropRight([1, 2, 3], 2);</div><div class="line">// =&gt; [1]</div></pre></td></tr></table></figure>
<p>现在很多数组处理函数都配了从右开始处理数据，这种处理肯定不可能进行逆置后再处理，应该就是根据整个数组长度，然后从最后一位开始，根据<code>Array.length</code> 减去你要处理的长度。</p>
<p>对区间进行修剪。</p>
<p>一般来说如果是纯粹的循环，可以直接从末尾开始处理。</p>
<p>我们来看下源码是怎么处理的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function dropRight(array, n=1) &#123;</div><div class="line">  const length = array == null ? 0 : array.length;</div><div class="line">  return length ? slice(array, 0, n &lt; 0 ? 0 : -n) : [];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到依旧还是引用了内置的<code>slice</code> 只是传了一个<code>-n</code></p>
<p>我们有必要来复习一下这个<code>slice</code>函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function slice(array, start, end) &#123;</div><div class="line">  let length = array == null ? 0 : array.length // 先判断是否为空,字符串会通过检测</div><div class="line">  if (!length) &#123;</div><div class="line">    return []</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  start = start == null ? 0 : start</div><div class="line">  end = end === undefined ? length : end</div><div class="line"></div><div class="line">  // 判断越界情况</div><div class="line">  if (start &lt; 0) &#123;</div><div class="line">    start = -start &gt; length ? 0 : (length + start)</div><div class="line">  &#125;</div><div class="line">  end = end &gt; length ? length : end</div><div class="line">  if (end &lt; 0) &#123;</div><div class="line">    end += length</div><div class="line">  &#125;</div><div class="line">  length = start &gt; end ? 0 : ((end - start) &gt;&gt;&gt; 0)</div><div class="line">  start &gt;&gt;&gt;= 0 //把num变成一个无符号的32位的整数,JavaScript的数组的最大长度是2^32-1，所以这样做也避免了数组的索引超出界限。</div><div class="line"></div><div class="line">  let index = -1</div><div class="line">  const result = new Array(length) // 重新生成一个数组</div><div class="line">  while (++index &lt; length) &#123;</div><div class="line">    result[index] = array[index + start]</div><div class="line">  &#125;</div><div class="line">  return result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">if (end &lt; 0) &#123;</div><div class="line">  end += length</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和预料的处理一致。</p>
<h3 id="dropRightWhile"><a href="#dropRightWhile" class="headerlink" title="_.dropRightWhile"></a>_.dropRightWhile</h3><blockquote>
<p><em>.dropRightWhile(array, [predicate=</em>.identity])</p>
</blockquote>
<p>从末尾对数组进行截取，从第一个不满足predicate 条件的元素开始截取数组。predicate接受三个参数（value,index,array）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var users = [</div><div class="line">  &#123; &apos;user&apos;: &apos;barney&apos;,  &apos;active&apos;: true &#125;,</div><div class="line">  &#123; &apos;user&apos;: &apos;fred&apos;,    &apos;active&apos;: false &#125;,</div><div class="line">  &#123; &apos;user&apos;: &apos;pebbles&apos;, &apos;active&apos;: false &#125;</div><div class="line">];</div><div class="line"> </div><div class="line">_.dropRightWhile(users, function(o) &#123; return !o.active; &#125;);</div><div class="line">// =&gt; objects for [&apos;barney&apos;]</div><div class="line"> </div><div class="line">// The `_.matches` iteratee shorthand.</div><div class="line">_.dropRightWhile(users, &#123; &apos;user&apos;: &apos;pebbles&apos;, &apos;active&apos;: false &#125;);</div><div class="line">// =&gt; objects for [&apos;barney&apos;, &apos;fred&apos;]</div><div class="line"> </div><div class="line">// The `_.matchesProperty` iteratee shorthand.</div><div class="line">_.dropRightWhile(users, [&apos;active&apos;, false]);</div><div class="line">// =&gt; objects for [&apos;barney&apos;]</div><div class="line"> </div><div class="line">// The `_.property` iteratee shorthand.</div><div class="line">_.dropRightWhile(users, &apos;active&apos;);</div><div class="line">// =&gt; objects for [&apos;barney&apos;, &apos;fred&apos;, &apos;pebbles&apos;]</div></pre></td></tr></table></figure>
<p>根据后置条件进行过滤剔除。</p>
<p>而且很明显可以进行<code>function</code>判断和对象判断。</p>
<p>因此肯定会先有一个类似 <code>for in</code>的循环对传进来的数组进行遍历。然后再分情况进行判断。</p>
<p>找到源码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function dropRightWhile(array, predicate) &#123;</div><div class="line">  return (array != null &amp;&amp; array.length)</div><div class="line">    ? baseWhile(array, predicate, true, true)</div><div class="line">    : []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对数组是否靠谱进行了验证之后就传到了 <code>baseWhile</code>这个函数进行处理。而且可以看到<code>predicate</code>将我们不定数的参数都包含了。</p>
<p>来看看<code>baseWhile</code>的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function baseWhile(array, predicate, isDrop, fromRight) &#123;</div><div class="line">  const &#123; length &#125; = array</div><div class="line">  // 如果是从右开始删除，下标指向数组末尾，不然指向-1</div><div class="line">  let index = fromRight ? length : -1</div><div class="line"></div><div class="line">  // 根据drop的方向决定下标是增还是减.并且同时进行迭代条件判断。</div><div class="line">  while ((fromRight ? index-- : ++index &lt; length) &amp;&amp;</div><div class="line">    predicate(array[index], index, array)) &#123;&#125;</div><div class="line"></div><div class="line">//如果是删除元素，如果从末尾开始，调用</div><div class="line">Slice(0,index+1),否则调用Slice(index,length)</div><div class="line">  </div><div class="line">  //如果是获取元素，如果从末尾开始，调用</div><div class="line">  Slice(index+1,length),否则调用Slice(0,index)</div><div class="line"> </div><div class="line">  //最后返回切好的数组</div><div class="line">  </div><div class="line">  return isDrop</div><div class="line">    ? slice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))</div><div class="line">    : slice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="dropWhile"><a href="#dropWhile" class="headerlink" title="_.dropWhile"></a>_.dropWhile</h3><blockquote>
<p><em>.dropWhile(array, [predicate=</em>.identity])</p>
</blockquote>
<p>从开始对数组进行截取，从第一个不满足predicate 条件的元素开始截取数组。predicate接受三个参数（value,index,array）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function dropWhile(array, predicate) &#123;</div><div class="line">  return (array != null &amp;&amp; array.length)</div><div class="line">    ? baseWhile(array, predicate, true)</div><div class="line">    : []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>没有传递<code>dropRight</code>参数，因此直接从左到右。还是基于<code>baseWhile</code>就不重复了。</p>
<h3 id="fill"><a href="#fill" class="headerlink" title="_.fill"></a>_.fill</h3><blockquote>
<p>_.fill(array, value, [start=0], [end=array.length])</p>
</blockquote>
<p>使用 value 值来填充（也就是替换） array，从start位置开始, 到end位置结束（但不包含end位置）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var array = [1, 2, 3];</div><div class="line"> </div><div class="line">_.fill(array, &apos;a&apos;);</div><div class="line">console.log(array);</div><div class="line">// =&gt; [&apos;a&apos;, &apos;a&apos;, &apos;a&apos;]</div><div class="line"> </div><div class="line">_.fill(Array(3), 2);</div><div class="line">// =&gt; [2, 2, 2]</div><div class="line"> </div><div class="line">_.fill([4, 6, 8, 10], &apos;*&apos;, 1, 3);</div><div class="line">// =&gt; [4, &apos;*&apos;, &apos;*&apos;, 10]</div></pre></td></tr></table></figure>
<p>填充函数，一看是对原数组进行改变。那么就需要先判断数组边界和开始结束的位置。然后遍历到指定位置就填充。</p>
<p>来看下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function fill(array, value, start, end) &#123;</div><div class="line">       var length = array == null ? 0 : array.length;</div><div class="line">       if (!length) &#123;</div><div class="line">         return [];</div><div class="line">       &#125;</div><div class="line">       if (start &amp;&amp; typeof start != &apos;number&apos; &amp;&amp; isIterateeCall(array, value, start)) &#123;</div><div class="line">         start = 0;</div><div class="line">         end = length;</div><div class="line">       &#125;</div><div class="line">       return baseFill(array, value, start, end);</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>这里我们看到判断start是否存在还有start是不是number，但后面还有一个<code>isIterateeCall</code>，这个看字面意思好像是判断迭代参数。<br>我们来看下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function isIterateeCall(value, index, object) &#123;</div><div class="line">        if (!isObject(object)) &#123;</div><div class="line">          return false;</div><div class="line">        &#125;</div><div class="line">        var type = typeof index;</div><div class="line">        if (type == &apos;number&apos;</div><div class="line">              ? (isArrayLike(object) &amp;&amp; isIndex(index, object.length))</div><div class="line">              : (type == &apos;string&apos; &amp;&amp; index in object)</div><div class="line">            ) &#123;</div><div class="line">          return eq(object[index], value);</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>它的作用是判断start是否为遍历器的参数。</p>
<p>最后是用<code>baseFill</code>函数来完成功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function baseFill(array, value, start, end) &#123;</div><div class="line">       var length = array.length; </div><div class="line"> </div><div class="line">       start = toInteger(start); // 转为整数</div><div class="line">       </div><div class="line">       // 如果start小于0 当 -start的长度都大于数组长度，那么，就默认从数组第一个元素开始。不然就length + start</div><div class="line">       if (start &lt; 0) &#123;</div><div class="line">         start = -start &gt; length ? 0 : (length + start);</div><div class="line">       &#125;</div><div class="line">       // 如果没有指定end参数 或者end大于数组长度，就默认end为数组长度。不然的话就把end转成整型</div><div class="line">       </div><div class="line">       end = (end === undefined || end &gt; length) ? length : toInteger(end);</div><div class="line">       </div><div class="line">       if (end &lt; 0) &#123;</div><div class="line">         end += length;</div><div class="line">       &#125;</div><div class="line">       end = start &gt; end ? 0 : toLength(end);</div><div class="line">       // 用一个循环来搞定</div><div class="line">       while (start &lt; end) &#123;</div><div class="line">         array[start++] = value;</div><div class="line">       &#125;</div><div class="line">       return array;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，一个比较简单填充方法，为了健壮性需要做很多事情。</p>
<h3 id="findIndex"><a href="#findIndex" class="headerlink" title="_.findIndex"></a>_.findIndex</h3><blockquote>
<p><em>.findIndex(array, [predicate=</em>.identity], [fromIndex=0])</p>
</blockquote>
<p>这个方法就像_.find，对数组从开始进行查找，该方法返回符合判断条件的第一个元素的索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var users = [</div><div class="line">  &#123; &apos;user&apos;: &apos;barney&apos;,  &apos;active&apos;: false &#125;,</div><div class="line">  &#123; &apos;user&apos;: &apos;fred&apos;,    &apos;active&apos;: false &#125;,</div><div class="line">  &#123; &apos;user&apos;: &apos;pebbles&apos;, &apos;active&apos;: true &#125;</div><div class="line">];</div><div class="line"> </div><div class="line">_.findIndex(users, function(o) &#123; return o.user == &apos;barney&apos;; &#125;);</div><div class="line">// =&gt; 0</div><div class="line"> </div><div class="line">// The `_.matches` iteratee shorthand.</div><div class="line">_.findIndex(users, &#123; &apos;user&apos;: &apos;fred&apos;, &apos;active&apos;: false &#125;);</div><div class="line">// =&gt; 1</div><div class="line"> </div><div class="line">// The `_.matchesProperty` iteratee shorthand.</div><div class="line">_.findIndex(users, [&apos;active&apos;, false]);</div><div class="line">// =&gt; 0</div><div class="line"> </div><div class="line">// The `_.property` iteratee shorthand.</div><div class="line">_.findIndex(users, &apos;active&apos;);</div><div class="line">// =&gt; 2</div></pre></td></tr></table></figure>
<p>一般来说，对数组查下标我们都是直接IndexOf，但是对对象进行查找。我们需要考虑是否是对象，需要做一些判断。对于对象的属性遍历用 for in。</p>
<p>接下来看下源码是怎么实现的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function findIndex(array, predicate, fromIndex) &#123;</div><div class="line">  var length = array == null ? 0 : array.length;</div><div class="line">  // 数组不存在就返回-1</div><div class="line">  if (!length) &#123;</div><div class="line">    return -1;</div><div class="line">  &#125;</div><div class="line">  var index = fromIndex == null ? 0 : toInteger(fromIndex);</div><div class="line">  if (index &lt; 0) &#123;</div><div class="line">    index = nativeMax(length + index, 0);</div><div class="line">  &#125;</div><div class="line">  return baseFindIndex(array, getIteratee(predicate, 3), index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过一系列判断，最终还是调用基础函数来实习功能，我们从最中心的<code>getIteratee</code>读起，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function getIteratee() &#123;</div><div class="line">  var result = lodash.iteratee || iteratee;</div><div class="line">  result = result === iteratee ? baseIteratee : result;</div><div class="line">  return arguments.length ? result(arguments[0], arguments[1]) : result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果lodash.iteratee被重新定义,则使用用户定义的iteratee，否则就用官方定义的baseIteratee。需要强调的是，result(arguments[0],arguments[1])是柯里化的函数返回，返回的仍旧是一个函数</p>
<p>我们需要看看官方定义的baseIteratee的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function baseIteratee(value) &#123;</div><div class="line">   if (typeof value == &apos;function&apos;) &#123;</div><div class="line">         return value;</div><div class="line">       &#125;</div><div class="line">       if (value == null) &#123;</div><div class="line">         return identity;</div><div class="line">       &#125;</div><div class="line">       if (typeof value == &apos;object&apos;) &#123;</div><div class="line">         return isArray(value)</div><div class="line">           ? baseMatchesProperty(value[0], value[1])</div><div class="line">           : baseMatches(value);</div><div class="line">       &#125;</div><div class="line">       return property(value);</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>getIteratee(iteratee, 3)，给了两个参数，按照逻辑，最终返回的是一个baseIteratee，baseIteratee的第一个参数value就是iteratee,这是一个函数，所以，baseIteratee函数在第一个判断就返回了。</p>
<p>这个判断到不是很理解，先放着。我们来看<br><code>baseFindIndex</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function baseFindIndex(array, predicate, fromIndex, fromRight) &#123;</div><div class="line">  var length = array.length,</div><div class="line">      index = fromIndex + (fromRight ? 1 : -1);</div><div class="line">  </div><div class="line">  while ((fromRight ? index-- : ++index &lt; length)) &#123;</div><div class="line">    if (predicate(array[index], index, array)) &#123;</div><div class="line">      return index;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>核心判断是<code>(predicate(array[index], index, array)</code></p>
<p>而这里的<code>predicate</code>函数是之前传入的<code>getIteratee(predicate, 3)</code></p>
<p>然后调用的是<code>baseIteratee</code>来判断。baseIteratee是封装好的遍历器（让遍历器不仅可以是函数，还可以是属性或者对象）。</p>
<p>这样大体是了解了，对细节感兴趣需要跟踪仔细推敲。</p>
<h3 id="flatten"><a href="#flatten" class="headerlink" title="_.flatten"></a>_.flatten</h3><blockquote>
<p>_.flatten(array)</p>
</blockquote>
<p>对数组执行扁平化一级操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.flatten([1, [2, [3, [4]], 5]]);</div><div class="line">// =&gt; [1, 2, [3, [4]], 5]</div></pre></td></tr></table></figure>
<p>对扁平化还是直接看核心函数<code>baseFlatten</code>源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">   * @param &#123;Array&#125; array 需要处理的数组.</div><div class="line"> * @param &#123;number&#125; depth 扁平化的深度.</div><div class="line"> * @param &#123;boolean&#125; [predicate=isFlattenable] 判断是否执行扁平化操作，对每个元素进行调用.</div><div class="line"> * @param &#123;boolean&#125; [isStrict] 是否遵守predicate的检查.</div><div class="line"> * @param &#123;Array&#125; [result=[]] 初始化结果值.</div><div class="line"> * @returns &#123;Array&#125; 返回扁平化之后的数组.</div><div class="line"> </div><div class="line"> </div><div class="line">function baseFlatten(array, depth, predicate, isStrict, result) &#123;</div><div class="line">// 初始化下标从源头开始</div><div class="line">        var index = -1,</div><div class="line">            length = array.length;</div><div class="line">  </div><div class="line">        predicate || (predicate = isFlattenable); //如果没有传入判断方法，这判断方法为isFlattenable(只有可以执行扁平化就执行)</div><div class="line">        result || (result = []); // 如果没有传入的初始的结果数组，则结果为空数组</div><div class="line">  ////遍历数组中的每个元素</div><div class="line">        while (++index &lt; length) &#123;</div><div class="line">          var value = array[index];</div><div class="line">          if (depth &gt; 0 &amp;&amp; predicate(value)) &#123; // //如果深度大于0并且通过了检查</div><div class="line">            if (depth &gt; 1) &#123;</div><div class="line">              // //如果深度大于1（还需要扁平化），递归调用自身，并且depth-1,否则将这个元素值添加到结果数组</div><div class="line">              baseFlatten(value, depth - 1, predicate, isStrict, result);</div><div class="line">            &#125; else &#123;</div><div class="line">              arrayPush(result, value);</div><div class="line">            &#125;</div><div class="line">            // //如果不需要遵守判断规则，直接将value添加到结果中</div><div class="line">          &#125; else if (!isStrict) &#123;</div><div class="line">            result[result.length] = value;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<h3 id="fromPairs"><a href="#fromPairs" class="headerlink" title="_.fromPairs()"></a>_.fromPairs()</h3><blockquote>
<p>_.fromPairs(pairs)</p>
</blockquote>
<p>此方法返回由键值对组成的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.fromPairs([[&apos;a&apos;, 1], [&apos;b&apos;, 2]]);</div><div class="line">// =&gt; &#123; &apos;a&apos;: 1, &apos;b&apos;: 2 &#125;</div></pre></td></tr></table></figure>
<p>这个看例子是直接生成一个对象，把参数迭代加进去。</p>
<p>来看源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function fromPairs(pairs) &#123;</div><div class="line">        var index = -1,</div><div class="line">            length = pairs == null ? 0 : pairs.length,</div><div class="line">            result = &#123;&#125;;</div><div class="line">  </div><div class="line">        while (++index &lt; length) &#123;</div><div class="line">          var pair = pairs[index];</div><div class="line">          result[pair[0]] = pair[1];</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>和预计一样。</p>
<h3 id="head"><a href="#head" class="headerlink" title="_.head()"></a>_.head()</h3><blockquote>
<p>_.head(array)</p>
</blockquote>
<p>返回数组第一个元素</p>
<p>这个没啥好说，直接取第一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function head(array) &#123;</div><div class="line">     return (array &amp;&amp; array.length) ? array[0] : undefined;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="_.indexOf()"></a>_.indexOf()</h3><blockquote>
<p>_.indexOf(array, value, [fromIndex=0])</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.indexOf([1, 2, 1, 2], 2);</div><div class="line">// =&gt; 1</div><div class="line"> </div><div class="line">// Search from the `fromIndex`.</div><div class="line">_.indexOf([1, 2, 1, 2], 2, 2);</div><div class="line">// =&gt; 3</div></pre></td></tr></table></figure>
<p>在数组中找到第一次出现值的索引，用于等式比较。<br>如果fromIndex为负数，则将其用作从数组结尾的偏移量。</p>
<p>功能很简单，主要是这个偏移量<code>fromIndex</code></p>
<p>从示例中可以看到，不仅是从偏移量开始找，而且最终结果也是计算了偏移量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function indexOf(array, value, fromIndex) &#123;</div><div class="line">       var length = array == null ? 0 : array.length;</div><div class="line">       if (!length) &#123;</div><div class="line">         return -1;</div><div class="line">       &#125;</div><div class="line">       var index = fromIndex == null ? 0 : toInteger(fromIndex);</div><div class="line">       if (index &lt; 0) &#123; // 如果偏移量小于0</div><div class="line">         // 如果在length以内，则右偏移，不然从0开始</div><div class="line">         index = nativeMax(length + index, 0);</div><div class="line">         </div><div class="line">       &#125;</div><div class="line">       return baseIndexOf(array, value, index);</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>查看<code>baseIndexOf</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function baseIndexOf(array, value, fromIndex) &#123;</div><div class="line">    return value === value</div><div class="line">      ? strictIndexOf(array, value, fromIndex)</div><div class="line">      : baseFindIndex(array, baseIsNaN, fromIndex);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>跟着发现最后实习功能是<code>baseFindIndex</code></p>
<p>调用<code>baseFindIndex(array, baseIsNaN, fromIndex)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function baseFindIndex(array, predicate, fromIndex, fromRight) &#123;</div><div class="line">     var length = array.length,</div><div class="line">         index = fromIndex + (fromRight ? 1 : -1);</div><div class="line"> // 循环，对每个元素调用判断方法，如果结果为true,返回对应的index</div><div class="line">     while ((fromRight ? index-- : ++index &lt; length)) &#123;</div><div class="line">     // </div><div class="line">       if (predicate(array[index], index, array)) &#123;</div><div class="line">         return index;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">     return -1;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="initial"><a href="#initial" class="headerlink" title="_.initial()"></a>_.initial()</h3><blockquote>
<p>_.initial(array)</p>
</blockquote>
<p>获取数组的最后一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function initial(array) &#123;</div><div class="line">     var length = array == null ? 0 : array.length;</div><div class="line">     return length ? baseSlice(array, 0, -1) : [];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>直接切了最后一个元素然后返回切割后的数组。</p>
<h3 id="intersection"><a href="#intersection" class="headerlink" title="_.intersection()"></a>_.intersection()</h3><blockquote>
<p>_.intersection([arrays])</p>
</blockquote>
<p>创建包含在所有给定数组中的唯一值数组，以进行相似性比较。<br>结果值的顺序和引用由第一个数组决定。</p>
<p>取出各数组中都有的元素，使用 SameValueZero方式比较（===）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.intersection([2, 1], [2, 3]);</div><div class="line">// =&gt; [2]</div></pre></td></tr></table></figure>
<p>这把两个数组的交集求了出来。如果是我可能两重循环解决。</p>
<p>来看源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 创建具备rest参数的方法</div><div class="line">     var intersection = baseRest(function(arrays) &#123;</div><div class="line">        var mapped = arrayMap(arrays, castArrayLikeObject); // 将所有数组转化为类似数组的对象</div><div class="line">        return (mapped.length &amp;&amp; mapped[0] === arrays[0]) // //如果传入的数组个数不为0,并且第一个参数为数组，调用baseIntersection方法传入mapped，并将结果作为返回值返回，否则返回空数组</div><div class="line">          ? baseIntersection(mapped)</div><div class="line">          : [];</div><div class="line">      &#125;);</div></pre></td></tr></table></figure>
<p>这个<code>baseIntersection</code>看上去就比较复杂了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> /**</div><div class="line"> * _.intersection的基本实现, 不支持遍历器的简写.</div><div class="line"> *</div><div class="line"> * @private</div><div class="line"> * @param &#123;Array&#125; arrays 需要处理的数组.</div><div class="line"> * @param &#123;Function&#125; [iteratee] 遍历器,作用于每个元素.</div><div class="line"> * @param &#123;Function&#125; [comparator] 比较器，作用于每个元素.</div><div class="line"> * @returns &#123;Array&#125; 返回一个数组包含给定所有数组中共有的元素.</div><div class="line"> */</div><div class="line">function baseIntersection(arrays, iteratee, comparator) &#123;</div><div class="line">  var includes = comparator ? arrayIncludesWith : arrayIncludes,//如果有比较器，为arrayIncludesWith,否则为arrayIncludes</div><div class="line">      length = arrays[0].length,//第一个数组的长度</div><div class="line">      othLength = arrays.length,//给定的所有数组的长度</div><div class="line">      othIndex = othLength,//给定所有数组的索引</div><div class="line">      caches = Array(othLength),//创建一个缓存给定数组个数的数组</div><div class="line">      maxLength = Infinity,//最大长度</div><div class="line">      result = [];//返回结果</div><div class="line">  //遍历给定的数组</div><div class="line">  while (othIndex--) &#123;</div><div class="line">    var array = arrays[othIndex];//当前数组</div><div class="line">    if (othIndex &amp;&amp; iteratee) &#123;//如果不是第一个数组，并且有遍历器，对当前数组调用遍历器遍历每个元素</div><div class="line">      array = arrayMap(array, baseUnary(iteratee));//当前数组为调用之后的数组</div><div class="line">    &#125;</div><div class="line">    maxLength = nativeMin(array.length, maxLength);//数组的最大长度</div><div class="line">    //如果该数组长度超过120就创建Set缓存数组中并添加到caches中（用于优化）</div><div class="line">    caches[othIndex] = !comparator &amp;&amp; (iteratee || (length &gt;= 120 &amp;&amp; array.length &gt;= 120))</div><div class="line">      ? new SetCache(othIndex &amp;&amp; array)</div><div class="line">      : undefined;</div><div class="line">  &#125;</div><div class="line">  array = arrays[0];//给定所有数组中的第一个</div><div class="line"></div><div class="line">  var index = -1,//数组索引</div><div class="line">      seen = caches[0];//第一个缓存数组，初始为undefined或者new SetCache(0)</div><div class="line"></div><div class="line">  outer:</div><div class="line">  //遍历第一个数组</div><div class="line">  while (++index &lt; length &amp;&amp; result.length &lt; maxLength) &#123;</div><div class="line">    var value = array[index],//数组元素</div><div class="line">        computed = iteratee ? iteratee(value) : value;//如果有遍历器，对改元素调用,得到计算后的值</div><div class="line"></div><div class="line">    value = (comparator || value !== 0) ? value : 0;//如果有比较器或者value不为0，value为value，否则为0</div><div class="line">    if (!(seen//如果seen有值了，判断是否含有computed，否则判断结果中是否含有computed，如果都没有computed</div><div class="line">          ? cacheHas(seen, computed)</div><div class="line">          : includes(result, computed, comparator)</div><div class="line">        )) &#123;</div><div class="line">      othIndex = othLength;//其他数组的索引，初始为给定数组的长度</div><div class="line">      //遍历给定的数组，除了第一个</div><div class="line">      while (--othIndex) &#123;</div><div class="line">        var cache = caches[othIndex];//缓存数组中的值</div><div class="line">        //太长的数组就是cache,短的就是arrays[index],判断是否含有computed，如果没有，跳过此次循环</div><div class="line">        if (!(cache</div><div class="line">              ? cacheHas(cache, computed)</div><div class="line">              : includes(arrays[othIndex], computed, comparator))</div><div class="line">            ) &#123;</div><div class="line">          continue outer;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      if (seen) &#123;//如果缓存存在，将computed添加到缓存中</div><div class="line">        seen.push(computed);</div><div class="line">      &#125;</div><div class="line">      result.push(value);//将value添加到结果数组中</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return result;//返回结果数组</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="join"><a href="#join" class="headerlink" title="_.join()"></a>_.join()</h3><blockquote>
<p>_.join(array, [separator=’,’])</p>
</blockquote>
<p>将数组中的所有元素转换为由分隔符分隔的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.join([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], &apos;~&apos;);</div><div class="line">// =&gt; &apos;a~b~c&apos;</div></pre></td></tr></table></figure>
<p>讲道理这种插入式的我觉得遍历加入就挺直接的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function join(array, separator) &#123;</div><div class="line">      return array == null ? &apos;&apos; : nativeJoin.call(array, separator);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然后这个直接用的原生<code>join</code>… 是[Native Code]</p>
<p>有兴趣可以看看<a href="http://yincheng.site/chrome-js-array" rel="external nofollow noopener noreferrer" target="_blank">实现方式</a></p>
<h3 id="nth"><a href="#nth" class="headerlink" title="_.nth()"></a>_.nth()</h3><blockquote>
<p>_.nth(array, [n=0])</p>
</blockquote>
<p>获取数组的索引n处的元素。<br>如果n为负，则返回从结尾处的第n个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var array = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];</div><div class="line"> </div><div class="line">_.nth(array, 1);</div><div class="line">// =&gt; &apos;b&apos;</div><div class="line"> </div><div class="line">_.nth(array, -2);</div><div class="line">// =&gt; &apos;c&apos;;</div></pre></td></tr></table></figure>
<p>感觉只需要判断一下索引正负，然后根据判断是否加上数组长度。<br>然后直接按下标取值就行了。</p>
<p>来看源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function nthArg(n) &#123;</div><div class="line">        n = toInteger(n);</div><div class="line">        return baseRest(function(args) &#123;</div><div class="line">          return baseNth(args, n);</div><div class="line">        &#125;);</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function baseNth(array, n) &#123;</div><div class="line">   var length = array.length;</div><div class="line">   if (!length) &#123;</div><div class="line">     return;</div><div class="line">   &#125;</div><div class="line">   n += n &lt; 0 ? length : 0;</div><div class="line">   return isIndex(n, length) ? array[n] : undefined;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function isIndex(value, length) &#123;</div><div class="line">     length = length == null ? MAX_SAFE_INTEGER : length;</div><div class="line">     return !!length &amp;&amp;</div><div class="line">       (typeof value == &apos;number&apos; || reIsUint.test(value)) &amp;&amp;</div><div class="line">       (value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt; length);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看到思路是一样的，不过做了两个处理一个是对参数进行处理转为数组。一个是对下标进行验证。</p>
<h3 id="pull"><a href="#pull" class="headerlink" title="_.pull()"></a>_.pull()</h3><blockquote>
<p>_.pull(array, [values])</p>
</blockquote>
<p>使用SameValueZero（===）从数组中删除所有给定的值以进行相等的比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var array = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</div><div class="line"> </div><div class="line">_.pull(array, &apos;a&apos;, &apos;c&apos;);</div><div class="line">console.log(array);</div><div class="line">// =&gt; [&apos;b&apos;, &apos;b&apos;]</div></pre></td></tr></table></figure>
<p>这个和filter类似，不过可以传入多个值。如果是filter来做，应该是做连续判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function pullAll(array, values) &#123;</div><div class="line">       return (array &amp;&amp; array.length &amp;&amp; values &amp;&amp; values.length)</div><div class="line">         ? basePullAll(array, values)</div><div class="line">         : array;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function basePullAll(array, values, iteratee, comparator) &#123;</div><div class="line">        var indexOf = comparator ? baseIndexOfWith : baseIndexOf, // //选择indexOf方法，如果传入比较器为baseIndexOfWith,否则为baseIndexOf</div><div class="line">            index = -1,</div><div class="line">            length = values.length,</div><div class="line">            seen = array;</div><div class="line">  </div><div class="line">        if (array === values) &#123; //如果需要移除的元素和需要修改的数组一样，拷贝一份values</div><div class="line">          values = copyArray(values);</div><div class="line">        &#125;</div><div class="line">        if (iteratee) &#123; // 如果存在遍历器，对数组进行遍历操作</div><div class="line">          seen = arrayMap(array, baseUnary(iteratee));</div><div class="line">        &#125;</div><div class="line">        while (++index &lt; length) &#123;</div><div class="line">          var fromIndex = 0,</div><div class="line">              value = values[index],</div><div class="line">              computed = iteratee ? iteratee(value) : value;//如果有遍历器对value进行调用，得到 计算后的value(也就是computed)</div><div class="line">  </div><div class="line">    //循环执行indexOf方法，如果seen中，直到找不到computed为止</div><div class="line">          while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) &gt; -1) &#123;</div><div class="line">            if (seen !== array) &#123;</div><div class="line">              splice.call(seen, fromIndex, 1);  ///seen和array不相等即存在遍历器,对seen执行splice方法移除fromIndex的元素</div><div class="line">            &#125;</div><div class="line">            splice.call(array, fromIndex, 1);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        return array;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>也是在循环里剔除。</p>
<h3 id="remove"><a href="#remove" class="headerlink" title="_.remove()"></a>_.remove()</h3><blockquote>
<p><em>.remove(array, [predicate=</em>.identity])</p>
</blockquote>
<p>从数组中删除谓词返回真值的所有元素，并返回已删除元素的数组。<br>谓词被调用三个参数：（value，index，array）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var array = [1, 2, 3, 4];</div><div class="line">var evens = _.remove(array, function(n) &#123;</div><div class="line">  return n % 2 == 0;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">console.log(array);</div><div class="line">// =&gt; [1, 3]</div><div class="line"> </div><div class="line">console.log(evens);</div><div class="line">// =&gt; [2, 4]</div></pre></td></tr></table></figure>
<p>直接对原数组做操作。感觉用Map可以做到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function remove(array, predicate) &#123;</div><div class="line">				  // 判断合法数组</div><div class="line">        var result = [];</div><div class="line">        if (!(array &amp;&amp; array.length)) &#123; </div><div class="line">          return result;</div><div class="line">        &#125;</div><div class="line">        var index = -1,</div><div class="line">            indexes = [],</div><div class="line">            length = array.length;</div><div class="line">  			 // 将判断条件封装，支持简写</div><div class="line">        predicate = getIteratee(predicate, 3);</div><div class="line">        while (++index &lt; length) &#123;</div><div class="line">          var value = array[index];</div><div class="line">          // //调用判断方法返回true,将这个元素加入到结果中，将当前索引值加到indexes中</div><div class="line">          if (predicate(value, index, array)) &#123;</div><div class="line">            result.push(value);</div><div class="line">            indexes.push(index);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        basePullAt(array, indexes); ////调用basePullAt方法移除indexes中的元素</div><div class="line">        return result;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="_.reverse()"></a>_.reverse()</h3><blockquote>
<p>_.reverse(array)</p>
</blockquote>
<p>反转阵列，使第一个元素成为最后一个元素，第二个元素成为第二个元素，等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var array = [1, 2, 3];</div><div class="line"> </div><div class="line">_.reverse(array);</div><div class="line">// =&gt; [3, 2, 1]</div><div class="line"> </div><div class="line">console.log(array);</div><div class="line">// =&gt; [3, 2, 1]</div></pre></td></tr></table></figure>
<p>用逆置数组算法完成是第一个想到的解决方法。</p>
<p>看源码是怎么解决的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function reverse(array) &#123;</div><div class="line">     return array == null ? array : nativeReverse.call(array);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">nativeReverse = arrayProto.reverse;</div></pre></td></tr></table></figure>
<p>用原生，差点忘记原生还有这种操作。</p>
<h3 id="sortedUniq"><a href="#sortedUniq" class="headerlink" title="_.sortedUniq()"></a>_.sortedUniq()</h3><blockquote>
<p>_.sortedUniq(array)</p>
</blockquote>
<p>这个方法就像_.uniq，除了它为排序的数组设计和优化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.sortedUniq([1, 1, 2]);</div><div class="line">// =&gt; [1, 2]</div></pre></td></tr></table></figure>
<p>排序的同时还进行了排重</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function baseSortedUniq(array, iteratee) &#123;</div><div class="line">       var index = -1,</div><div class="line">           length = array.length,</div><div class="line">           resIndex = 0,</div><div class="line">           result = [];</div><div class="line"> </div><div class="line">       while (++index &lt; length) &#123;</div><div class="line">         var value = array[index],</div><div class="line">         // 计算遍历器后的值</div><div class="line">             computed = iteratee ? iteratee(value) : value;</div><div class="line">             </div><div class="line"> //如果index为0或者computed和seen不相等</div><div class="line">         if (!index || !eq(computed, seen)) &#123;</div><div class="line">           var seen = computed;</div><div class="line">           result[resIndex++] = value === 0 ? 0 : value;</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">       return result;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<h3 id="union"><a href="#union" class="headerlink" title="_.union()"></a>_.union()</h3><blockquote>
<p>_.union([arrays])</p>
</blockquote>
<p>使用SameValueZero从所有给定的数组中按顺序创建一组唯一的值，以进行相似性比较。</p>
<p>创建一个数组，包含给出的所有数组的值的唯一值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.union([2], [1, 2]);</div><div class="line">// =&gt; [2, 1]</div></pre></td></tr></table></figure>
<p>直接看源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var union = baseRest(function(arrays) &#123;</div><div class="line">    //先将给出的数组扁平化一级之后再调用baseUniq方法，并将结果作为返回值返回。</div><div class="line">  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>再来看 <code>baseUniq</code>做了什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function baseUniq(array, iteratee, comparator) &#123;</div><div class="line">        var index = -1,</div><div class="line">            includes = arrayIncludes,</div><div class="line">            length = array.length,</div><div class="line">            isCommon = true,</div><div class="line">            result = [],</div><div class="line">            seen = result; // //返回结果的引用（保存被遍历器调用过的值）</div><div class="line">  </div><div class="line">        if (comparator) &#123; //如果有比较器,不是常规比较，并且比较方法为arrayIncludesWith</div><div class="line">          isCommon = false;</div><div class="line">          includes = arrayIncludesWith;</div><div class="line">        &#125;</div><div class="line">        else if (length &gt;= LARGE_ARRAY_SIZE) &#123; //如果数组过长</div><div class="line">          var set = iteratee ? null : createSet(array);</div><div class="line">          if (set) &#123; //如果没有传遍历器,只用转为Set对象，再转为数组,并将这个数组返回</div><div class="line">            return setToArray(set);</div><div class="line">          &#125;</div><div class="line">          isCommon = false;</div><div class="line">          includes = cacheHas;</div><div class="line">          seen = new SetCache;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">          seen = iteratee ? [] : result;//如果有遍历器，seen为空数组，否则为result的引用</div><div class="line">        &#125;</div><div class="line">        outer: //遍历数组</div><div class="line">        while (++index &lt; length) &#123;</div><div class="line">          var value = array[index],</div><div class="line">              computed = iteratee ? iteratee(value) : value;</div><div class="line">  </div><div class="line">          value = (comparator || value !== 0) ? value : 0;</div><div class="line">          if (isCommon &amp;&amp; computed === computed) &#123;</div><div class="line">            var seenIndex = seen.length;</div><div class="line">            while (seenIndex--) &#123;</div><div class="line">              if (seen[seenIndex] === computed) &#123;</div><div class="line">                continue outer;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">            if (iteratee) &#123;</div><div class="line">              seen.push(computed);</div><div class="line">            &#125;</div><div class="line">            result.push(value);</div><div class="line">          &#125;</div><div class="line">          else if (!includes(seen, computed, comparator)) &#123;</div><div class="line">            if (seen !== result) &#123;</div><div class="line">              seen.push(computed);</div><div class="line">            &#125;</div><div class="line">            result.push(value);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>我们可以看到没有遍历器的情况下，是创建了<code>set</code>对象来去重，不然要计算遍历结果然后再遍历剔除。</p>
<h3 id="uniq"><a href="#uniq" class="headerlink" title="_.uniq()"></a>_.uniq()</h3><blockquote>
<p>_.uniq(array)</p>
</blockquote>
<p>创建一个无重复的数组版本，使用SameValueZero进行相等的比较，其中只保留每个元素的第一次出现。<br>结果值的顺序由它们在数组中出现的顺序决定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.uniq([2, 1, 2]);</div><div class="line">// =&gt; [2, 1]</div></pre></td></tr></table></figure>
<p>去重。按照之前读的源码尿性，应该是做了一个缓存组，然后判断有没有迭代器，然后再循环判断有么有重复。</p>
<p>来看核心实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseUniq</span>(<span class="params">array, iteratee, comparator</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> index = <span class="number">-1</span></div><div class="line">  <span class="keyword">let</span> includes = arrayIncludes</div><div class="line">  <span class="keyword">let</span> isCommon = <span class="literal">true</span></div><div class="line"></div><div class="line">  <span class="keyword">const</span> &#123; length &#125; = array</div><div class="line">  <span class="keyword">const</span> result = []</div><div class="line">  <span class="keyword">let</span> seen = result  <span class="comment">// 返回结果的引用（保存被遍历器调用过的值</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (comparator) &#123;</div><div class="line">    isCommon = <span class="literal">false</span></div><div class="line">    includes = arrayIncludesWith</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (length &gt;= LARGE_ARRAY_SIZE) &#123;</div><div class="line">    <span class="keyword">const</span> set = iteratee ? <span class="literal">null</span> : createSet(array)</div><div class="line">    <span class="keyword">if</span> (set) &#123;</div><div class="line">      <span class="keyword">return</span> setToArray(set)</div><div class="line">    &#125;</div><div class="line">    isCommon = <span class="literal">false</span></div><div class="line">    includes = cacheHas</div><div class="line">    seen = <span class="keyword">new</span> SetCache  <span class="comment">//创建一个缓存数组</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    seen = iteratee ? [] : result <span class="comment">//如果有遍历器，seen为空数组，否则为result的引用</span></div><div class="line">  &#125;</div><div class="line">  outer:</div><div class="line">  </div><div class="line">    <span class="comment">// 遍历数组</span></div><div class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</div><div class="line">    <span class="keyword">let</span> value = array[index]</div><div class="line">    <span class="keyword">const</span> computed = iteratee ? iteratee(value) : value</div><div class="line"></div><div class="line">    value = (comparator || value !== <span class="number">0</span>) ? value : <span class="number">0</span></div><div class="line">    <span class="keyword">if</span> (isCommon &amp;&amp; computed === computed) &#123;</div><div class="line">      <span class="keyword">let</span> seenIndex = seen.length</div><div class="line">      <span class="keyword">while</span> (seenIndex--) &#123;</div><div class="line">        <span class="keyword">if</span> (seen[seenIndex] === computed) &#123;</div><div class="line">          <span class="keyword">continue</span> outer</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (iteratee) &#123;</div><div class="line">        seen.push(computed)</div><div class="line">      &#125;</div><div class="line">      result.push(value)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!includes(seen, computed, comparator)) &#123;</div><div class="line">      <span class="keyword">if</span> (seen !== result) &#123; </div><div class="line">        seen.push(computed)</div><div class="line">      &#125;</div><div class="line">      result.push(value)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和之前的看到的很类似。</p>
<h3 id="unzip"><a href="#unzip" class="headerlink" title="_.unzip()"></a>_.unzip()</h3><blockquote>
<p>_.unzip(array)</p>
</blockquote>
<p>该方法类似于_.zip，除了它接受一个分组元素的数组，并创建一个将元素重新分组到其预压缩配置的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var zipped = _.zip([&apos;a&apos;, &apos;b&apos;], [1, 2], [true, false]);</div><div class="line">// =&gt; [[&apos;a&apos;, 1, true], [&apos;b&apos;, 2, false]]</div><div class="line"> </div><div class="line">_.unzip(zipped);</div><div class="line">// =&gt; [[&apos;a&apos;, &apos;b&apos;], [1, 2], [true, false]]</div></pre></td></tr></table></figure>
<p>我们来看实现代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function unzip(array) &#123;</div><div class="line">  if (!(array != null &amp;&amp; array.length)) &#123;</div><div class="line">    return []</div><div class="line">  &#125;</div><div class="line">  let length = 0</div><div class="line">  // 返回array中，所有是数组的元素，并且取得length为最大的数组的长度</div><div class="line">  array = filter(array, (group) =&gt; &#123;</div><div class="line">    if (isArrayLikeObject(group)) &#123;</div><div class="line">      length = Math.max(group.length, length)</div><div class="line">      return true</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  let index = -1</div><div class="line">  const result = new Array(length)</div><div class="line">  while (++index &lt; length) &#123;</div><div class="line">  // //调用length次方法，每次再调用map获得array中每个元素对应index位置的值得数组，然后将包含这些这些数组的数组返回。</div><div class="line">    result[index] = map(array, baseProperty(index))</div><div class="line">  &#125;</div><div class="line">  return result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="without"><a href="#without" class="headerlink" title="_.without()"></a>_.without()</h3><blockquote>
<p>_.without(array, [values])</p>
</blockquote>
<p>使用SameValueZero创建一个排除所有给定值的数组，以进行相等比较。<br>注意：与_.pull不同，此方法返回一个新数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.without([2, 1, 2, 3], 1, 2);</div><div class="line">// =&gt; [3]</div></pre></td></tr></table></figure>
<p>排除元素。优先遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function without(array, ...values) &#123;</div><div class="line">  return isArrayLikeObject(array) ? baseDifference(array, values) : []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前的<code>Difference</code>来完成。</p>
<h3 id="xor"><a href="#xor" class="headerlink" title="_.xor()"></a>_.xor()</h3><blockquote>
<p>_.xor([arrays])</p>
</blockquote>
<p>创建一个唯一值的数组，它是给定数组的对称差异。<br>结果值的顺序由它们在数组中出现的顺序决定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.xor([2, 1], [2, 3]);</div><div class="line">// =&gt; [1, 3]</div></pre></td></tr></table></figure>
<p>取交集。之前也找过类似的功能。它的写法是做双重遍历。但那很明显很低效。</p>
<p>来看核心实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function baseXor(arrays, iteratee, comparator) &#123;</div><div class="line">  const length = arrays.length</div><div class="line">  if (length &lt; 2) &#123;</div><div class="line">    return length ? baseUniq(arrays[0]) : []</div><div class="line">  &#125;</div><div class="line">  let index = -1</div><div class="line">  const result = new Array(length)</div><div class="line"></div><div class="line">  while (++index &lt; length) &#123;</div><div class="line">    const array = arrays[index]</div><div class="line">    let othIndex = -1</div><div class="line"></div><div class="line">    while (++othIndex &lt; length) &#123;</div><div class="line">      if (othIndex != index) &#123; ////如果比较的数组和当前数组不是同一个数组，调用baseDifference方法取得array中不同于当前用于比较的数组的值</div><div class="line">        result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return baseUniq(baseFlatten(result, 1), iteratee, comparator)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很明显，还是需要双重遍历~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;以前读源码都虎头蛇尾，一心想着用什么工具提高效率啊，用什么方式读更容易啊，要不要先去看看别人的源码注解啊什么的。但是发现源码,Just re
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="框架" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Lodash" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/Lodash/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://wiki.haoqiao.me/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Lodash" scheme="http://wiki.haoqiao.me/tags/Lodash/"/>
    
  </entry>
  
  <entry>
    <title>《小狗钱钱》  《自我激励的100种方法》《活出生命的意义》</title>
    <link href="http://wiki.haoqiao.me/wiki/%E9%98%85%E8%AF%BB/%E3%80%8A%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1%E3%80%8B%20%20%E3%80%8A%E8%87%AA%E6%88%91%E6%BF%80%E5%8A%B1%E7%9A%84100%E7%A7%8D%E6%96%B9%E6%B3%95%E3%80%8B%E3%80%8A%E6%B4%BB%E5%87%BA%E7%94%9F%E5%91%BD%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>http://wiki.haoqiao.me/wiki/阅读/《小狗钱钱》  《自我激励的100种方法》《活出生命的意义/</id>
    <published>2017-10-14T01:41:50.000Z</published>
    <updated>2017-10-14T03:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原本应该是周五晚上固定时间写，但是昨晚遇到一个不可抗的bug，整整连续debug了5个小时。造成延后。今天还要补上昨天的体能训练QAQ，讲道理，玄学问题真的很难定位。。。</p>
<h1 id="《小狗钱钱》-《自我激励的100种方法》-《活出生命的意义》简评"><a href="#《小狗钱钱》-《自我激励的100种方法》-《活出生命的意义》简评" class="headerlink" title="《小狗钱钱》  《自我激励的100种方法》  《活出生命的意义》简评"></a>《小狗钱钱》  《自我激励的100种方法》  《活出生命的意义》简评</h1><p>过去一周在晚上每天花一小时读了几本书，一本是教人理财类的《小狗钱钱》，很像童话的故事书。我觉得挺适合全年龄阶段的人去阅读。</p>
<p>一本书心灵鸡汤《自我激励的100种方法》。我个人是觉得人嘛偶尔还是要给自己一些激励，免得在重复一天又一天的日子里慢慢消沉。虽然一直有做计划，规划，时间管理。但是情绪的调动后的执行力真的是完全不一样的。因此从《自我激励的100种方法》中还是能从中找到自己可以用的一些方法。</p>
<p>《活出生命的意义》是讲集中营生存者的一些感悟。嗯，个人是很难有共鸣，大概是以前看美丽人生和辛德勒的名单留下更多的痕迹。不过这种书的意义就是让你领略不一样的风景。</p>
<h2 id="《小狗钱钱》"><a href="#《小狗钱钱》" class="headerlink" title="《小狗钱钱》"></a>《小狗钱钱》</h2><blockquote>
<p>天下难事必做于易，天下大事必做于细。</p>
</blockquote>
<p>发现很多国外的名言和引用的格言都是我们自己古代先贤的一些令人发省的短句。国学有必要去好好读一读。</p>
<blockquote>
<p>好奇是好的，但是你绝对不能因为好奇而阻碍你去做一件事情，太多的人都是犹豫不决，就是他们觉得没有弄懂一样东西。而真正付诸实施要比纯粹的思考要聪明多了。</p>
<p>不是试试看，而是去行动！如果你只是带着试试看的心态，那么你最好只会以失败而告终，你会一事无成。尝试纯粹是一个借口，你还没有做，就已经给自己想好了后路。不能试验，你只有两个选择，做或不做。</p>
</blockquote>
<p>我们必须确定我们想做一件事情，就是立刻着手做一些简单的，不要拖延等所谓的时机，做好做坏都是次要，关键是你着手开始做一些简单的起步，这样你就能慢慢将其完成。也会有更多机会去完善。你不做，什么都不会发生。</p>
<p>讲道理，看到上面这段的时候我联系了下自身之前学习的状态。感觉挺有道理。我很早以前刚入门学习的时候，初生牛犊不怕虎，想做什么，想学什么我都直接去学，去看书。然而到了后来，我有一个想法，在脑子里思考了很久，但是我觉得当时技术不够成熟，我就只是在ominifocus里面写下想法之类的。真正让我去做的想法只是其中的三分之一。近期我关注了一个知乎话题，发现别人的执行力远超自己。半个月到一个月他们就可以完成一个自己的小项目。发现差距再进行对比，我觉得自身还可以更加具有主动性，真正局限自己的不是想象力，不是技术积累，而是去立刻执行的冲动。即使是一开始做一些小的铺垫，也比在计划中夭折来的靠谱。</p>
<blockquote>
<p>学习就是认识新观念和新想法的过程，假如人们始终以同一种思维方式来思考问题，那么始终会得到同样的结果。在自己还没有做成之前，不要轻易下结论。我们一生中投入精力越多的事情。其成功性越大。大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西。</p>
</blockquote>
<p>这和debug是一样的，如果用同一种思维去解决问题，大部分问题会很容易解决，但是遇到玄学问题的时候，你必须脱离原来的思维，用另外一些方式，去思考，不然很容易陷入僵局。精力不是能量守恒，每天你其实可以做的事情比你想象的要多，把不必要的时间节省下来(比如弃游2333),你能在一些事情上有更多的时间去思考。有更多的事情去反思。把精力集中在喜欢的事情上挺重要，因为这意味着你很容易调动自己的积极的情绪去做事情，提升效率。</p>
<blockquote>
<p>你必须设想自己已经拥有了这些东西，这样你的愿望就变成了一种渴望，你想象的越多，你的愿望就越强烈，那么你就会开始寻找机会实现自己的梦想。</p>
</blockquote>
<p>这点我觉得在自己的经历中得到了证实。不过在一次次实现后发现自己渐渐减少了渴望，随遇而安，知足常乐的心态在这些方面造成了阻力。因此我也在逐步的去反转心态，继续去幻想去渴望。这样才有源源不断的学习动力。</p>
<blockquote>
<p>你的自信程度决定了你是否相信自己的能力，你是否相信自己，假如你根本不相信自己能做到的话，你就根本不会动手去做。假如你不开始去坐，那么你就什么也得不到。</p>
</blockquote>
<p>我觉得了解自己是一件非常重要的事情，很多人过于狂热的去了解他人，去理解他人。但是没有静下心来真正的去评审自己，去挖掘内心的自己。你想要什么，你的能力局限在哪里，你是否能调动你的大部分积极情绪去做事情，如何顺利的去完成一些你觉得很困难的事情，如果去调整你突变的情绪。你的自信源于你对自身的认知。你越了解自己，越自信。</p>
<blockquote>
<p>尝试为别人解决一个难题，你就能赚很多钱。把精力集中在你知道的，你会的和你拥有的事情上。</p>
</blockquote>
<p>这是本书理财核心。其实很多工作就是给别人解决问题。而现在服务性产业的蓬勃发展，也给了更多人更多的机会。比如公众号，比如外包等等。</p>
<blockquote>
<p>一个人想要更幸福，更满意的生活，就得对自身进行改变。这和金钱无关，金钱本身既不会使人幸福也不会带来不幸，钱要么被用于好的用途或者坏的用途。一个幸福的人拥有更多钱会更幸福，一个悲观忧虑的人，钱越多，越烦恼。</p>
</blockquote>
<p>德行需要匹配，只有驾驭住自身欲望的人，才能驾驭住生活，驾驭住金钱。</p>
<h2 id="《自我激励的100种方法》"><a href="#《自我激励的100种方法》" class="headerlink" title="《自我激励的100种方法》"></a>《自我激励的100种方法》</h2><blockquote>
<p>要生活在自我激励的状态中，关键就是但你每天早晨醒来，都要有所“求”。你尚未达到的目标，正是你对它的“饥渴感”使你不断进步。</p>
</blockquote>
<p>心有所求,才会去行动。</p>
<blockquote>
<p>就在当时当地把事情解决掉，不要把任何不必要的事情留给你的未来。现在就做，那么未来就永远是广阔而开放的。</p>
</blockquote>
<p>具体场景需要具体分析，但大概率来讲，在不是非常紧急的状况下，随手完成一些只占用几分钟的事情会让你生活更加有条理。</p>
<blockquote>
<p>自我激励往往受挫于我们选择怎样的方式理解人生的各种境遇。这是因为我们理解人生各种境遇的出发点不是环境本身，而是我们本身。实际上在任何环境中，我们都能找到黄金或者糟粕，我们找的是什么，我们就能找到什么。</p>
</blockquote>
<p>心态决定你的处境。</p>
<blockquote>
<p>好好想一想，你所看过的电视节目能够挖掘潜力，能否带给你灵感？然后再想一想，一个月读的书，甚至一周前读的电子期刊。什么给你留下了更有价值、更持久的印象？哪一种娱乐能够带给你更多自强不息的动力？</p>
</blockquote>
<p>把时间用在更有意义的事情上，现在online还是很有意思的。</p>
<blockquote>
<p>很多人错误的认为过真实的生活就意味着很幸运找到一个合适的职位。有一个赏识自己的老板。后来明白了，你可以在任何地方、任何职位上和任务一个老板一起过你的真实生活。首先要找到什么让你快乐，接下来就去做。</p>
</blockquote>
<p><code>当你说我不认为我能做到。那么就不要成为你自己，如果你做不到，那么就成为其他的人。成为那些可以做到的人。成为李小龙，成为你所崇拜的任何人。现实并不在意你是谁，只要你能够做到。</code></p>
<p><code>不知道生活目标的原因只有两个：1.你不与自己交谈。2.你不知道目标来源于何处（你认为目标来自外界而非自身）</code></p>
<blockquote>
<p>如果你真的想得到一些新鲜的活力，那么试一试加倍你的目标，让它高到令你恐惧。然后把它当做你必须达到的目标来对待。这是一个自我承诺的游戏。你只有当真才能体会它产生的积极的作用。</p>
</blockquote>
<p>在渐渐消沉的执行目标的时间中，突破自己的极限，带来新的活力。</p>
<blockquote>
<p>如果你不知道你想要的是什么，那么就写一张你人生中最不想去做的事情，并且列出原因，列出每一个主要的难题和你不想去做的原因，你的烦恼和你所有能耐想到的负面的消极的东西。甚至包括那些还未发生成现实的东西，以及那些你不想让其发生为未来的东西。</p>
</blockquote>
<p>这个方法简直强大。适合没有目标的人群。你越不想要什么，你越恐惧什么，那么能制约这些东西的目标，其实就是你需要达到的，你需要拼尽全力去争取的东西。</p>
<h2 id="《活出生命的意义》"><a href="#《活出生命的意义》" class="headerlink" title="《活出生命的意义》"></a>《活出生命的意义》</h2><p>摘录没什么意思。不过我从中看到的是，每个人都需要独处，将自身置于一个完全脱离人群的环境，当你被幽静环绕，你就容易沉下心去和内心对话。当然现在的前提是你需要放下手机2333.</p>
<p>每个人都有向往人群的渴望，就像羊拼命挤向羊群，因为羊群意味着安全感。</p>
<p>真正重要的不是我们对人生有什么指望，而是人生对我们有什么指望。我们不该继续追问生命有何意义，而是认清自己无时无刻不在接受生命的追问。我们不能以说话和沉思来答复，而应该以正确的行为作为答复。</p>
<p><code>我们终将明白,生命的意义在于探索人生问题的正确答案，完成生命不断安排给每个人的使命。</code></p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>因为几本书调节了自身的情绪，对于以前一些我懒得做的事情，比如组织社群一起做一件事情。我都尝试着有了一个开头，我觉得能改变自身以往的观念，然后再慢慢对自己提高要求，不断进行自我的追逐，可以让我每天迸发出更多的精力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;原本应该是周五晚上固定时间写，但是昨晚遇到一个不可抗的bug，整整连续debug了5个小时。造成延后。今天还要补上昨天的体能训练QAQ，讲道
    
    </summary>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="自我提升" scheme="http://wiki.haoqiao.me/tags/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="读书笔记" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读后感" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>《大秦帝国》  《千面英雄》</title>
    <link href="http://wiki.haoqiao.me/wiki/%E9%98%85%E8%AF%BB/%E3%80%8A%E5%A4%A7%E7%A7%A6%E5%B8%9D%E5%9B%BD%E3%80%8B%E3%80%8A%E5%8D%83%E9%9D%A2%E8%8B%B1%E9%9B%84%E3%80%8B/"/>
    <id>http://wiki.haoqiao.me/wiki/阅读/《大秦帝国》《千面英雄》/</id>
    <published>2017-10-14T01:41:50.000Z</published>
    <updated>2017-10-20T09:42:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这周读的东西挺散，也有书比较厚的原因，《大秦帝国》大概7000多页。后来读了400多页停了。《千面英雄》读了一半。</p>
<h2 id="《大秦帝国》"><a href="#《大秦帝国》" class="headerlink" title="《大秦帝国》"></a>《大秦帝国》</h2><p>一开始我以为是正史，没想到是小说。然后作者是一个崇拜秦朝的狂热粉丝。一般来说偏执狂都会有不同人的观点。本着了解的态度继续跟踪读下去。开头非常吸引人，六国谋秦，国耻昭昭，求贤令，商鞅变法。大气磅礴的战国，性格各异的国君，尔虞我诈的计策，以及作者脑补的各种心理描述，都很吸引人。但后来为什么停止了呢，还是偏执的锅。作者太狂热秦朝了，然而历史应该是客观的，太主观将秦孝公描述的各种高大上，尤其是后面五马分尸商鞅，写的太戏剧性，个人受不了于是赶紧悬崖勒马，准备后面找正史来校正。不过如果说按照小说来评分，这本书已经算非常不错了，作者的私货也不少。</p>
<p>下面举几个例子</p>
<blockquote>
<p>   “帝国”是一个历史概念。它一般包含三个基本标准：其一，统一辽阔的国土（小国家没有帝国）；其二，专制统治（民主制没有帝国）；其三，强大的军事扩张（无扩张不成帝国）</p>
<p>魏赵韩三国，原是老牌诸侯晋国的三家大臣，势力坐大后，三家共同瓜分了晋国。周威烈王于魏文侯四十三年不得不正式册封魏赵韩三家为诸侯国，迄今不过四十余年。这就是说，七大战国中，有四个是坐大夺权建立的–齐魏赵韩；一个是山高水远先自立而后被王室认可的–楚；只有燕秦两国是正式册封立国而一脉相延的诸侯国。燕国是西周的开国诸侯，秦国是东周的开国诸侯，燕国比秦国恰恰老了整整一个时代。</p>
</blockquote>
<p><code>这段话就建立了一个详细的鄙视链，正统鄙视篡位的，篡位鄙视落后地区的。</code></p>
<blockquote>
<p>庞涓根本不在乎那些纨绔膏粱者如何蔑视他，也不在意将士们对他简朴起居的赞颂，他深深懂得，在连绵刀兵你死我活的战国时代，立足的根本点是功业，是胜利。作为三军统帅的上将军，若果丧师失地，将士们的拥戴赞颂会在一夜之间变为咒骂或叛乱。若果能破国拔城，那些纨绔膏粱们也会在一夜之间跪拜在他的脚下。成者王侯败者贼，在刀兵铁血的年月，这是一条永远的铁则。</p>
</blockquote>
<p>成王败寇皆是如此。</p>
<blockquote>
<p>   在七大战国中，惟有秦国没有确定宣示自己的德性，但却是举国尚黑，令列国百般嘲笑，说秦国蛮荒之地不懂王化。秦国却是不理不睬，依旧黑色不改，在战国眼里成了一个乖戾怪诞充满神秘的西部邦国。</p>
</blockquote>
<p>读这段的时候我觉得历代秦朝国军都有很大的野心啊，德行为黑，黑纳七色。有气吞天下的野心。</p>
<blockquote>
<p>由于落后，由于穷困，由于稳定，由于战争，秦国世族和乡野庶民的种种差距，远远不象东方世族与庶民那样有天壤之别。秦国世族在战争中的伤亡丝毫不比庶民少，生活上想奢侈排场也没有条件。一旦兵连祸结，世族庶民一般艰苦一般流血。所有的世族子弟，都是少年从军，浴血奋战，任何一个家族都可以数出历代成百上千的战死者。这种不大的差别，使秦国世族在山野庶民中有着很深的根基，某种意义上说他们溶为一体也不为过。正是这种相安无事的稳定和谐，使秦国世族和乡野庶民都没有改变现状的强烈愿望。世族中没有分化出东方那样的新地主，也没有产生东方那样的士人阶层；庶民虽有怨言和不满，但却从来没有发生过几乎同样落后的楚国那样的群盗暴动，或周室洛阳那样的百工起义。三百多年中，秦国朝野没有改变这种”一体穷困，同甘共苦”的愿望。平民如此，世族更如此。</p>
</blockquote>
<p>这段很有触动，当一个群体习惯了贫穷，如果有人想要改革，第一个面对的就是昔日的伙伴。</p>
<h3 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h3><p>读这本书的时候，最让人感触深刻的应该是”赳赳老秦，共赴国难”吧。多代国君的积累，隐忍，秦人在那么艰苦的环境下，秦孝公作为一个国君能忍常人不能，为了让秦国复兴所做的努力和尝试。当秦人不仅拥有冷水无法浇灭的热血，也懂得了卧薪尝胆的隐忍，强大只是时间的问题。</p>
<p>可惜原本挺好的设定，后面写的尬死我了QAQ…</p>
<h2 id="《千面英雄》"><a href="#《千面英雄》" class="headerlink" title="《千面英雄》"></a>《千面英雄》</h2><p>看这本书是因为它的简介很吸引人，《星球大战》的导演乔治-卢卡斯从中吸取了很多，并将其作为蓝本。它给很多艺术家提供了素材和灵感(因此这本学术性很强的书非常抽象)</p>
<p>这本书看了一半，大概是将人类心理学和神话故事结合，并梳理了大量的寓言，民间神话来印证自身的观点。</p>
<blockquote>
<p>   正如我们很快将会看到的，无论是在东方神话广阔的、几乎无边无际的形象中，还是在希腊神话充满力量的叙述中，或是在《圣经》壮美的传奇中，英雄的冒险经历通常遵循以上描述的核心模式：离开凡人的世界，进入某种力量之源，然后返回凡人的世界，生命得到了提升</p>
</blockquote>
<p>最后作者将其梳理成一个英雄成长路线，这和美国很多大片的套路是一样一样的，这也是为什么这本书那么有名的原因之一吧0-0，美国英雄主义大片都从中得到了套路的精髓。。。</p>
<p>用一句话来概述这本书，<code>神话是梦的本质，或者梦是精神动力学的征兆</code></p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>草草结束了本周的总结，主要是读的这两本没啥好讲的。而且还木有全部读完。本周花了挺多时间去读框架源码…大概这个借口找的比较好~下周继续</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这周读的东西挺散，也有书比较厚的原因，《大秦帝国》大概7000多页。后来读了400多页停了。《千面英雄》读了一半。&lt;/p&gt;
&lt;h2 id=&quot;
    
    </summary>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="自我提升" scheme="http://wiki.haoqiao.me/tags/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="读书笔记" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读后感" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>国王 武士 祭司 诗人</title>
    <link href="http://wiki.haoqiao.me/wiki/%E9%98%85%E8%AF%BB/%E5%9B%BD%E7%8E%8B%20%E6%AD%A6%E5%A3%AB%20%E7%A5%AD%E5%8F%B8%20%E8%AF%97%E4%BA%BA/"/>
    <id>http://wiki.haoqiao.me/wiki/阅读/国王 武士 祭司 诗人/</id>
    <published>2017-10-06T14:17:17.000Z</published>
    <updated>2017-10-07T01:54:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>   最近把很多精力投入到了对一个运行3年的Web应用进行版本迭代和功能添加。国庆也一直投入时间进去,于是日常除了体能训练就是coding,后来想想还是得找个其它事情做做，于是给自己列了一份书单，定了一个长期规划。《国王 武士 祭司 诗人》是偶然发现的一本书，中译本看完发现只有55页,比英文版浓缩好多，但是都能反复咀嚼。之前是被简介吸引的</p>
<blockquote>
<p>它很好的把社会上表象的男人问题，清晰的投射到了荣格原型中，用一个易懂又毫不乏深度的系统来向我们阐述了“成熟”需要什么样的外部条件，和我们每个男人需要如何去认识自己的内在心智</p>
</blockquote>
<p>因此我列的阅读理由是</p>
<blockquote>
<p>更深层次的去审视自己。类似的书之前没遇见过。觉得值得一读。</p>
</blockquote>
<p>后来花了两个晚上读完觉得还是挺有收获。因此在每周五的读书笔记整理中将这本书进行整理。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><code>《国王 武士 祭司 诗人》这本书主要是根基于荣格心理学通过心理学模型一步步发展来解释男人如何变得更成熟。</code></p>
<p>整本书阅读完后我想到了很久以前看到的一句话:</p>
<blockquote>
<p>人的一生会经历三个阶段</p>
<p>一 发现自己不是世界中心的时候。</p>
<p>二 发现自己再怎么努力，有些事情也是无能为力的时候。</p>
<p>三 在明知有些事情可能无能无力的时候，还尽力去争取的时候。</p>
</blockquote>
<p>这也恰好对应了这本书的心理模型的几个阶段。</p>
<p>本书分为2个层次，男孩和男人。</p>
<p><code>男孩阶段的四个原型分别是神圣男孩(The Divine Child)，早熟男孩 (The Precocious Child)和恋母男孩(The Oedipal Child)，以及最后一 个，英雄男孩(The Hero)</code></p>
<p><code>男人阶段的四个原型是诗人，祭司，武士，国王</code></p>
<blockquote>
<p>不论是男孩还是男人的内心，都由这些原型组成。每个原型主宰着我们 每一部分的心智，对待世界和他人的方式。在依赖机制原型(男孩心理)和责 任机制原型(男人心理)中间，存在一条清晰的界限。从男孩心理出发，在模 型中清晰的划定了一条进化的道路，引领男孩看到更开阔的生命景致，同时 打下男人心理的根基。此外，在每个原型的坐标轴上，不仅分为不成熟和成 熟两个阶段，在男孩和男人的阶段内还各有一个金字塔，在塔的顶点可以找 到原型的中心位置，在塔的左右角分别是正负阴影位置。当我们不能激发一 个原型的中心位置的时候，我们会自动的被这种原型的两极的阴影所控制。</p>
<p>当我们意识到一种原型在我们的人格和心理中占有过分强大的统治地 位，必须用其它原型的力量来平衡它时,或者当我们意识到我们依照阴影面 中的积极或消极来行动(而不是完整而成熟的一面)的时候，心理的治愈和整 合就会发生。</p>
</blockquote>
<h2 id="男孩是他自我中心-ego-的奴隶"><a href="#男孩是他自我中心-ego-的奴隶" class="headerlink" title="男孩是他自我中心(ego)的奴隶"></a>男孩是他自我中心(ego)的奴隶</h2><p>书中比较明显的就是译者个人的私货。比如对男孩和男人的区别：</p>
<blockquote>
<p>男孩式的年轻漂亮和朝气取代了成熟的男性魅力成为当下 文化推崇和赞扬的主流。这种现象在各式各样的文化领域中随处可见，就好 像当红的男子组合里的花样美男、运动场上雄性荷尔蒙爆发的运动员们、广 告里铺天盖地的宣扬的“随心所欲，为所欲为”的不负责任的人生观，潮流音 乐追捧的“唯我独尊，挡路者死”的风潮，股市和房市里经纪人们金钱至上,自私自利的生活方式，影视剧里帅哥的大行其道，观众对英雄角色的追捧， 人们对神童的盲目崇拜等等，这一切无不是当今世界男孩泛滥，男人不再的 真实写照。</p>
<p>现在在舞台上、影视里、书本里，乃至生活中 被塑造的成功男人的形象无不根植于对性、名声、金钱和权力的追求，他们 的价值所在都来源于这些不安定的外在因素。人们被误导，被迷惑，变得越 来越看重身外物的价值，在乎别人眼中的自己，追寻名利，而真正重要的东 西则被丢弃在一旁无人问津。</p>
</blockquote>
<p>这让我想起了一些美剧中父亲的角色，他们总是沉稳，容易给他人安全和可靠感。</p>
<blockquote>
<p>男孩是自我中心的奴隶，而男人则是自我中心的主人</p>
</blockquote>
<p>男人的特质可以如此描述:</p>
<p>他们沉稳，处事不惊。能够在危险中保持镇定。<br>他们不容易被冒犯，却很容易能给人带来安全和可靠感。<br>他们从不寻求关注和爱护。他们生活的趋势是给于他人认同，给于爱。<br>他们习惯于慷慨的给于他人帮助。他们深知，助人强者无不自强。<br>他们的生活有确定的使命，行动和思维从不混乱。<br>他们能够忍耐痛苦，但依旧敞开心活着。他们不怕被骗，被看不起。<br><code>他们从来不为自己辩解，因为他们知道自己是谁。</code></p>
<h2 id="男性启动仪式。"><a href="#男性启动仪式。" class="headerlink" title="男性启动仪式。"></a>男性启动仪式。</h2><blockquote>
<p>在古老的部落中，当男孩子长到14岁左右，会突然被部落的男人们集 体从他母亲那里把他抓走，对男孩的殴打，恐吓，各种催眠与暗示，让他认 为已经不能够再依赖成人，不再是孩子了。在角色转换完成之后，他会像其他成人一样承担成人应该承担的站岗，打猎，抵御侵略等社会责任。<br>启动仪式的严密性非常重要。在不同的部落有不同的仪式形式和长度,在美洲某些印第安人部落，一个仪式甚至会长达3天之久。我们上面的例子 取自上个世纪的新几内亚岛:如果孩子在无意间发现了是村民装扮的怪兽， 或者在其中一些恐吓的过程中孩子没有遵守规则，例如“呆在原地不动” - 而 是被吓跑了，村民们会宣告这次启动仪式的失败。接下来，他们会把这个孩 子杀死，并吃掉。</p>
<p>这样就可以确保，所有的男孩在成长到这一部都要成功的变成男人，不成功的就杀掉。他们不能够依靠成群结队的小男孩们打猎站岗，保卫家园。</p>
<p>这是保证部落存活的必然性处理。</p>
</blockquote>
<p>简单的来讲就是从依赖别人到负责的过程。而且部落文化更加直接不成功就是死翘翘。。。</p>
<h2 id="神圣男孩-The-Divine-Child"><a href="#神圣男孩-The-Divine-Child" class="headerlink" title="神圣男孩 The Divine Child"></a>神圣男孩 The Divine Child</h2><blockquote>
<p>神圣男孩代表了生命的源泉，代表了创造力的原始动力。你在看到孩子的时候的那种说不上来的欣喜感。是这个神圣孩子能量的最初表现形式。</p>
</blockquote>
<p>神圣男孩最大的敌人，是他自己的影子。他的影子分为正负两级：</p>
<h3 id="正极-暴君"><a href="#正极-暴君" class="headerlink" title="正极:暴君"></a>正极:暴君</h3><blockquote>
<p>他是整个宇宙的中心，所有人存在的原因都是去为了满足他的需求。他 狂妄自大，对他人和自己不负责任。心理学家会把这个叫做Pathological Nar- cissism (病态自恋)。<br>暴君的问题在于，他意识不到他并不是整个宇宙的中心.一个男人很容易会变成他内心的这个小暴君的奴隶，他必须取得别人都有的物质财富，车，房，手表，只要是世界上存在的，他都想要。暴君想要的，是什么都不用做，好东西都来找他.他想象自己是最重要的人，于是他经常贬低他人。</p>
</blockquote>
<h3 id="负极-懦弱的王子"><a href="#负极-懦弱的王子" class="headerlink" title="负极:懦弱的王子"></a>负极:懦弱的王子</h3><blockquote>
<p>他会显得毫无性格，没有生活的激情。他看起来虚弱，无助，他需要被抱着，被安抚，被裹得严严实实的抱来抱去，轻拿轻放。<br>但实际上，他的这种懦弱是伪装的。他装成一个无助的受害者，去欺骗他的父母，这样他可以得到他想得到的.通过他人同情来得到自己想要的。</p>
</blockquote>
<p><code>懦夫在关键的时候爆发，会立即转向暴君极，变的异常暴力。一个在学校经常被欺负的懦弱孩子，会突然带刀到学校捅死他所有的室友。</code></p>
<h2 id="早熟男孩-The-Precocious-Child"><a href="#早熟男孩-The-Precocious-Child" class="headerlink" title="早熟男孩 The Precocious Child"></a>早熟男孩 The Precocious Child</h2><blockquote>
<p>早熟男孩是我们好奇心的源泉，他代表了我们探索与猎奇的本能。他带领着我们去尝试新鲜事物，对未知世界探索。他不仅让我们对外部世界，还有对人的内心世界都充满了好奇:为什么有些人会做有些事?为什么有些人会有某些感觉?</p>
<p>他可能会是内向的，喜欢反思的。他可以看到一些别人看不到的事物之间的联系;他也可能会有外向的脾气，迫不及待的给周围的人展示它的洞察力与才华。</p>
<p>如此的好奇心，探索的精神与源动力，继续推动的这个男孩的智力，直到他成年后成为一个成熟的祭司(The Magician)。</p>
</blockquote>
<p>早熟男孩也携带着正负两级阴影.</p>
<h3 id="正极-博学的骗子-The-Know-it-all-Trickster"><a href="#正极-博学的骗子-The-Know-it-all-Trickster" class="headerlink" title="正极:博学的骗子 The Know it all Trickster"></a>正极:博学的骗子 The Know it all Trickster</h3><blockquote>
<p>博学的骗子最大的特点是:自作聪明.<br>他们是创造表面假象的专家，通过欺骗的手法得到自己想要的<br>博学的骗子喜 欢争夺餐桌上的话语权，和别人争论，证明自己是更正确的。它贬低，藐视 那些和他观点不一致的人，不知道他知道的东西的人，因为他“什么都知 道”。<br>他不愿意去付出努力，不愿意诚实的依靠劳动得到某些东西。它只想什么都不用做，去得到更多，得到本不属于他的。他不愿意承担任何责任，但他想得到承担责任所得到的报酬。<br>他深深得嫉妒别人的才华，别人的好奇和学习的能力。每当他看到别人也可以很优秀，他会想尽办法阻拦别人比他变得更聪明。</p>
</blockquote>
<h3 id="负极-天真的蠢货-The-Naive-Dummy"><a href="#负极-天真的蠢货-The-Naive-Dummy" class="headerlink" title="负极:天真的蠢货 The Naive Dummy"></a>负极:天真的蠢货 The Naive Dummy</h3><blockquote>
<p>他显得很笨，经常听不懂一些笑话，学习成绩不好，身体失衡。在学校的运动场上经常因为笨拙被人取笑。别人都学会了乘法表，代数公式。而他总是最后一个，他显得比别人慢很多。</p>
<p>但是这是一种假象。他知道的要比他表现出来的更多他想让你看到他愚笨的假象，让你根本就不会想到是他。</p>
</blockquote>
<h2 id="恋母男孩-The-Oedipal-Child"><a href="#恋母男孩-The-Oedipal-Child" class="headerlink" title="恋母男孩 The Oedipal Child"></a>恋母男孩 The Oedipal Child</h2><blockquote>
<p>恋母男孩是温暖的，和别人相处融洽的，富有情感的。是我们的博爱的精神境界的源泉。</p>
</blockquote>
<h3 id="正极-妈妈的宝贝-The-Mama’s-Boy"><a href="#正极-妈妈的宝贝-The-Mama’s-Boy" class="headerlink" title="正极 妈妈的宝贝 The Mama’s Boy"></a>正极 妈妈的宝贝 The Mama’s Boy</h3><blockquote>
<p>他在交往中什么都不愿付出，不想担负责任。因为现实中的男女关系有很多复杂的感情，麻烦，和不尽如人意的地方。现实中是没有女神的。</p>
</blockquote>
<h3 id="负极-梦幻宝贝-The-Dreamer"><a href="#负极-梦幻宝贝-The-Dreamer" class="headerlink" title="负极:梦幻宝贝 The Dreamer"></a>负极:梦幻宝贝 The Dreamer</h3><blockquote>
<p>他什么都不想做，也什么都做不成。他对生活，和现实中的人没 有真实的感情。看起来有种淡淡的忧伤和抑郁。他的幻想会非常的脱离现 实。当别人都一步步踏入生活，了解人的真实情感,了解这个真实的世界的时候，会躲在他自己的梦幻世界中。“真实”对他来讲，太丑陋，太冷酷.</p>
</blockquote>
<h2 id="英雄男孩-The-Hero"><a href="#英雄男孩-The-Hero" class="headerlink" title="英雄男孩 The Hero"></a>英雄男孩 The Hero</h2><blockquote>
<p>他所向无敌，不管是什么敌人，他都能击败，不管是什么困难，他都能摆平。它是我们幻想中男性气概的顶峰。</p>
</blockquote>
<p><code>英雄的阴影可以被总结成一句成语:欺软怕硬</code></p>
<p>英雄原型不仅不会退化掉，而且他的出现预示着男人成长的重要一步:激活男孩强烈自我认知，让其具备和母体剥离的初步条件。</p>
<p>英雄原型调用了男孩所有的雄性能量储备，去推进到他心理的边缘地带，帮他暂时切断他体内存储的大量的雌性能量，去成为一个独立的，在心理上能够自生自灭的雄性个体。只有当这样的个体形成后，他才会被激发出来他个人的使命，去给这个世界带来新的创造。</p>
<p><code>英雄原型的出现，是为了预备男孩的依赖机制的死亡，而进一步迎接男人的诞生。</code></p>
<h3 id="正极-恶霸-The-Bully"><a href="#正极-恶霸-The-Bully" class="headerlink" title="正极:恶霸 The Bully"></a>正极:恶霸 The Bully</h3><blockquote>
<p>恶霸总想去通过他的力量来显示自己，他喜欢在周围的人中争夺霸主的地位。如果他的地位被挑战了，他一定暴怒，立即出手打击敢于挑战他地位的人。</p>
<p>他不喜欢团队工作，他总是喜欢一个人。他对自己的实际能力有一种自我膨胀的意识。他认为自己可以打败最不可能的敌人，完成最不能完成的任务。然而恶霸的最终结局，是他会被自己的傲慢击败。</p>
</blockquote>
<h3 id="负极-懦夫-The-Coward"><a href="#负极-懦夫-The-Coward" class="headerlink" title="负极:懦夫 The Coward"></a>负极:懦夫 The Coward</h3><blockquote>
<p>当面临冲突的时候，懦夫最希望的，是找借口逃脱。在平时，他习惯于让自己被其他人欺负:无论身体上或者心智上。他也和恶霸一样不合群，因为他秘密地认为，其实他还是最强的。当他面对比自己个头小的孩子的时候，他恶霸的一面就展现出来了。</p>
</blockquote>
<h2 id="从男孩到男人"><a href="#从男孩到男人" class="headerlink" title="从男孩到男人"></a>从男孩到男人</h2><blockquote>
<p>心理上男孩仍旧是需要死亡的，在这之后才能迎来心智独立的男人的重生。而男孩死亡的条件，就是英雄原型(The Hero)的彻底战败:死亡。</p>
<p>当这个认为自己无所不能的英雄，遇到生命中最重要的，却又是真正的 难题的时候，- 我们拿一条巨龙来比喻 - 他勇敢的冲上前去，天真的认 为，“屠龙”是理所当然的时候，他被巨龙一口活吞了。</p>
<p>男人会经历一段匪夷所思的变化:他的傲气被削弱，每一步，仿佛都是拖着虚弱的身体走出一个沉睡已久的洞穴。他看看周围的世界，发现一切都还没变，但一切又都不一样了。</p>
<p>他开始认识到:自己的能力其实非常有限，人生中的问题远远要比他想象得大得多。他开始明白，为什么很多成年的男人都那么低调和谦虚。每当他回想起过去的自己，都会含着羞愧的苦，一笑而过。</p>
</blockquote>
<p><code>此时此刻，男人重生了。</code></p>
<p>男性启动仪式结束后，一个生活在依赖心理机制的男孩，开始走向了以责任机制为主的男人。</p>
<h2 id="武士-The-Warrior"><a href="#武士-The-Warrior" class="headerlink" title="武士 The Warrior"></a>武士 The Warrior</h2><blockquote>
<p>武士是一直清醒的，警惕的。他知道如何专注他的心智和身体，知道他想要什么，而且知道怎么得到他想要的。同时，武士也是一个战术家，他能够适应变化作出最好的判断和战术。他知道自己占上风还是下风，是否能击败敌人，完成任务，是否应该临时隐退，是否需要独辟蹊径。</p>
<p>武士非常清楚自己的能力范围。英雄从来不知道 天高地厚，他对自己的能力抱有一种浪漫主义的幻想。而武士了解现实，没 有丝毫的妄自尊大。他对自己的能力和要完成的任务，有脚踏实地的作风。 他的行动从来不“过头”，从来不显摆自己。武士从来不用过分的行为来试图 证明给别人或者自己，他具备有他所希望的能力。</p>
</blockquote>
<p>武士是死过后重生的英雄.</p>
<p>武士能够感觉到死亡随 时都有可能降临，因此，一个被武士能量引导的男人知道他生命的短暂.这并不让他感到悲伤，反而让他充满了生命力。而这种强烈的内心体验只有他自己知道，而且从不外露。</p>
<blockquote>
<p>他用这种对生命的激情，引导他做每一个选择，一个武士把每一件事做的程度，就像是他活在这个世界上最后一天一样。“犹豫”这个词在武士的词典里不存在。因为犹豫会产生怀疑，怀疑会产生麻痹。麻痹就会导致最终的失败。他100%得投入到生活中，从不犹豫不决，从不麻痹。</p>
</blockquote>
<p><code>当一个男人去为了一个国家，一个民族，一场运动，一个大于他自己的事物而活着的时候，他成为了一个拥有成熟武士原型的男人。在这个阶段里，他的全部生命围绕着这样一个超越自我的使命，个人的得失则是完全次要的。</code></p>
<h3 id="正极-虐待狂-The-Saddist"><a href="#正极-虐待狂-The-Saddist" class="headerlink" title="正极:虐待狂 (The Saddist)"></a>正极:虐待狂 (The Saddist)</h3><blockquote>
<p>虐待狂把自己驱赶到生命的边缘。我们知道这样的人:医生，律师，创业家，政客，经常工作到很晚的经理，施加压力给自己的员工，强迫自己的员工加班。所有的工作狂人格，都是一种指向自己的暴力倾向。这些男人能忍受痛苦完成很多工作，然而他们付出的代价是自己的健康。最终以工作劳累而心脏病发作的男人比比皆是。</p>
<p>武士驱使自虐的能量，来自于深深的焦虑和不安和找不 到自我价值。当一个武士没有国王(The King)的命令去服从的时候，他生 命变得毫无方向，能量无从释放，于是会开始到处施展他们的战斗能力，攻 击他人，攻击自我。</p>
</blockquote>
<h3 id="负极-受虐狂-The-Masochist"><a href="#负极-受虐狂-The-Masochist" class="headerlink" title="负极:受虐狂(The Masochist)"></a>负极:受虐狂(The Masochist)</h3><blockquote>
<p>他倾向于自我的暴力，让他不仅自己自虐，而且还喜欢受虐.</p>
<p>你会发现他们什么工作强度都能忍受，上司说什么都说答应，允许别人持续得冒犯，侵犯自己的权利。他感到自己没有能力，抑郁，没有目 标，得过且过。活在别人的虐待中似乎是唯一的让他能感到“还活着”的方 式。</p>
<p>受虐狂实际上是一个面具。如果权利落在他的手中，他很有可能会突然爆发，自己突然变成一个经常压迫员工，以摧残别人生命为乐的虐待狂。</p>
</blockquote>
<h2 id="祭司-The-Magician"><a href="#祭司-The-Magician" class="headerlink" title="祭司 The Magician"></a>祭司 The Magician</h2><blockquote>
<p>祭司用他人生的智慧，去引导年轻人思考，去构建一个不仅是物质上，而且精神上丰富的世界。</p>
</blockquote>
<h3 id="正极-残酷的专家-The-Manipulator"><a href="#正极-残酷的专家-The-Manipulator" class="headerlink" title="正极:残酷的专家 The Manipulator"></a>正极:残酷的专家 The Manipulator</h3><blockquote>
<p>残酷的专家求知的目的并不引导别人，帮助别人。他希望通过了解别人不了解的知识而强大起来，用来攻击别人。他藏匿信息，摆布他人，阻止他们拥有更强健的心智。他经常主动误导他人，污蔑，嘲笑他人，并从中取乐。他这样对别人的伤害，同时也在伤害自己。因为，当他不去帮助别人的时候，他用知识让自己更了不起，让别人崇拜他的同时，他的思想会因此固化，让他也不能正常的，积极向前生活。最终，他自己也不能得到提高。</p>
</blockquote>
<h3 id="负极-无辜的阴谋家-The-Innocent-One"><a href="#负极-无辜的阴谋家-The-Innocent-One" class="headerlink" title="负极:无辜的阴谋家 The Innocent One"></a>负极:无辜的阴谋家 The Innocent One</h3><blockquote>
<p>阴谋家想得到祭司的身份地位，但不想去付出祭司所要付出的努力。他认为，求知不需要很多，能超过别人就足够。</p>
<p>他相当的懒惰，没看过几本书，真正钻研过，却喜欢吹嘘自己的知识成就。而实际上他所知道的东西只是皮毛。于是，不想付出努力，又要去标榜自己的聪明才智，他不得不攻击别人。其他的有见地的学说，学者的著作，他都喜欢批判一下。尽管他自己还不明白那里面在说什么。他认为那些都是值得怀疑的，都没有他聪明。</p>
<p>他也因此嫉妒，害怕那些真正努力成长的人，他期望去阻止其他人的成 长。在他“足够”的努力之间，如果能够绊别人一脚，减缓别人的成长速度， 就更完美了。他会因为别人的失败而偷乐。</p>
</blockquote>
<h2 id="诗人-The-Lover"><a href="#诗人-The-Lover" class="headerlink" title="诗人 The Lover"></a>诗人 The Lover</h2><blockquote>
<p>诗人能量的基础，来自于对万物的感知，和爱的能力。他具有多彩缤纷生活的激情，他充满了生命力，对食物，性爱，情绪的渴望。当他面临生活的艰难时拥有无限的创造力，让他能够毫无障碍的进行情感的联结与表达。诗人的存在，是去满足我们对情感的饥饿。</p>
<p>诗人对生命的热情不是通过认知的，而是通过感受。诗人渴望，身体上的和心灵上的触摸和被触摸。在诗人的世界里，没<br>有规则，没有道德伦理，没有任何边界和约束，他强烈的生活在万物皆一体的感受中。诗人是我们能够博爱的基础。</p>
<p>诗人是我们每个男人最陌生的，却又都拥有的原型。不管平时的工作和生活中你有多么忽略他，在某些人生感动的时刻，他的作用在你身上是不可忽略的。</p>
<p>比如，仅仅因为你喜欢某个女人，你就会为她做很多你平时不会做的事情。即便是你知道你们没有什么结果，她一旦开口，你就感到无比的动力。在现实中，男人的生命在大多数时候是被捆绑起来的。在闲暇之余，他会用自己的方式寻找自己的诗人:在游戏中，在小说中，在故事中，在爱情中。</p>
</blockquote>
<p><code>诗人会让武士和祭司更具有情感，具有人文精神，而不是一味的追求目标和知识。反过他来也需要他们的帮助，他需要武士的果断来铲除无控制的享乐，他需要祭司的才智来让自己从情感的纠缠中脱身，对待人生更客观，更长远。</code></p>
<h3 id="瘾君子-The-Addicted-Lover"><a href="#瘾君子-The-Addicted-Lover" class="headerlink" title="瘾君子 The Addicted Lover"></a>瘾君子 The Addicted Lover</h3><blockquote>
<p>当诗人缺乏国王引导的时候，他的第一个问题是:为什么我需要约束我的这些无尽美妙的体验?</p>
<p>于是，一个缺乏自我约束的诗人，也具备了成瘾性的人格。他很容易会落入毒品，香烟，酒精的魔掌中。</p>
</blockquote>
<h3 id="麻木情人-The-Impotent-Lover"><a href="#麻木情人-The-Impotent-Lover" class="headerlink" title="麻木情人 The Impotent Lover"></a>麻木情人 The Impotent Lover</h3><blockquote>
<p>麻木情人精神萎靡，生活没有激情。他对周围环境中的颜色一点都不敏感，仿佛世界是黑白的一样。他经常失眠，或者早上起不来，说话无精打采，吃饭没有味道。</p>
</blockquote>
<h2 id="国王"><a href="#国王" class="headerlink" title="国王"></a>国王</h2><p> 对大多数男人来讲，国王往往是最后一个上线的原型。</p>
<blockquote>
<p>当国王原型上线的时候，我们看到了神圣男孩从降生之日的惹人注目，发展到了具备成熟能量和能力来去改变世界的现有格局。他有强烈的方向感和勇气去带领武士作战，过人的智慧去和祭司一起治理臣民，和一颗向善的心和诗人一起让他的领土充满爱。</p>
<p>国王拥有主权去界定他国度的边界。在国界之内是祝福与繁荣，在国界之外是无秩序与混乱。他坐在大地的中心，将他的能量释放到国界内的各个角落，保护臣民免受外来侵袭，并且，如果有必要的话，支配武士来到边疆，进入战斗状态。</p>
</blockquote>
<p><code>国王的男人的使命感的最终载体，他是一个从神圣世界
带给现实世界中男人能量的大动脉。在国王原型的上线之前，一个男人不会知道他的使命究竟使什么。而当它出现在一个男人的心智中时，他就会像是一个有威望的父亲，他在给女人带来一个令人向往的世界的同时，让她们感到权威，稳重，与信赖。</code></p>
<p><code>对于还走在成熟道路上年轻人来讲，得到国王的祝福显得非常重要。</code></p>
<p>当一个年轻人被成熟的国王祝福的时候，他的内部结构会发生奇妙的变化。杂乱的思绪会突然被平伏，怀疑和焦虑会在那一刻烟消云散。因为，国王的远景为他拨开了云雾，用祝福的力量送他上路。</p>
<p>国王的阴影，其实就是由早期神圣男孩的阴影携带过来的。每个人，每个原型都有阴影，区别是，有些人大部分时间生活在中心位置，有些人则生活在阴影中。那么，是什么导致了一个年过不惑的男人，仍旧迟迟不能够唤醒他中心位置的国王?</p>
<p>早年家庭对一个男孩的过度溺爱或过度严厉，歪曲的母爱，和父亲不加 以引导(缺乏祭司能量)或者施暴，那么孩子就会从幼年期开始经历扭曲的 心理:他要么感到自己就是世界的中心，衣来伸手饭来张口;要么，他就一 无是处，来到这个世界完全是多余的。这为孩子的未来埋下了暴君/庸君的 种子。甚至，懦弱的他，会连越过男孩英雄阶段的机会都没有。</p>
<h3 id="正极-暴君-The-Tyrant"><a href="#正极-暴君-The-Tyrant" class="headerlink" title="正极:暴君 The Tyrant"></a>正极:暴君 The Tyrant</h3><blockquote>
<p>和处在中心能量位置的国王不同，暴君不希望去祝福，不愿意创造，而且，由于惧怕新生力量(其他神圣男孩)威胁他的国度，他必定要扼杀新生。</p>
<p>我们每个人内心中的一个暴君。如果我们处在权威位置上，当我们面临 压力，被强烈挑战的时候，暴君会随时跳出来，帮你“解决问题”。而他对你 臣民的伤害，则需要你更加努力去补救。</p>
</blockquote>
<h3 id="负极-庸君-The-Weakling"><a href="#负极-庸君-The-Weakling" class="headerlink" title="负极:庸君 The Weakling"></a>负极:庸君 The Weakling</h3><blockquote>
<p>一个庸君会觉得自己什么都不是。他只知道享乐，任其国度混乱，民不聊生。他平时看起来没有什么威胁，而一旦被挑衅，他的暴君本质会突然跳出来，做出毁灭性的决定。</p>
</blockquote>
<h2 id="认知性距离-Cognitive-Distance"><a href="#认知性距离-Cognitive-Distance" class="headerlink" title="认知性距离 Cognitive Distance"></a>认知性距离 Cognitive Distance</h2><blockquote>
<p>认知性距离是指原型能量和自我之间的距离。即，你可以展现这些精神品质，但你本身不是这些能量。这些天赐的精神品质只存在于每一刻的你的疏通当中，而你永远都不能成为这些能量本身。你只能通过每时每刻行为的选择，来让这些能量通过你散发到这个世界中来。</p>
</blockquote>
<p><code>你的才华，勇气，纪律，爱心，祝福，都是天赐之物，并不
是你作为一个凡人可以拥有的。而是他依靠你不懈的努力，让自己的肉体成为这些能量的通道才能达成的。</code></p>
<p><code>真实的伟大，并不是因为你做一个令人敬仰的人，而是你此时此刻选择去做令人敬仰的事情。</code></p>
<p>不管你在人生中的任何位置，你取得了任何成就，都应该把自己看做一个动脉而不是心脏。国王是一个传送王权的渠道，而不是<br>王权本身。做一个国王，并不是为了当国王所带来的利益，而是为了你的土地，臣民的繁荣。</p>
<h1 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h1><p>我读这本书的时候在很多原型上都能看到自己的影子。其实并不是当你从一个阶段过渡到另一个阶段，上一个阶段的影响就没有了。</p>
<p>我更觉得每一个原型它一直存在你的身体内部，只是当你逐渐成熟时，成熟的人格会把那些原型的平衡点更好的展现出来。</p>
<p>从男孩到男人，每个男孩都是在逐步成为掌控自己的国王。</p>
<p>我们曾经听过很多名言，比如林肯曾说:</p>
<p>父母给了一个男人前半生的长相，而后半生的长相是自己给 的。其实，林肯说得并不是长相本身。在中国的传统文化中，我们相信“面由心生”，林肯的这番话实际上指向的是男人的内在修养，即你后半生的内 在修养完全靠你自己创造。长相是一个人的内在气质的一个外在表现形式.</p>
<p>这和我以前小学听到的：<code>腹有诗书气自华</code>。</p>
<p>后来网上看到的，<code>你现在的气质里藏着你读过的书，跑过的步，爱过的人。</code></p>
<p>这都是由内而外的表现。</p>
<p>这本书值得多次反复去阅读，因为每一个阶段都能看到自己过去做过的事情在阴影部分是否对应。</p>
<p>吾日三省吾身。</p>
<p>大概这就是阅读所带来的收益，成为更好的自己。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;   最近把很多精力投入到了对一个运行3年的Web应用进行版本迭代和功能添加。国庆也一直投入时间进去,于是日常除了体能训练就是coding,
    
    </summary>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="读书笔记" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读后感" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>javascript框架设计第一版</title>
    <link href="http://wiki.haoqiao.me/wiki/%E9%98%85%E8%AF%BB/javascript%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%80%E7%89%88/"/>
    <id>http://wiki.haoqiao.me/wiki/阅读/javascript框架设计第一版/</id>
    <published>2017-09-20T11:18:20.000Z</published>
    <updated>2017-09-21T10:32:36.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="读书笔记" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读后感" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>聊聊架构</title>
    <link href="http://wiki.haoqiao.me/wiki/%E9%98%85%E8%AF%BB/%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84/"/>
    <id>http://wiki.haoqiao.me/wiki/阅读/聊聊架构/</id>
    <published>2017-09-18T02:36:00.000Z</published>
    <updated>2017-09-18T07:32:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><ol>
<li><p>生命周期的主体，比如用户的一次购买活动</p>
</li>
<li><p>生命周期可拆分，确定核心生命周期。</p>
<blockquote>
<p>空间上连续的限制可以通过拆分生命周期突破，形成空间上并行和时间上串行执行的状况。</p>
</blockquote>
</li>
<li><p>非核心生命周期一旦拆分出来，往往形成一个通用的服务。不再局限于原有的大的生命周期。</p>
<p>大生命周期也因此变得更加精简，可以专注自己的核心生命周期活动，节省更多时间。</p>
</li>
</ol>
<h1 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h1><h2 id="什么是架构-1"><a href="#什么是架构-1" class="headerlink" title="什么是架构"></a>什么是架构</h2><ul>
<li>必须由人执行的工作</li>
<li>每个人的时间有限</li>
<li>对目标系统有更高的要求</li>
<li>目标系统的复杂性使得单个人完成系统时会受限于时间</li>
</ul>
<blockquote>
<p>架构的思考来源于对生命周期的识别，以及拆分。</p>
</blockquote>
<h2 id="架构是什么"><a href="#架构是什么" class="headerlink" title="架构是什么"></a>架构是什么</h2><ul>
<li>对目标系统的边界进行界定。问题的主题确定一般就能确定边界，问题的确定可以明确核心生命周期</li>
<li>围绕目标系统核心生命周期进行切分。首先进行空间上的拆分，只有空间上并行才能减少每个人的执行时间。最终使得空间上管理可以并行，时间执行上串行。</li>
<li>对切分出来的部分，各种确定生命周期和主体，以及负责的角色。切出来的生命周期活动的结果都累计在改生命周期的主题上，这就是内聚。</li>
<li>在<code>非核心生命周期</code>和<code>核心生命周期</code>之间建立沟通机制，使非核心围绕核心建立树状结构.</li>
</ul>
<h1 id="架构的生命周期"><a href="#架构的生命周期" class="headerlink" title="架构的生命周期"></a>架构的生命周期</h1><ol>
<li>架构设计生命周期（非核心）</li>
</ol>
<blockquote>
<p>主要工作是研究业务本身的生命周期,根据业务面对的问题，发现瓶颈，进行架构的拆分。进架构的拆分。拆分的原则是把非核心生命周期拆分出来，由不同角色负责，让人们可以并行工作。每个角色达到<code>权责的对等</code>,并形成不同的角色各种的激励机制。目的是让业务成长更加强大，服务于更多人</p>
</blockquote>
<ol>
<li>架构实施生命周期（核心）</li>
</ol>
<p>为了把架构的拆分落实到组织架构上，让每个人能够按照架构的职责拆分，并行工作。执行各自的生命周期。这些角色按照树状架构协调互相之间的协调，使得每个拆分出非核心生命周期的<br>增长，都贡献给核心生命周期。同时自己也受益。</p>
<h1 id="识别问题"><a href="#识别问题" class="headerlink" title="识别问题"></a>识别问题</h1><h1 id="切分原则"><a href="#切分原则" class="headerlink" title="切分原则"></a>切分原则</h1><ol>
<li>架构的切分导火索是人的负载太重，也就是时间不够。</li>
<li>架构的切分实际是对利益相关人的利益进行切分或合并，使得每个利益相关人的权责对等。每个利益相关人可以对自己的利益负责。</li>
<li>架构切分的最终结果体现在组织架构上，这样能让架构落地并推进。</li>
<li>架构切分一定是树状，分层越少，尽可能平衡，让整个系统效率最大化。</li>
</ol>
<h1 id="什么是软件架构"><a href="#什么是软件架构" class="headerlink" title="什么是软件架构"></a>什么是软件架构</h1><p>软件开发周期，软件工程师需要完成以下：</p>
<blockquote>
<p>学习业务知识，认识业务的生命周期，以及生命周期中所涉及的利益相关人的核心利益诉求。业务是如何拆分生命周期，拆分出来的核心生命周期。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期&quot; class=&quot;headerlink&quot; title=&quot;生命周期&quot;&gt;&lt;/a&gt;生命周期&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;生命周期的主体，比如用户的一次购买活动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生命周期可拆分，确定核心生命周期
    
    </summary>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="读书笔记" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读后感" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>深入React技术栈</title>
    <link href="http://wiki.haoqiao.me/wiki/%E9%98%85%E8%AF%BB/%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <id>http://wiki.haoqiao.me/wiki/阅读/深入React技术栈/</id>
    <published>2017-09-17T05:36:18.000Z</published>
    <updated>2017-09-17T14:51:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h2><p>React基于Virtual DOM实现了一个SyntheticEvent(事件层) 我们所定义的事件处理器会接收到一个SyntheticEvent对象的实例。</p>
<blockquote>
<p>事件处理程序通过 合成事件（SyntheticEvent）的实例传递，SyntheticEvent 是浏览器原生事件跨浏览器的封装。SyntheticEvent 和浏览器原生事件一样有 stopPropagation()、preventDefault() 接口，而且这些接口所有浏览器兼容。</p>
</blockquote>
<p>所有事件绑定到最外层。</p>
<p>访问原生事件对象通过 <code>nativeEvent</code></p>
<p>必须用驼峰形式写事件的属性名 比如 <code>onClick={...}</code></p>
<h3 id="合成事件的实现机制"><a href="#合成事件的实现机制" class="headerlink" title="合成事件的实现机制"></a>合成事件的实现机制</h3><p><strong><code>事件委派</code></strong></p>
<p>事件代理机制:</p>
<p>并不会直接绑定到真实节点。所有事件绑定到结构最外层。</p>
<p>使用统一的<code>事件监听器</code>。</p>
<p><code>事件监听器</code>维护了一个映射来保存所有的组件内部的事件监听和处理函数。</p>
<p>组件挂载或卸载时，只是在<code>事件监听器</code>上插入和删除一些对象。</p>
<p>当事件发生时，统一的事件监听器去处理。在映射中找到对应处理。简化了事件处理和回收机制，效率提升。</p>
<p><strong><code>自动绑定</code></strong></p>
<p>在React组件，每个方法的上下文自动绑定该组件实例。自动绑定this到当前组件。</p>
<p>当使用ES6 classes或者纯函数。这种自动绑定消失，我们需要自己去绑定。</p>
<p><code>bind方法</code> 可以传递参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onClick=&#123;this.handleClick.bind(this,&apos;arg&apos;)&#125;</div></pre></td></tr></table></figure>
<p><code>双冒号语法</code> 不传递参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onClick=&#123;::this.handleClick&#125;</div></pre></td></tr></table></figure>
<p><code>构造器内声明</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">handleClick(e)&#123;</div><div class="line">  this.handleClick=this.handleClick.bind(this)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">onClick=&#123;this.handleClick&#125;</div></pre></td></tr></table></figure>
<p><code>箭头函数</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">const handleClick = (e) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">onClick=&#123;this.handleClick&#125;</div></pre></td></tr></table></figure>
<h2 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h2><p>用 compose 来组合样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">.base&#123;&#125;</div><div class="line"></div><div class="line">.normal &#123;</div><div class="line">  compose:base;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">import styles from &apos;./Button.css&apos;</div><div class="line">&lt;button class=&#123;styles.normal&#125;&gt; click &lt;/button&gt;</div><div class="line"></div><div class="line">=&gt;</div><div class="line"></div><div class="line">&lt;button class=&quot;button--base--abc123 button--normal--sss&quot;&gt; click &lt;/button&gt;</div></pre></td></tr></table></figure>
<h1 id="解读React源码"><a href="#解读React源码" class="headerlink" title="解读React源码"></a>解读React源码</h1><h1 id="React应用架构"><a href="#React应用架构" class="headerlink" title="React应用架构"></a>React应用架构</h1><h2 id="React-MiddleWare"><a href="#React-MiddleWare" class="headerlink" title="React MiddleWare"></a>React MiddleWare</h2><p>Redux 借鉴了Koa的MiddleWare思想。</p>
<h2 id="Redux-中的组件"><a href="#Redux-中的组件" class="headerlink" title="Redux 中的组件"></a>Redux 中的组件</h2><table>
<thead>
<tr>
<th></th>
<th>展示型组件</th>
<th>容器型组件</th>
</tr>
</thead>
<tbody>
<tr>
<td>目的</td>
<td>长什么样子(标签，样式)</td>
<td>干什么用(获取数据，更新状态)</td>
</tr>
<tr>
<td>是否感知redux</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>获取数据</td>
<td>从this.props</td>
<td>从redux状态树中获取</td>
</tr>
<tr>
<td>要改变数据</td>
<td>调用从props中传入的action creator</td>
<td>直接分发action</td>
</tr>
<tr>
<td>实际创建于</td>
<td>开发者自身</td>
<td>由React Redux创建</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事件系统&quot;&gt;&lt;a href=&quot;#事件系统&quot; class=&quot;headerlink&quot; title=&quot;事件系统&quot;&gt;&lt;/a&gt;事件系统&lt;/h2&gt;&lt;p&gt;React基于Virtual DOM实现了一个SyntheticEvent(事件层) 我们所定义的事件处理器会接收到一个Sy
    
    </summary>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="读书笔记" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读后感" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>开发配置</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E6%A0%87%E5%87%86/%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/开发标准/开发配置/</id>
    <published>2017-09-16T03:23:22.000Z</published>
    <updated>2017-09-16T10:56:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mongodb配置"><a href="#Mongodb配置" class="headerlink" title="Mongodb配置"></a>Mongodb配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">1. 切换数据库到 use admin</div><div class="line">2. 指定了数据库 testDb ,拥有权限: userAdmin</div><div class="line"> db.createUser(</div><div class="line">   &#123;</div><div class="line">     user: &quot;test&quot;,</div><div class="line">     pwd: &quot;test666&quot;,</div><div class="line">     roles: [ &#123; role: &quot;userAdmin&quot;, db: &quot;testDb&quot; &#125; ]</div><div class="line">   &#125;</div><div class="line"> )</div><div class="line"> 3. 验证下上面创建的账号 cvte</div><div class="line"></div><div class="line"> db.auth(&apos;test&apos;,&apos;test666&apos;)</div><div class="line"> =&gt; 1</div><div class="line"></div><div class="line"> 4.用 mongoose 指定用户连接数据库</div><div class="line"> </div><div class="line"> var mongoose = require(&apos;mongoose&apos;);</div><div class="line"></div><div class="line">module.exports = function (done) &#123;</div><div class="line">  mongoose.connect(&quot;mongodb://test:test666@127.0.0.1:27017/admin&quot;, &#123;auto_reconnect: true&#125;, done);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mongodb配置&quot;&gt;&lt;a href=&quot;#Mongodb配置&quot; class=&quot;headerlink&quot; title=&quot;Mongodb配置&quot;&gt;&lt;/a&gt;Mongodb配置&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发标准" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E6%A0%87%E5%87%86/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发配置" scheme="http://wiki.haoqiao.me/tags/%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>typescript 基础开发</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E6%A0%87%E5%87%86/TypeScript%E5%BC%80%E5%8F%91/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/开发标准/TypeScript开发/</id>
    <published>2017-09-05T09:49:39.000Z</published>
    <updated>2018-02-07T14:28:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://www.typescriptlang.org/docs/handbook/jsx.html" rel="external nofollow noopener noreferrer" target="_blank">官方英文文档</a></p>
<p><a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tutorials/TypeScript%20in%205%20minutes.html" rel="external nofollow noopener noreferrer" target="_blank">官方中文文档</a></p>
<p><a href="https://ts.xcatliu.com/basics/primitive-data-types.html" rel="external nofollow noopener noreferrer" target="_blank">非官方文档</a></p>
<p><a href="http://definitelytyped.org/" rel="external nofollow noopener noreferrer" target="_blank">写d.ts参考</a></p>
<blockquote>
<p><a href="https://zhongsp.gitbooks.io/typescript-handbook/" rel="external nofollow noopener noreferrer" target="_blank">typescript-handbook</a></p>
<h4 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 原始值</div><div class="line">const isDone: boolean = false;</div><div class="line">const amount: number = 6;</div><div class="line">const address: string = &apos;beijing&apos;;</div><div class="line">const greeting: string = `Hello World`;</div><div class="line">// 数组</div><div class="line">const list: number[] = [1, 2, 3];</div><div class="line">const list: Array&lt;number&gt; = [1, 2, 3];</div><div class="line">// 元组</div><div class="line">const name: [string, string] = [&apos;Sean&apos;, &apos;Sun&apos;];</div><div class="line">// 枚举</div><div class="line">enum Color &#123;</div><div class="line">    Red,</div><div class="line">    Green,</div><div class="line">    Blue</div><div class="line">&#125;;</div><div class="line">const c: Color = Color.Green;</div><div class="line">// 任意值：可以调用任意方法</div><div class="line">let anyTypes: any = 4;</div><div class="line">anyTypes = &apos;any&apos;;</div><div class="line">anyTypes = false</div><div class="line">// 空值</div><div class="line">function doSomething (): void &#123;</div><div class="line">    return undefined;</div><div class="line">&#125;</div><div class="line">// 类型断言</div><div class="line">let someValue: any = &quot;this is a string&quot;;</div><div class="line">let strLength: number = (someValue as string).length;</div></pre></td></tr></table></figure>
<h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">let myFavoriteNumber: string | number;</div><div class="line">myFavoriteNumber = &apos;seven&apos;;</div><div class="line">myFavoriteNumber = 7;</div></pre></td></tr></table></figure>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><blockquote>
<p>接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">interface Person &#123;</div><div class="line">  name: string;</div><div class="line">  age: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let xcatliu: Person = &#123;</div><div class="line">  name: &apos;Xcat Liu&apos;,</div><div class="line">  age: 25,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 可选属性,可选属性的含义是该属性可以不存在。</div><div class="line"></div><div class="line">interface Person &#123;</div><div class="line">  name: string;</div><div class="line">  age?: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let xcatliu: Person = &#123;</div><div class="line">  name: &apos;Xcat Liu&apos;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">// 任意属性 确定属性和可选属性都必须是它的子属性：</div><div class="line">interface Person &#123;</div><div class="line">  name: string;</div><div class="line">  age?: number;</div><div class="line">  [propName: string]: any;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let xcatliu: Person = &#123;</div><div class="line">  name: &apos;Xcat Liu&apos;,</div><div class="line">  website: &apos;http://xcatliu.com&apos;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">// 只读属性  readonly 定义只读属性</div><div class="line"></div><div class="line">interface Person &#123;</div><div class="line">  readonly id: number;</div><div class="line">  name: string;</div><div class="line">  age?: number;</div><div class="line">  [propName: string]: any;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let xcatliu: Person = &#123;</div><div class="line">  id: 89757,</div><div class="line">  name: &apos;Xcat Liu&apos;,</div><div class="line">  website: &apos;http://xcatliu.com&apos;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xcatliu.id = 9527; // error</div></pre></td></tr></table></figure>
<h4 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</div><div class="line"></div><div class="line"></div><div class="line">interface NumberArray &#123;</div><div class="line">  [index: number]: number;</div><div class="line">&#125;</div><div class="line">let fibonacci: NumberArray = [1, 1, 2, 3, 5];</div><div class="line"></div><div class="line">let list: any[] = [&apos;Xcat Liu&apos;, 25, &#123; website: &apos;http://xcatliu.com&apos; &#125;];</div></pre></td></tr></table></figure>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function sum(x: number, y: number): number &#123;</div><div class="line">  return x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sum(1, 2, 3); //输入多余的（或者少于要求的）参数，是不被允许的：</div><div class="line"></div><div class="line">let mySum = function (x: number, y: number): number &#123;</div><div class="line">  return x + y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//接口中函数的定义</div><div class="line"></div><div class="line">interface SearchFunc &#123;</div><div class="line">  (source: string, subString: string): boolean;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let mySearch: SearchFunc;</div><div class="line">mySearch = function(source: string, subString: string) &#123;</div><div class="line">  return source.search(subString) !== -1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 可选参数</div><div class="line"></div><div class="line">function buildName(firstName: string, lastName?: string) &#123; // 可选参数后面不允许再出现必须参数</div><div class="line">  if (lastName) &#123;</div><div class="line">    return firstName + &apos; &apos; + lastName;</div><div class="line">  &#125; else &#123;</div><div class="line">    return firstName;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">let xcatliu = buildName(&apos;Xcat&apos;, &apos;Liu&apos;);</div><div class="line">let xcat = buildName(&apos;Xcat&apos;);</div><div class="line"></div><div class="line">// 参数默认值</div><div class="line"></div><div class="line">function buildName(firstName: string, lastName: string = &apos;Liu&apos;) &#123;</div><div class="line">  return firstName + &apos; &apos; + lastName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>&lt;类型&gt;值</p>
<p>// 或</p>
<p>值 as 类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function getLength(something: string | number): number &#123;</div><div class="line">  if ((&lt;string&gt;something).length) &#123;</div><div class="line">    return (&lt;string&gt;something).length;</div><div class="line">  &#125; else &#123;</div><div class="line">    return something.toString().length;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h4><p>通常我们会把类型声明放到一个单独的文件中，这就是声明文件：</p>
<p>// jQuery.d.ts</p>
<p>declare var jQuery: (string) =&gt; any;<br>我们约定声明文件以 .d.ts 为后缀。</p>
<p>然后在使用到的文件的开头，用「三斜线指令」表示引用了声明文件：</p>
<p>/// <reference path="./jQuery.d.ts"></reference></p>
<p>jQuery(‘#foo’);</p>
<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><blockquote>
<p>类型别名用来给一个类型起个新名字。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">type Name = string;</div><div class="line">type NameResolver = () =&gt; string;</div><div class="line">type NameOrResolver = Name | NameResolver;</div><div class="line">function getName(n: NameOrResolver): Name &#123;</div><div class="line">  if (typeof n === &apos;string&apos;) &#123;</div><div class="line">    return n;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    return n();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h4><blockquote>
<p>字符串字面量类型用来约束取值只能是某几个字符串中的一个。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">type EventNames = &apos;click&apos; | &apos;scroll&apos; | &apos;mousemove&apos;;</div><div class="line">function handleEvent(ele: Element, event: EventNames) &#123;</div><div class="line">  // do something</div><div class="line">&#125;</div><div class="line"></div><div class="line">handleEvent(document.getElementById(&apos;hello&apos;), &apos;scroll&apos;);  // 没问题</div><div class="line">handleEvent(document.getElementById(&apos;world&apos;), &apos;dbclick&apos;); // 报错，event 不能为 &apos;dbclick&apos;</div></pre></td></tr></table></figure>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><blockquote>
<p>数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">let xcatliu: [string, number] = [&apos;Xcat Liu&apos;, 25];</div><div class="line"></div><div class="line">let xcatliu: [string, number];</div><div class="line">xcatliu[0] = &apos;Xcat Liu&apos;;</div><div class="line">xcatliu[1] = 25;</div><div class="line"></div><div class="line">xcatliu[0].slice(1);</div><div class="line">xcatliu[1].toFixed(2);</div><div class="line"></div><div class="line">// Declare a tuple type</div><div class="line">let x: [string, number];</div><div class="line">// Initialize it</div><div class="line">x = [&apos;hello&apos;, 10]; // OK</div><div class="line">// Initialize it incorrectly</div><div class="line">x = [10, &apos;hello&apos;]; // Error</div></pre></td></tr></table></figure>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><blockquote>
<p>类(Class)：定义了一件事物的抽象特点，包含它的属性和方法<br>对象（Object）：类的实例，通过 new 生成<br>面向对象（OOP）的三大特性：封装、继承、多态</p>
<p>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</p>
<p>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</p>
<p>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat<br>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</p>
<p>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法</p>
<p>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</p>
<p>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用 class 定义类，使用 constructor 定义构造函数。</div><div class="line"></div><div class="line">通过 new 生成新实例的时候，会自动调用构造函数。</div><div class="line"></div><div class="line">class Animal &#123;</div><div class="line">  constructor(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line">  sayHi() &#123;</div><div class="line">    return `My name is $&#123;this.name&#125;`;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let a = new Animal(&apos;Jack&apos;);</div><div class="line">console.log(a.sayHi()); // My name is Jack</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">类的继承</div><div class="line"></div><div class="line">使用 extends 关键字实现继承，子类中使用 super 关键字来调用父类的构造函数和方法。</div><div class="line"></div><div class="line">class Cat extends Animal &#123;</div><div class="line">  constructor(name) &#123;</div><div class="line">    super(name); // 调用父类的 constructor(name)</div><div class="line">    console.log(this.name);</div><div class="line">  &#125;</div><div class="line">  sayHi() &#123;</div><div class="line">    return &apos;Meow, &apos; + super.sayHi(); // 调用父类的 sayHi()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let c = new Cat(&apos;Tom&apos;); // Tom</div><div class="line">console.log(c.sayHi()); // Meow, My name is Tom</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">存取器</div><div class="line"></div><div class="line">使用 getter 和 setter 可以改变属性的赋值和读取行为：</div><div class="line"></div><div class="line">class Animal &#123;</div><div class="line">  constructor(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line">  get name() &#123;</div><div class="line">    return &apos;Jack&apos;;</div><div class="line">  &#125;</div><div class="line">  set name(value) &#123;</div><div class="line">    console.log(&apos;setter: &apos; + value);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let a = new Animal(&apos;Kitty&apos;); // setter: Kitty</div><div class="line">a.name = &apos;Tom&apos;; // setter: Tom</div><div class="line">console.log(a.name); // Jack</div><div class="line"></div><div class="line"></div><div class="line">静态方法</div><div class="line"></div><div class="line">使用 static 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用：</div><div class="line"></div><div class="line">class Animal &#123;</div><div class="line">  static isAnimal(a) &#123;</div><div class="line">    return a instanceof Animal;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let a = new Animal(&apos;Jack&apos;);</div><div class="line">Animal.isAnimal(a); // true</div><div class="line">a.isAnimal(a); // TypeError: a.isAnimal is not a function</div></pre></td></tr></table></figure>
<h4 id="TypeScript-中类的用法"><a href="#TypeScript-中类的用法" class="headerlink" title="TypeScript 中类的用法"></a>TypeScript 中类的用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。</div><div class="line"></div><div class="line">public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的</div><div class="line">private 修饰的属性或方法是私有的，不能在声明它的类的外部访问</div><div class="line">protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的</div><div class="line">下面举一些例子：</div><div class="line"></div><div class="line">class Animal &#123;</div><div class="line">  public name;</div><div class="line">  public constructor(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let a = new Animal(&apos;Jack&apos;);</div><div class="line">console.log(a.name); // Jack</div><div class="line">a.name = &apos;Tom&apos;;</div><div class="line">console.log(a.name); // Tom</div><div class="line">上面的例子中，name 被设置为了 public，所以直接访问实例的 name 属性是允许的。</div><div class="line"></div><div class="line">很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 private 了：</div><div class="line"></div><div class="line">class Animal &#123;</div><div class="line">  private name;</div><div class="line">  public constructor(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let a = new Animal(&apos;Jack&apos;);</div><div class="line">console.log(a.name); // Jack</div><div class="line">a.name = &apos;Tom&apos;;</div><div class="line"></div><div class="line">// index.ts(9,13): error TS2341: Property &apos;name&apos; is private and only accessible within class &apos;Animal&apos;.</div><div class="line">// index.ts(10,1): error TS2341: Property &apos;name&apos; is private and only accessible within class &apos;Animal&apos;.</div><div class="line">需要注意的是，TypeScript 编译之后的代码中，并没有限制 private 属性在外部的可访问性。</div><div class="line"></div><div class="line">上面的例子编译后的代码是：</div><div class="line"></div><div class="line">var Animal = (function () &#123;</div><div class="line">    function Animal(name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    return Animal;</div><div class="line">&#125;());</div><div class="line">var a = new Animal(&apos;Jack&apos;);</div><div class="line">console.log(a.name);</div><div class="line">a.name = &apos;Tom&apos;;</div><div class="line">使用 private 修饰的属性或方法，在子类中也是不允许访问的：</div><div class="line"></div><div class="line">class Animal &#123;</div><div class="line">  private name;</div><div class="line">  public constructor(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat extends Animal &#123;</div><div class="line">  constructor(name) &#123;</div><div class="line">    super(name);</div><div class="line">    console.log(this.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// index.ts(11,17): error TS2341: Property &apos;name&apos; is private and only accessible within class &apos;Animal&apos;.</div><div class="line">而如果是用 protected 修饰，则允许在子类中访问：</div><div class="line"></div><div class="line">class Animal &#123;</div><div class="line">  protected name;</div><div class="line">  public constructor(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat extends Animal &#123;</div><div class="line">  constructor(name) &#123;</div><div class="line">    super(name);</div><div class="line">    console.log(this.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>抽象类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">abstract class Animal &#123;</div><div class="line">  public name;</div><div class="line">  public constructor(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line">  public abstract sayHi();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat extends Animal &#123;</div><div class="line">  public sayHi() &#123;</div><div class="line">    console.log(`Meow, My name is $&#123;this.name&#125;`);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let cat = new Cat(&apos;Tom&apos;);</div></pre></td></tr></table></figure>
<h4 id="一个类可以实现多个接口："><a href="#一个类可以实现多个接口：" class="headerlink" title="一个类可以实现多个接口："></a>一个类可以实现多个接口：</h4><blockquote>
<p>一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">interface Alarm &#123;</div><div class="line">  alert();</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface Light &#123;</div><div class="line">  lightOn();</div><div class="line">  lightOff();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Car implements Alarm, Light &#123;</div><div class="line">  alert() &#123;</div><div class="line">    console.log(&apos;Car alert&apos;);</div><div class="line">  &#125;</div><div class="line">  lightOn() &#123;</div><div class="line">    console.log(&apos;Car light on&apos;);</div><div class="line">  &#125;</div><div class="line">  lightOff() &#123;</div><div class="line">    console.log(&apos;Car light off&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><blockquote>
<p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：</div><div class="line"></div><div class="line">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</div><div class="line">  let result = [];</div><div class="line">  for (let i = 0; i &lt; length; i++) &#123;</div><div class="line">    result[i] = value;</div><div class="line">  &#125;</div><div class="line">  return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">createArray&lt;string&gt;(3, &apos;x&apos;); // [&apos;x&apos;, &apos;x&apos;, &apos;x&apos;]</div><div class="line"></div><div class="line"></div><div class="line">在函数名后添加了 &lt;T&gt;，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array&lt;T&gt; 中即可使用了</div></pre></td></tr></table></figure>
<p><code>多个类型参数</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">定义泛型的时候，可以一次定义多个类型参数：</div><div class="line"></div><div class="line">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;</div><div class="line">  return [tuple[1], tuple[0]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">swap([7, &apos;seven&apos;]); // [&apos;seven&apos;, 7]</div><div class="line">上例中，我们定义了一个 swap 函数，用来交换输入的元组。</div></pre></td></tr></table></figure>
<p><code>泛型约束</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是泛型约束：</div><div class="line"></div><div class="line">interface Lengthwise &#123;</div><div class="line">  length: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</div><div class="line">  console.log(arg.length);</div><div class="line">  return arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">多个类型参数之间也可以互相约束：</div><div class="line"></div><div class="line">function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123;</div><div class="line">  for (let id in source) &#123;</div><div class="line">    target[id] = (&lt;T&gt;source)[id];</div><div class="line">  &#125;</div><div class="line">  return target;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;</div><div class="line"></div><div class="line">copyFields(x, &#123; b: 10, d: 20 &#125;);</div><div class="line">上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。</div></pre></td></tr></table></figure>
<p><code>泛型接口</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">interface CreateArrayFunc &#123;</div><div class="line">  &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let createArray: CreateArrayFunc;</div><div class="line">createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</div><div class="line">  let result = [];</div><div class="line">  for (let i = 0; i &lt; length; i++) &#123;</div><div class="line">    result[i] = value;</div><div class="line">  &#125;</div><div class="line">  return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">createArray(3, &apos;x&apos;); // [&apos;x&apos;, &apos;x&apos;, &apos;x&apos;]</div></pre></td></tr></table></figure>
<p><code>泛型类</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class GenericNumber&lt;T&gt; &#123;</div><div class="line">    zeroValue: T;</div><div class="line">    add: (x: T, y: T) =&gt; T;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let myGenericNumber = new GenericNumber&lt;number&gt;();</div><div class="line">myGenericNumber.zeroValue = 0;</div><div class="line">myGenericNumber.add = function(x, y) &#123; return x + y; &#125;;</div></pre></td></tr></table></figure>
<h2 id="提升学习"><a href="#提升学习" class="headerlink" title="提升学习"></a>提升学习</h2><h4 id="接口学习"><a href="#接口学习" class="headerlink" title="接口学习"></a>接口学习</h4><p>常用的接口定义一般是这么写的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">interface Project&#123;</div><div class="line">  _id : String,</div><div class="line">  projectName?: String,</div><div class="line">  projectUrl?: String,</div><div class="line">  projectDesc?: String,</div><div class="line">  version?: String,</div><div class="line">  transferUrl?: String,</div><div class="line">  status?: String,</div><div class="line">  type?: String,</div><div class="line">  teamMember?: Array&lt;any&gt;,</div><div class="line">  interfaceList?: Array&lt;any&gt;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这在约定好接口字段的时候很管用，但是有时候字段没约定好，比如有时候可能会传入多余的数据，这个时候编译前会自动报错提醒。</p>
<p>此时可以考虑这么写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">interface SquareConfig &#123;</div><div class="line">    color?: string;</div><div class="line">    width?: number;</div><div class="line">    [propName: string]: any;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。</div></pre></td></tr></table></figure>
<h4 id="泛型学习"><a href="#泛型学习" class="headerlink" title="泛型学习"></a>泛型学习</h4><p>经过学习，除去经常用的接口定义 Interface, 以及常用的基本类型定义。想要更优写法肯定需要应用上泛型。</p>
<blockquote>
<p>泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>
<p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 </p>
<p>泛型就是指定一个表示类型的变量，用它来代替某个实际的类型用于编程，而后通过实际调用时传入或推导的类型来对其进行替换，以达到一段使用泛型程序可以实际适应不同类型的目的。</p>
</blockquote>
<p><code>HandBook</code> 上有几个例子，比如当需要一种方法使返回值的类型与传入参数的类型是相同的情况下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function identity&lt;T&gt;(arg: T): T &#123;</div><div class="line">    return arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。</div></pre></td></tr></table></figure>
<p>还有就是泛型类的应用。</p>
<p>泛型类其实多数时候是应用于容器类。假设我们需要实现一个 FilteredList，我们可以向其中 add()(添加) 任意数据，但是它在添加的时候会自动过滤掉不符合条件的一些，最终通过 get all() 输出所有符合条件的数据(数组)。而过滤条件在构造对象的时候，以函数或 Lambda 表达式提供。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 声明泛型类，类型变量为 T</div><div class="line">class FilteredList&lt;T&gt; &#123;</div><div class="line">    // 声明过滤器是以 T 为参数类型，返回 boolean 的函数表达式</div><div class="line">    filter: (v: T) =&gt; boolean;</div><div class="line">    // 声明数据是 T 数组类型</div><div class="line">    data: T[];</div><div class="line">    constructor(filter: (v: T) =&gt; boolean) &#123;</div><div class="line">        this.filter = filter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    add(value: T) &#123;</div><div class="line">        if (this.filter(value)) &#123;</div><div class="line">            this.data.push(value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    get all(): T[] &#123;</div><div class="line">        return this.data;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 处理 string 类型的 FilteredList</div><div class="line">const validStrings = new FilteredList&lt;string&gt;(s =&gt; !s);</div><div class="line"></div><div class="line">// 处理 number 类型的 FilteredList</div><div class="line">const positiveNumber  = new FilteredList&lt;number&gt;(n =&gt; n &gt; 0);</div></pre></td></tr></table></figure>
<p>这个可以应用于维护本地数据的地方，以及ajax提交数据的一些地方。主要是用于筛选数据。我们完全可以基于这个思想做一些多条件的过滤。在很多对数据需要处理的地方这个还是很有用的。</p>
<h3 id="命名空间与模块"><a href="#命名空间与模块" class="headerlink" title="命名空间与模块"></a>命名空间与模块</h3><p> “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”。</p>
<p> 常用的 <code>helper函数</code>，封装的 <code>until</code> 系列都是习惯用 export 导出模块然后引用的。但是一些验证函数如果也这么使用就不稳妥了。</p>
<p> 随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们类型的同时还不用担心与其它对象产生命名冲突。 因此，我们把验证器包裹到一个命名空间内，而不是把它们放在模块下。<br>  我们来看一个例子。在之前我们是这么写的:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">  interface StringValidator &#123;</div><div class="line">    isAcceptable(s: string): boolean;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let lettersRegexp = /^[A-Za-z]+$/;</div><div class="line">let numberRegexp = /^[0-9]+$/;</div><div class="line"></div><div class="line">class LettersOnlyValidator implements StringValidator &#123;</div><div class="line">    isAcceptable(s: string) &#123;</div><div class="line">        return lettersRegexp.test(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ZipCodeValidator implements StringValidator &#123;</div><div class="line">    isAcceptable(s: string) &#123;</div><div class="line">        return s.length === 5 &amp;&amp; numberRegexp.test(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Some samples to try</div><div class="line">let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];</div><div class="line"></div><div class="line">// Validators to use</div><div class="line">let validators: &#123; [s: string]: StringValidator; &#125; = &#123;&#125;;</div><div class="line">validators[&quot;ZIP code&quot;] = new ZipCodeValidator();</div><div class="line">validators[&quot;Letters only&quot;] = new LettersOnlyValidator();</div><div class="line"></div><div class="line">// Show whether each string passed each validator</div><div class="line">for (let s of strings) &#123;</div><div class="line">    for (let name in validators) &#123;</div><div class="line">        let isMatch = validators[name].isAcceptable(s);</div><div class="line">        console.log(`&apos;$&#123; s &#125;&apos; $&#123; isMatch ? &quot;matches&quot; : &quot;does not match&quot; &#125; &apos;$&#123; name &#125;&apos;.`);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后改成命名空间的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">namespace Validation &#123;</div><div class="line">    export interface StringValidator &#123;</div><div class="line">        isAcceptable(s: string): boolean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    const lettersRegexp = /^[A-Za-z]+$/;</div><div class="line">    const numberRegexp = /^[0-9]+$/;</div><div class="line"></div><div class="line">    export class LettersOnlyValidator implements StringValidator &#123;</div><div class="line">        isAcceptable(s: string) &#123;</div><div class="line">            return lettersRegexp.test(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    export class ZipCodeValidator implements StringValidator &#123;</div><div class="line">        isAcceptable(s: string) &#123;</div><div class="line">            return s.length === 5 &amp;&amp; numberRegexp.test(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Some samples to try</div><div class="line">let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];</div><div class="line"></div><div class="line">// Validators to use</div><div class="line">let validators: &#123; [s: string]: Validation.StringValidator; &#125; = &#123;&#125;;</div><div class="line">validators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator();</div><div class="line">validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();</div><div class="line"></div><div class="line">// Show whether each string passed each validator</div><div class="line">for (let s of strings) &#123;</div><div class="line">    for (let name in validators) &#123;</div><div class="line">        console.log(`&quot;$&#123; s &#125;&quot; - $&#123; validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; &#125; $&#123; name &#125;`);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很明显这个组织格式差别不大，但是在一个命名空间内可以避免一些不必要的冲突。</p>
<p>然后我们可以将一些不同逻辑的代码进行物理分割，但是在逻辑上，在同一个命名空间内，即使它们分离两地但是还是心连心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Validation.ts</div><div class="line">namespace Validation &#123;</div><div class="line">    export interface StringValidator &#123;</div><div class="line">        isAcceptable(s: string): boolean;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">LettersOnlyValidator.ts</div><div class="line">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</div><div class="line">namespace Validation &#123;</div><div class="line">    const lettersRegexp = /^[A-Za-z]+$/;</div><div class="line">    export class LettersOnlyValidator implements StringValidator &#123;</div><div class="line">        isAcceptable(s: string) &#123;</div><div class="line">            return lettersRegexp.test(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">ZipCodeValidator.ts</div><div class="line">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</div><div class="line">namespace Validation &#123;</div><div class="line">    const numberRegexp = /^[0-9]+$/;</div><div class="line">    export class ZipCodeValidator implements StringValidator &#123;</div><div class="line">        isAcceptable(s: string) &#123;</div><div class="line">            return s.length === 5 &amp;&amp; numberRegexp.test(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Test.ts</div><div class="line">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</div><div class="line">/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;</div><div class="line">/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;</div><div class="line"></div><div class="line">// Some samples to try</div><div class="line">let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];</div><div class="line"></div><div class="line">// Validators to use</div><div class="line">let validators: &#123; [s: string]: Validation.StringValidator; &#125; = &#123;&#125;;</div><div class="line">validators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator();</div><div class="line">validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();</div><div class="line"></div><div class="line">// Show whether each string passed each validator</div><div class="line">for (let s of strings) &#123;</div><div class="line">    for (let name in validators) &#123;</div><div class="line">        console.log(`&quot;$&#123; s &#125;&quot; - $&#123; validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; &#125; $&#123; name &#125;`);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>模块的基本都了解，在 Typescirpt 中，我们可以用更好的方式组织模块。</p>
<p>比如我们常常引用自己的模块是通过相对导入。</p>
<p>比如 <code>import { DefaultHeaders } from &quot;../constants/http&quot;;</code></p>
<p>我们引用的一些外部模块是非相对的.</p>
<p>比如 <code>import * as $ from &quot;jQuery&quot;;</code></p>
<p>对于一些比较成熟的依赖库我们可以通过将其作为外部模块载入。</p>
<blockquote>
<p>可以使用顶级的 export 声明来为每个模块都定义一个 .d.ts 文件，但最好还是写在一个大的 .d.ts 文件里。 我们使用与构造一个外部命名空间相似的方法，但是这里使用 module 关键字并且把名字用引号括起来，方便之后 import.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">node.d.ts (simplified excerpt)</div><div class="line">declare module &quot;url&quot; &#123;</div><div class="line">    export interface Url &#123;</div><div class="line">        protocol?: string;</div><div class="line">        hostname?: string;</div><div class="line">        pathname?: string;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;</div><div class="line">&#125;</div><div class="line"></div><div class="line">declare module &quot;path&quot; &#123;</div><div class="line">    export function normalize(p: string): string;</div><div class="line">    export function join(...paths: any[]): string;</div><div class="line">    export let sep: string;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以 <code>/// &lt;reference&gt; node.d.ts</code> 并且使用 <code>import url = require(&quot;url&quot;);</code> 或 <code>import * as URL from &quot;url&quot;</code> 加载模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/// &lt;reference path=&quot;node.d.ts&quot;/&gt;</div><div class="line">import * as URL from &quot;url&quot;;</div><div class="line">let myUrl = URL.parse(&quot;http://www.typescriptlang.org&quot;);</div></pre></td></tr></table></figure>
<h3 id="书写声明文件"><a href="#书写声明文件" class="headerlink" title="书写声明文件"></a>书写声明文件</h3><p>针对模块有三种可用的模块， <code>module.d.ts</code>, <code>module-class.d.ts</code> 和 <code>module-function.d.ts</code>. </p>
<p>如果模块不能被调用或构造，使用module.d.ts文件。</p>
<p><code>module.d.ts</code>里一般这么写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</div><div class="line">// Project: [~THE PROJECT NAME~]</div><div class="line">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</div><div class="line"></div><div class="line">/*~ This is the module template file. You should rename it to index.d.ts</div><div class="line"> *~ and place it in a folder with the same name as the module.</div><div class="line"> *~ For example, if you were writing a file for &quot;super-greeter&quot;, this</div><div class="line"> *~ file should be &apos;super-greeter/index.d.ts&apos;</div><div class="line"> */</div><div class="line"></div><div class="line">/*~ If this module is a UMD module that exposes a global variable &apos;myLib&apos; when</div><div class="line"> *~ loaded outside a module loader environment, declare that global here.</div><div class="line"> *~ Otherwise, delete this declaration.</div><div class="line"> */</div><div class="line">export as namespace myLib;</div><div class="line"></div><div class="line">/*~ If this module has methods, declare them as functions like so.</div><div class="line"> */</div><div class="line">export function myMethod(a: string): string;</div><div class="line">export function myOtherMethod(a: number): number;</div><div class="line"></div><div class="line">/*~ You can declare types that are available via importing the module */</div><div class="line">export interface someType &#123;</div><div class="line">    name: string;</div><div class="line">    length: number;</div><div class="line">    extras?: string[];</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*~ You can declare properties of the module using const, let, or var */</div><div class="line">export const myField: number;</div><div class="line"></div><div class="line">/*~ If there are types, properties, or methods inside dotted names</div><div class="line"> *~ of the module, declare them inside a &apos;namespace&apos;.</div><div class="line"> */</div><div class="line">export namespace subProp &#123;</div><div class="line">    /*~ For example, given this definition, someone could write:</div><div class="line">     *~   import &#123; subProp &#125; from &apos;yourModule&apos;;</div><div class="line">     *~   subProp.foo();</div><div class="line">     *~ or</div><div class="line">     *~   import * as yourMod from &apos;yourModule&apos;;</div><div class="line">     *~   yourMod.subProp.foo();</div><div class="line">     */</div><div class="line">    export function foo(): void;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用 module-class.d.ts 如果模块能够使用new来构造：</div><div class="line">var x = require(&quot;bar&quot;);</div><div class="line">// Note: using &apos;new&apos; operator on the imported variable</div><div class="line">var y = new x(&quot;hello&quot;);</div></pre></td></tr></table></figure>
<p><code>module-class.d.ts</code> 的模板写法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</div><div class="line">// Project: [~THE PROJECT NAME~]</div><div class="line">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</div><div class="line"></div><div class="line">/*~ This is the module template file for function modules.</div><div class="line"> *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.</div><div class="line"> *~ For example, if you were writing a file for &quot;super-greeter&quot;, this</div><div class="line"> *~ file should be &apos;super-greeter/index.d.ts&apos;</div><div class="line"> */</div><div class="line"></div><div class="line">/*~ Note that ES6 modules cannot directly export callable functions.</div><div class="line"> *~ This file should be imported using the CommonJS-style:</div><div class="line"> *~   import x = require(&apos;someLibrary&apos;);</div><div class="line"> *~</div><div class="line"> *~ Refer to the documentation to understand common</div><div class="line"> *~ workarounds for this limitation of ES6 modules.</div><div class="line"> */</div><div class="line"></div><div class="line">/*~ If this module is a UMD module that exposes a global variable &apos;myFuncLib&apos; when</div><div class="line"> *~ loaded outside a module loader environment, declare that global here.</div><div class="line"> *~ Otherwise, delete this declaration.</div><div class="line"> */</div><div class="line">export as namespace myFuncLib;</div><div class="line"></div><div class="line">/*~ This declaration specifies that the function</div><div class="line"> *~ is the exported object from the file</div><div class="line"> */</div><div class="line">export = MyFunction;</div><div class="line"></div><div class="line">/*~ This example shows how to have multiple overloads for your function */</div><div class="line">declare function MyFunction(name: string): MyFunction.NamedReturnType;</div><div class="line">declare function MyFunction(length: number): MyFunction.LengthReturnType;</div><div class="line"></div><div class="line">/*~ If you want to expose types from your module as well, you can</div><div class="line"> *~ place them in this block. Often you will want to describe the</div><div class="line"> *~ shape of the return type of the function; that type should</div><div class="line"> *~ be declared in here, as this example shows.</div><div class="line"> */</div><div class="line">declare namespace MyFunction &#123;</div><div class="line">    export interface LengthReturnType &#123;</div><div class="line">        width: number;</div><div class="line">        height: number;</div><div class="line">    &#125;</div><div class="line">    export interface NamedReturnType &#123;</div><div class="line">        firstName: string;</div><div class="line">        lastName: string;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*~ If the module also has properties, declare them here. For example,</div><div class="line">     *~ this declaration says that this code is legal:</div><div class="line">     *~   import f = require(&apos;myFuncLibrary&apos;);</div><div class="line">     *~   console.log(f.defaultName);</div><div class="line">     */</div><div class="line">    export const defaultName: string;</div><div class="line">    export let defaultLength: number;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用 module-function.d.ts，如果模块能够作为函数调用。</div><div class="line">var x = require(&quot;foo&quot;);</div><div class="line">// Note: calling &apos;x&apos; as a function</div><div class="line">var y = x(42);</div></pre></td></tr></table></figure>
<p><code>module-function.d.ts</code> 的模板写法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</div><div class="line">// Project: [~THE PROJECT NAME~]</div><div class="line">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</div><div class="line"></div><div class="line">/*~ This is the module template file for class modules.</div><div class="line"> *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.</div><div class="line"> *~ For example, if you were writing a file for &quot;super-greeter&quot;, this</div><div class="line"> *~ file should be &apos;super-greeter/index.d.ts&apos;</div><div class="line"> */</div><div class="line"></div><div class="line">/*~ Note that ES6 modules cannot directly export class objects.</div><div class="line"> *~ This file should be imported using the CommonJS-style:</div><div class="line"> *~   import x = require(&apos;someLibrary&apos;);</div><div class="line"> *~</div><div class="line"> *~ Refer to the documentation to understand common</div><div class="line"> *~ workarounds for this limitation of ES6 modules.</div><div class="line"> */</div><div class="line"></div><div class="line">/*~ If this module is a UMD module that exposes a global variable &apos;myClassLib&apos; when</div><div class="line"> *~ loaded outside a module loader environment, declare that global here.</div><div class="line"> *~ Otherwise, delete this declaration.</div><div class="line"> */</div><div class="line">export as namespace myClassLib;</div><div class="line"></div><div class="line">/*~ This declaration specifies that the class constructor function</div><div class="line"> *~ is the exported object from the file</div><div class="line"> */</div><div class="line">export = MyClass;</div><div class="line"></div><div class="line">/*~ Write your module&apos;s methods and properties in this class */</div><div class="line">declare class MyClass &#123;</div><div class="line">    constructor(someParam?: string);</div><div class="line"></div><div class="line">    someProperty: string[];</div><div class="line"></div><div class="line">    myMethod(opts: MyClass.MyClassMethodOptions): number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*~ If you want to expose types from your module as well, you can</div><div class="line"> *~ place them in this block.</div><div class="line"> */</div><div class="line">declare namespace MyClass &#123;</div><div class="line">    export interface MyClassMethodOptions &#123;</div><div class="line">        width?: number;</div><div class="line">        height?: number;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一些规范之前没有注意，在项目需要重新审视。</p>
<blockquote>
<p>不要使用如下类型Number，String，Boolean或Object。 这些类型指的是非原始的装盒对象，它们几乎没在JavaScript代码里正确地使用过。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/* 错误 */</div><div class="line">function reverse(s: String): String;</div><div class="line"></div><div class="line">/* OK */</div><div class="line">function reverse(s: string): string;</div></pre></td></tr></table></figure>
<p>一些例子:</p>
<p><strong>全局变量</strong> :  <code>declare var foo: number;</code></p>
<p><strong>全局变量</strong> : <code>declare function greet(greeting: string): void;</code></p>
<p><strong>带属性的对象</strong> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">全局变量myLib包含一个makeGreeting函数， 还有一个属性numberOfGreetings指示目前为止欢迎数量。</div><div class="line"></div><div class="line">代码</div><div class="line"></div><div class="line">let result = myLib.makeGreeting(&quot;hello, world&quot;);</div><div class="line">console.log(&quot;The computed greeting is:&quot; + result);</div><div class="line"></div><div class="line">let count = myLib.numberOfGreetings;</div><div class="line">声明</div><div class="line"></div><div class="line">使用declare namespace描述用点表示法访问的类型或值。</div><div class="line">declare namespace myLib &#123;</div><div class="line">    function makeGreeting(s: string): string;</div><div class="line">    let numberOfGreetings: number;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>函数重载</strong> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">getWidget函数接收一个数字，返回一个组件，或接收一个字符串并返回一个组件数组。</div><div class="line"></div><div class="line">代码</div><div class="line"></div><div class="line">let x: Widget = getWidget(43);</div><div class="line"></div><div class="line">let arr: Widget[] = getWidget(&quot;all of them&quot;);</div><div class="line">声明</div><div class="line"></div><div class="line">declare function getWidget(n: number): Widget;</div><div class="line">declare function getWidget(s: string): Widget[];</div></pre></td></tr></table></figure>
<p><strong>组织类型</strong> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">greeter对象能够记录到文件或显示一个警告。 你可以为.log(...)提供LogOptions和为.alert(...)提供选项。</div><div class="line">代码</div><div class="line"></div><div class="line">const g = new Greeter(&quot;Hello&quot;);</div><div class="line">g.log(&#123; verbose: true &#125;);</div><div class="line">g.alert(&#123; modal: false, title: &quot;Current Greeting&quot; &#125;);</div><div class="line">声明</div><div class="line"></div><div class="line">使用命名空间组织类型。</div><div class="line">declare namespace GreetingLib &#123;</div><div class="line">    interface LogOptions &#123;</div><div class="line">        verbose?: boolean;</div><div class="line">    &#125;</div><div class="line">    interface AlertOptions &#123;</div><div class="line">        modal: boolean;</div><div class="line">        title?: string;</div><div class="line">        color?: string;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">你也可以在一个声明中创建嵌套的命名空间：</div><div class="line">declare namespace GreetingLib.Options &#123;</div><div class="line">    // Refer to via GreetingLib.Options.Log</div><div class="line">    interface Log &#123;</div><div class="line">        verbose?: boolean;</div><div class="line">    &#125;</div><div class="line">    interface Alert &#123;</div><div class="line">        modal: boolean;</div><div class="line">        title?: string;</div><div class="line">        color?: string;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;资料&quot;&gt;&lt;a href=&quot;#资料&quot; class=&quot;headerlink&quot; title=&quot;资料&quot;&gt;&lt;/a&gt;资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/jsx.html&quot; rel=&quot;ex
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发标准" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E6%A0%87%E5%87%86/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="代码标准" scheme="http://wiki.haoqiao.me/tags/%E4%BB%A3%E7%A0%81%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>Airbnb React 代码风格标准</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E6%A0%87%E5%87%86/Airbnb%20React%20%E6%A0%87%E5%87%86/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/开发标准/Airbnb React 标准/</id>
    <published>2017-09-04T03:23:22.000Z</published>
    <updated>2017-09-04T03:26:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Airbnb-React-JSX-编码规范"><a href="#Airbnb-React-JSX-编码规范" class="headerlink" title="Airbnb React/JSX 编码规范"></a>Airbnb React/JSX 编码规范</h1><p><em>算是最合理的React/JSX编码规范之一了</em></p>
<h2 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h2><ol>
<li><a href="#basic-rules-基本规范">基本规范</a></li>
<li><a href="#创建模块">Class vs React.createClass vs stateless</a></li>
<li><a href="#mixins">Mixins</a></li>
<li><a href="#naming-命名">命名</a></li>
<li><a href="#declaration-声明模块">声明模块</a></li>
<li><a href="#alignment-代码对齐">代码对齐</a></li>
<li><a href="#quotes-单引号还是双引号">单引号还是双引号</a></li>
<li><a href="#spacing-空格">空格</a></li>
<li><a href="#props-属性">属性</a></li>
<li><a href="#refs">Refs引用</a></li>
<li><a href="#parentheses-括号">括号</a></li>
<li><a href="#tags-标签">标签</a></li>
<li><a href="#methods-函数">函数/方法</a></li>
<li><a href="#ordering-react-模块生命周期">模块生命周期</a></li>
<li><a href="#ismounted">isMounted</a></li>
</ol>
<h2 id="Basic-Rules-基本规范"><a href="#Basic-Rules-基本规范" class="headerlink" title="Basic Rules 基本规范"></a>Basic Rules 基本规范</h2><ul>
<li>每个文件只写一个模块.<ul>
<li>但是多个<a href="https://facebook.github.io/react/docs/reusable-components.html#stateless-functions" rel="external nofollow noopener noreferrer" target="_blank">无状态模块</a>可以放在单个文件中. eslint: <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/no-multi-comp.md#ignorestateless" rel="external nofollow noopener noreferrer" target="_blank"><code>react/no-multi-comp</code></a>.</li>
</ul>
</li>
<li>推荐使用JSX语法.</li>
<li>不要使用 <code>React.createElement</code>，除非从一个非JSX的文件中初始化你的app.</li>
</ul>
<h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><p>   Class vs React.createClass vs stateless  </p>
<ul>
<li><p>如果你的模块有内部状态或者是<code>refs</code>, 推荐使用 <code>class extends React.Component</code> 而不是 <code>React.createClass</code>.<br>eslint: <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/prefer-es6-class.md" rel="external nofollow noopener noreferrer" target="_blank"><code>react/prefer-es6-class</code></a> <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/prefer-stateless-function.md" rel="external nofollow noopener noreferrer" target="_blank"><code>react/prefer-stateless-function</code></a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> Listing = React.createClass(&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.hello&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listing</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.hello&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你的模块没有状态或是没有引用<code>refs</code>， 推荐使用普通函数（非箭头函数）而不是类:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listing</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.hello&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad (relying on function name inference is discouraged)</span></div><div class="line"><span class="keyword">const</span> Listing = <span class="function">(<span class="params">&#123; hello &#125;</span>) =&gt;</span> (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;hello&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Listing</span>(<span class="params">&#123; hello &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;hello&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h2><ul>
<li><p><a href="https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html" rel="external nofollow noopener noreferrer" target="_blank">不要使用 mixins</a>.</p>
<blockquote>
<p>为什么? Mixins 会增加隐式的依赖，导致命名冲突，并且会以雪球式增加复杂度。在大多数情况下Mixins可以被更好的方法替代，如：组件化，高阶组件，工具模块等。</p>
</blockquote>
</li>
</ul>
<h2 id="Naming-命名"><a href="#Naming-命名" class="headerlink" title="Naming 命名"></a>Naming 命名</h2><ul>
<li><strong>扩展名</strong>: React模块使用 <code>.jsx</code> 扩展名.</li>
<li><strong>文件名</strong>: 文件名使用帕斯卡命名. 如, <code>ReservationCard.jsx</code>.</li>
<li><p><strong>引用命名</strong>: React模块名使用帕斯卡命名，实例使用骆驼式命名. eslint: <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-pascal-case.md" rel="external nofollow noopener noreferrer" target="_blank"><code>react/jsx-pascal-case</code></a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">import</span> reservationCard <span class="keyword">from</span> <span class="string">'./ReservationCard'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">import</span> ReservationCard <span class="keyword">from</span> <span class="string">'./ReservationCard'</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> ReservationItem = <span class="xml"><span class="tag">&lt;<span class="name">ReservationCard</span> /&gt;</span>;</span></div><div class="line"></div><div class="line">// good</div><div class="line">const reservationItem = <span class="tag">&lt;<span class="name">ReservationCard</span> /&gt;</span>;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>模块命名</strong>: 模块使用当前文件名一样的名称. 比如 <code>ReservationCard.jsx</code> 应该包含名为 <code>ReservationCard</code>的模块. 但是，如果整个文件夹是一个模块，使用 <code>index.js</code>作为入口文件，然后直接使用 <code>index.js</code> 或者文件夹名作为模块的名称:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">'./Footer/Footer'</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">'./Footer/index'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">'./Footer'</span>;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>高阶模块命名</strong>: 对于生成一个新的模块，其中的模块名 <code>displayName</code> 应该为高阶模块名和传入模块名的组合. 例如, 高阶模块 <code>withFoo()</code>, 当传入一个 <code>Bar</code> 模块的时候， 生成的模块名 <code>displayName</code> 应该为 <code>withFoo(Bar)</code>.</p>
<blockquote>
<p>为什么？一个模块的 <code>displayName</code> 可能会在开发者工具或者错误信息中使用到，因此有一个能清楚的表达这层关系的值能帮助我们更好的理解模块发生了什么，更好的Debug.</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">withFoo</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">WithFoo</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &lt;WrappedComponent &#123;...props&#125; foo /&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">export default function withFoo(WrappedComponent) &#123;</div><div class="line">  function WithFoo(props) &#123;</div><div class="line">    return &lt;WrappedComponent &#123;...props&#125; foo /&gt;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  const wrappedComponentName = WrappedComponent.displayName</div><div class="line">    || WrappedComponent.name</div><div class="line">    || 'Component';</div><div class="line"></div><div class="line">  WithFoo.displayName = `withFoo($&#123;wrappedComponentName&#125;)`;</div><div class="line">  return WithFoo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>属性命名</strong>: 避免使用DOM相关的属性来用作其他的用途。</p>
<blockquote>
<p>为什么？对于<code>style</code> 和 <code>className</code>这样的属性名，我们都会默认它们代表一些特殊的含义，如元素的样式，CSS class的名称。在你的应用中使用这些属性来表示其他的含义会使你的代码更难阅读，更难维护，并且可能会引起bug。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">&lt;MyComponent style=<span class="string">"fancy"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;MyComponent variant=<span class="string">"fancy"</span> /&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Declaration-声明模块"><a href="#Declaration-声明模块" class="headerlink" title="Declaration 声明模块"></a>Declaration 声明模块</h2><ul>
<li><p>不要使用 <code>displayName</code> 来命名React模块，而是使用引用来命名模块， 如 class 名称.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</div><div class="line">  <span class="attr">displayName</span>: <span class="string">'ReservationCard'</span>,</div><div class="line">  <span class="comment">// stuff goes here</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationCard</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Alignment-代码对齐"><a href="#Alignment-代码对齐" class="headerlink" title="Alignment 代码对齐"></a>Alignment 代码对齐</h2><ul>
<li><p>遵循以下的JSX语法缩进/格式. eslint: <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-closing-bracket-location.md" rel="external nofollow noopener noreferrer" target="_blank"><code>react/jsx-closing-bracket-location</code></a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">&lt;Foo superLongParam=<span class="string">"bar"</span></div><div class="line">     anotherSuperLongParam=<span class="string">"baz"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">// good, 有多行属性的话, 新建一行关闭标签</span></div><div class="line">&lt;Foo</div><div class="line">  superLongParam=<span class="string">"bar"</span></div><div class="line">  anotherSuperLongParam=<span class="string">"baz"</span></div><div class="line">/&gt;</div><div class="line"></div><div class="line"><span class="comment">// 若能在一行中显示, 直接写成一行</span></div><div class="line">&lt;Foo bar=<span class="string">"bar"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">// 子元素按照常规方式缩进</span></div><div class="line">&lt;Foo</div><div class="line">  superLongParam=<span class="string">"bar"</span></div><div class="line">  anotherSuperLongParam=<span class="string">"baz"</span></div><div class="line">&gt;</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Quux</span> /&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">Foo</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Quotes-单引号还是双引号"><a href="#Quotes-单引号还是双引号" class="headerlink" title="Quotes 单引号还是双引号"></a>Quotes 单引号还是双引号</h2><ul>
<li><p>对于JSX属性值总是使用双引号(<code>&quot;</code>), 其他均使用单引号(<code>&#39;</code>). eslint: <a href="http://eslint.org/docs/rules/jsx-quotes" rel="external nofollow noopener noreferrer" target="_blank"><code>jsx-quotes</code></a></p>
<blockquote>
<p>为什么? HTML属性也是用双引号, 因此JSX的属性也遵循此约定.</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">&lt;Foo bar=<span class="string">'bar'</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;Foo bar=<span class="string">"bar"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line">&lt;Foo style=&#123;&#123; <span class="attr">left</span>: <span class="string">"20px"</span> &#125;&#125; /&gt;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;Foo style=&#123;&#123; <span class="attr">left</span>: <span class="string">'20px'</span> &#125;&#125; /&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Spacing-空格"><a href="#Spacing-空格" class="headerlink" title="Spacing 空格"></a>Spacing 空格</h2><ul>
<li><p>总是在自动关闭的标签前加一个空格，正常情况下也不需要换行. eslint: <a href="http://eslint.org/docs/rules/no-multi-spaces" rel="external nofollow noopener noreferrer" target="_blank"><code>no-multi-spaces</code></a>, <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-tag-spacing.md" rel="external nofollow noopener noreferrer" target="_blank"><code>react/jsx-tag-spacing</code></a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">&lt;Foo/&gt;</div><div class="line"></div><div class="line"><span class="comment">// very bad</span></div><div class="line">&lt;Foo                 /&gt;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line">&lt;Foo</div><div class="line"> /&gt;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;Foo /&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>不要在JSX <code>{}</code> 引用括号里两边加空格. eslint: <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-curly-spacing.md" rel="external nofollow noopener noreferrer" target="_blank"><code>react/jsx-curly-spacing</code></a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">&lt;Foo bar=&#123; baz &#125; /&gt;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;Foo bar=&#123;baz&#125; /&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Props-属性"><a href="#Props-属性" class="headerlink" title="Props 属性"></a>Props 属性</h2><ul>
<li><p>JSX属性名使用骆驼式风格<code>camelCase</code>.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">&lt;Foo</div><div class="line">  UserName=<span class="string">"hello"</span></div><div class="line">  phone_number=&#123;<span class="number">12345678</span>&#125;</div><div class="line">/&gt;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;Foo</div><div class="line">  userName=<span class="string">"hello"</span></div><div class="line">  phoneNumber=&#123;<span class="number">12345678</span>&#125;</div><div class="line">/&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>如果属性值为 <code>true</code>, 可以直接省略. eslint: <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-boolean-value.md" rel="external nofollow noopener noreferrer" target="_blank"><code>react/jsx-boolean-value</code></a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">&lt;Foo</div><div class="line">  hidden=&#123;<span class="literal">true</span>&#125;</div><div class="line">/&gt;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;Foo</div><div class="line">  hidden</div><div class="line">/&gt;</div></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;img&gt;</code> 标签总是添加 <code>alt</code> 属性. 如果图片以presentation(感觉是以类似PPT方式显示?)方式显示，<code>alt</code> 可为空, 或者<code>&lt;img&gt;</code> 要包含<code>role=&quot;presentation&quot;</code>. eslint: <a href="https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/alt-text.md" rel="external nofollow noopener noreferrer" target="_blank"><code>jsx-a11y/alt-text</code></a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">&lt;img src=<span class="string">"hello.jpg"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;img src=<span class="string">"hello.jpg"</span> alt=<span class="string">"Me waving hello"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;img src=<span class="string">"hello.jpg"</span> alt=<span class="string">""</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;img src=<span class="string">"hello.jpg"</span> role=<span class="string">"presentation"</span> /&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>不要在 <code>alt</code> 值里使用如 “image”, “photo”, or “picture”包括图片含义这样的词， 中文也一样. eslint: <a href="https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/img-redundant-alt.md" rel="external nofollow noopener noreferrer" target="_blank"><code>jsx-a11y/img-redundant-alt</code></a></p>
<blockquote>
<p>为什么? 屏幕助读器已经把 <code>img</code> 标签标注为图片了, 所以没有必要再在 <code>alt</code> 里说明了.</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">&lt;img src=<span class="string">"hello.jpg"</span> alt=<span class="string">"Picture of me waving hello"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;img src=<span class="string">"hello.jpg"</span> alt=<span class="string">"Me waving hello"</span> /&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>使用有效正确的 aria <code>role</code>属性值 <a href="https://www.w3.org/TR/wai-aria/roles#role_definitions" rel="external nofollow noopener noreferrer" target="_blank">ARIA roles</a>. eslint: <a href="https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/aria-role.md" rel="external nofollow noopener noreferrer" target="_blank"><code>jsx-a11y/aria-role</code></a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad - not an ARIA role</span></div><div class="line">&lt;div role=<span class="string">"datepicker"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">// bad - abstract ARIA role</span></div><div class="line">&lt;div role=<span class="string">"range"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;div role=<span class="string">"button"</span> /&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>不要在标签上使用 <code>accessKey</code> 属性. eslint: <a href="https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-access-key.md" rel="external nofollow noopener noreferrer" target="_blank"><code>jsx-a11y/no-access-key</code></a></p>
<blockquote>
<p>为什么? 屏幕助读器在键盘快捷键与键盘命令时造成的不统一性会导致阅读性更加复杂.</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">&lt;div accessKey=<span class="string">"h"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;div /&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>避免使用数组的index来作为属性<code>key</code>的值，推荐使用唯一ID. (<a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318" rel="external nofollow noopener noreferrer" target="_blank">为什么?</a>)</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">&#123;todos.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span></div><div class="line">  &lt;Todo</div><div class="line">    &#123;...todo&#125;</div><div class="line">    key=&#123;index&#125;</div><div class="line">  /&gt;</div><div class="line">)&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&#123;todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Todo</span></span></span></div><div class="line">    &#123;<span class="attr">...todo</span>&#125;</div><div class="line">    <span class="attr">key</span>=<span class="string">&#123;todo.id&#125;</span></div><div class="line">  /&gt;</div><div class="line">))&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对于所有非必须的属性，总是手动去定义<code>defaultProps</code>属性.</p>
<blockquote>
<p>为什么? propTypes 可以作为模块的文档说明, 并且声明 defaultProps 的话意味着阅读代码的人不需要去假设一些默认值。更重要的是, 显示的声明默认属性可以让你的模块跳过属性类型的检查.</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SFC</span>(<span class="params">&#123; foo, bar, children &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;foo&#125;&#123;bar&#125;&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line">SFC.propTypes = &#123;</div><div class="line">  <span class="attr">foo</span>: PropTypes.number.isRequired,</div><div class="line">  <span class="attr">bar</span>: PropTypes.string,</div><div class="line">  <span class="attr">children</span>: PropTypes.node,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SFC</span>(<span class="params">&#123; foo, bar, children &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;foo&#125;&#123;bar&#125;&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line">SFC.propTypes = &#123;</div><div class="line">  <span class="attr">foo</span>: PropTypes.number.isRequired,</div><div class="line">  <span class="attr">bar</span>: PropTypes.string,</div><div class="line">  <span class="attr">children</span>: PropTypes.node,</div><div class="line">&#125;;</div><div class="line">SFC.defaultProps = &#123;</div><div class="line">  <span class="attr">bar</span>: <span class="string">''</span>,</div><div class="line">  <span class="attr">children</span>: <span class="literal">null</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><ul>
<li><p>总是在Refs里使用回调函数. eslint: <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/no-string-refs.md" rel="external nofollow noopener noreferrer" target="_blank"><code>react/no-string-refs</code></a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">&lt;Foo</div><div class="line">  ref=<span class="string">"myRef"</span></div><div class="line">/&gt;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;Foo</div><div class="line">  ref=&#123;(ref) =&gt; &#123; <span class="keyword">this</span>.myRef = ref; &#125;&#125;</div><div class="line">/&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Parentheses-括号"><a href="#Parentheses-括号" class="headerlink" title="Parentheses 括号"></a>Parentheses 括号</h2><ul>
<li><p>将多行的JSX标签写在 <code>()</code>里. eslint: <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-wrap-multilines.md" rel="external nofollow noopener noreferrer" target="_blank"><code>react/jsx-wrap-multilines</code></a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">render() &#123;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">className</span>=<span class="string">"long body"</span> <span class="attr">foo</span>=<span class="string">"bar"</span>&gt;</span></span></div><div class="line">           <span class="tag">&lt;<span class="name">MyChild</span> /&gt;</span></div><div class="line">         <span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">render() &#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">className</span>=<span class="string">"long body"</span> <span class="attr">foo</span>=<span class="string">"bar"</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">MyChild</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good, 单行可以不需要</span></div><div class="line">render() &#123;</div><div class="line">  <span class="keyword">const</span> body = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span>&#123;body&#125;<span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Tags-标签"><a href="#Tags-标签" class="headerlink" title="Tags 标签"></a>Tags 标签</h2><ul>
<li><p>对于没有子元素的标签来说总是自己关闭标签. eslint: <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/self-closing-comp.md" rel="external nofollow noopener noreferrer" target="_blank"><code>react/self-closing-comp</code></a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">&lt;Foo className=<span class="string">"stuff"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Foo</span>&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;Foo className=<span class="string">"stuff"</span> /&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>如果模块有多行的属性， 关闭标签时新建一行. eslint: <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-closing-bracket-location.md" rel="external nofollow noopener noreferrer" target="_blank"><code>react/jsx-closing-bracket-location</code></a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">&lt;Foo</div><div class="line">  bar=<span class="string">"bar"</span></div><div class="line">  baz=<span class="string">"baz"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">&lt;Foo</div><div class="line">  bar=<span class="string">"bar"</span></div><div class="line">  baz=<span class="string">"baz"</span></div><div class="line">/&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Methods-函数"><a href="#Methods-函数" class="headerlink" title="Methods 函数"></a>Methods 函数</h2><ul>
<li><p>使用箭头函数来获取本地变量.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ItemList</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></div><div class="line">      &#123;props.items.map((item, index) =&gt; (</div><div class="line">        <span class="tag">&lt;<span class="name">Item</span></span></div><div class="line">          <span class="attr">key</span>=<span class="string">&#123;item.key&#125;</span></div><div class="line">          <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt; doSomethingWith(item.name, index)&#125;</div><div class="line">        /&gt;</div><div class="line">      ))&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>当在 <code>render()</code> 里使用事件处理方法时，提前在构造函数里把 <code>this</code> 绑定上去. eslint: <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md" rel="external nofollow noopener noreferrer" target="_blank"><code>react/jsx-no-bind</code></a></p>
<blockquote>
<p>为什么? 在每次 <code>render</code> 过程中， 再调用 <code>bind</code> 都会新建一个新的函数，浪费资源.</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  onClickDiv() &#123;</div><div class="line">    <span class="comment">// do stuff</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> &lt;div onClick=&#123;this.onClickDiv.bind(this)&#125; /&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">class extends React.Component &#123;</div><div class="line">  constructor(props) &#123;</div><div class="line">    super(props);</div><div class="line"></div><div class="line">    this.onClickDiv = this.onClickDiv.bind(this);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  onClickDiv() &#123;</div><div class="line">    // do stuff</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return &lt;div onClick=&#123;this.onClickDiv&#125; /&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在React模块中，不要给所谓的私有函数添加 <code>_</code> 前缀，本质上它并不是私有的.</p>
<blockquote>
<p>为什么？<code>_</code> 下划线前缀在某些语言中通常被用来表示私有变量或者函数。但是不像其他的一些语言，在JS中没有原生支持所谓的私有变量，所有的变量函数都是共有的。尽管你的意图是使它私有化，在之前加上下划线并不会使这些变量私有化，并且所有的属性（包括有下划线前缀及没有前缀的）都应该被视为是共有的。了解更多详情请查看Issue <a href="https://github.com/airbnb/javascript/issues/1024" rel="external nofollow noopener noreferrer" target="_blank">#1024</a>, 和 <a href="https://github.com/airbnb/javascript/issues/490" rel="external nofollow noopener noreferrer" target="_blank">#490</a> 。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">React.createClass(&#123;</div><div class="line">  _onClickSubmit() &#123;</div><div class="line">    <span class="comment">// do stuff</span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">// other stuff</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  onClickSubmit() &#123;</div><div class="line">    <span class="comment">// do stuff</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// other stuff</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在 <code>render</code> 方法中总是确保 <code>return</code> 返回值. eslint: <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/require-render-return.md" rel="external nofollow noopener noreferrer" target="_blank"><code>react/require-render-return</code></a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">render() &#123;</div><div class="line">  (<span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>);</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">render() &#123;</div><div class="line">  return (<span class="tag">&lt;<span class="name">div</span> /&gt;</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Ordering-React-模块生命周期"><a href="#Ordering-React-模块生命周期" class="headerlink" title="Ordering React 模块生命周期"></a>Ordering React 模块生命周期</h2><ul>
<li><code>class extends React.Component</code> 的生命周期函数:</li>
</ul>
<ol>
<li>可选的 <code>static</code> 方法</li>
<li><code>constructor</code> 构造函数</li>
<li><code>getChildContext</code> 获取子元素内容</li>
<li><code>componentWillMount</code> 模块渲染前</li>
<li><code>componentDidMount</code> 模块渲染后</li>
<li><code>componentWillReceiveProps</code> 模块将接受新的数据</li>
<li><code>shouldComponentUpdate</code> 判断模块需不需要重新渲染</li>
<li><code>componentWillUpdate</code> 上面的方法返回 <code>true</code>， 模块将重新渲染</li>
<li><code>componentDidUpdate</code> 模块渲染结束</li>
<li><code>componentWillUnmount</code> 模块将从DOM中清除, 做一些清理任务</li>
<li><em>点击回调或者事件处理器</em> 如 <code>onClickSubmit()</code> 或 <code>onChangeDescription()</code></li>
<li><em><code>render</code> 里的 getter 方法</em> 如 <code>getSelectReason()</code> 或 <code>getFooterContent()</code></li>
<li><em>可选的 render 方法</em> 如 <code>renderNavigation()</code> 或 <code>renderProfilePicture()</code></li>
<li><code>render</code> render() 方法</li>
</ol>
<ul>
<li><p>如何定义 <code>propTypes</code>, <code>defaultProps</code>, <code>contextTypes</code>, 等等其他属性…</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> propTypes = &#123;</div><div class="line">  <span class="attr">id</span>: PropTypes.number.isRequired,</div><div class="line">  <span class="attr">url</span>: PropTypes.string.isRequired,</div><div class="line">  <span class="attr">text</span>: PropTypes.string,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> defaultProps = &#123;</div><div class="line">  <span class="attr">text</span>: <span class="string">'Hello World'</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> methodsAreOk() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;this.props.url&#125;</span> <span class="attr">data-id</span>=<span class="string">&#123;this.props.id&#125;</span>&gt;</span>&#123;this.props.text&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Link.propTypes = propTypes;</div><div class="line">Link.defaultProps = defaultProps;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Link;</div></pre></td></tr></table></figure>
</li>
<li><p><code>React.createClass</code> 的生命周期函数，与使用class稍有不同: eslint: <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/sort-comp.md" rel="external nofollow noopener noreferrer" target="_blank"><code>react/sort-comp</code></a></p>
</li>
</ul>
<ol>
<li><code>displayName</code> 设定模块名称</li>
<li><code>propTypes</code> 设置属性的类型</li>
<li><code>contextTypes</code> 设置上下文类型</li>
<li><code>childContextTypes</code> 设置子元素上下文类型</li>
<li><code>mixins</code> 添加一些mixins</li>
<li><code>statics</code></li>
<li><code>defaultProps</code> 设置默认的属性值</li>
<li><code>getDefaultProps</code> 获取默认属性值</li>
<li><code>getInitialState</code> 或者初始状态</li>
<li><code>getChildContext</code></li>
<li><code>componentWillMount</code></li>
<li><code>componentDidMount</code></li>
<li><code>componentWillReceiveProps</code></li>
<li><code>shouldComponentUpdate</code></li>
<li><code>componentWillUpdate</code></li>
<li><code>componentDidUpdate</code></li>
<li><code>componentWillUnmount</code></li>
<li><em>clickHandlers or eventHandlers</em> like <code>onClickSubmit()</code> or <code>onChangeDescription()</code></li>
<li><em>getter methods for <code>render</code></em> like <code>getSelectReason()</code> or <code>getFooterContent()</code></li>
<li><em>Optional render methods</em> like <code>renderNavigation()</code> or <code>renderProfilePicture()</code></li>
<li><code>render</code></li>
</ol>
<h2 id="isMounted"><a href="#isMounted" class="headerlink" title="isMounted"></a>isMounted</h2><ul>
<li><p>不要再使用 <code>isMounted</code>. eslint: <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/no-is-mounted.md" rel="external nofollow noopener noreferrer" target="_blank"><code>react/no-is-mounted</code></a></p>
<blockquote>
<p>为什么? <a href="https://facebook.github.io/react/blog/2015/12/16/ismounted-antipattern.html" rel="external nofollow noopener noreferrer" target="_blank"><code>isMounted</code> 反人类设计模式:()</a>, 在 ES6 classes 中无法使用， 官方将在未来的版本里删除此方法.</p>
</blockquote>
</li>
</ul>
<p><strong><a href="#内容目录">⬆ 回到顶部</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Airbnb-React-JSX-编码规范&quot;&gt;&lt;a href=&quot;#Airbnb-React-JSX-编码规范&quot; class=&quot;headerlink&quot; title=&quot;Airbnb React/JSX 编码规范&quot;&gt;&lt;/a&gt;Airbnb React/JSX 编码规范&lt;/
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发标准" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E6%A0%87%E5%87%86/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="代码风格标准" scheme="http://wiki.haoqiao.me/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>Airbnb ES6 代码风格标准</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E6%A0%87%E5%87%86/Airbnb%20Es6%20%E6%A0%87%E5%87%86/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/开发标准/Airbnb Es6 标准/</id>
    <published>2017-09-04T03:23:22.000Z</published>
    <updated>2017-09-04T03:23:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#types">类型</a></li>
<li><a href="#references">引用</a></li>
<li><a href="#objects">对象</a></li>
<li><a href="#arrays">数组</a></li>
<li><a href="#destructuring">解构</a></li>
<li><a href="#strings">字符串</a></li>
<li><a href="#functions">函数</a></li>
<li><a href="#arrow-functions">箭头函数</a></li>
<li><a href="#constructors">构造函数</a></li>
<li><a href="#modules">模块</a></li>
<li><a href="#iterators-and-generators">迭代器和生成器</a></li>
<li><a href="#properties">属性</a></li>
<li><a href="#variables">变量</a></li>
<li><a href="#hoisting">提升</a></li>
<li><a href="#comparison-operators--equality">比较运算符和等号</a></li>
<li><a href="#blocks">代码块</a></li>
<li><a href="#comments">注释</a></li>
<li><a href="#whitespace">空白</a></li>
<li><a href="#commas">逗号</a></li>
<li><a href="#semicolons">分号</a></li>
<li><a href="#type-casting--coercion">类型转换</a></li>
<li><a href="#naming-conventions">命名规则</a></li>
<li><a href="#accessors">存取器</a></li>
<li><a href="#events">事件</a></li>
<li><a href="#jquery">jQuery</a></li>
<li><a href="#ecmascript-5-compatibility">ECMAScript 5 兼容性</a></li>
<li><a href="#ecmascript-6-styles">ECMAScript 6 编码规范</a></li>
<li><a href="#testing">测试</a></li>
<li><a href="#performance">性能</a></li>
<li><a href="#resources">相关资源</a></li>
<li><a href="#in-the-wild">使用情况</a></li>
<li><a href="#translation">其他翻译</a></li>
<li><a href="#the-javascript-style-guide-guide">JavaScript 编码规范说明</a></li>
<li><a href="#chat-with-us-about-javascript">讨论 JavaScript</a></li>
<li><a href="#contributors">贡献者</a></li>
<li><a href="#license">许可协议</a></li>
</ol>
<p><a name="types"></a></p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul>
<li><p><a href="#1.1">1.1</a> <a name="1.1"></a> <strong>基本类型</strong>: 直接存取基本类型。</p>
<ul>
<li><code>字符串</code></li>
<li><code>数值</code></li>
<li><code>布尔类型</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> bar = foo;</div><div class="line"></div><div class="line">bar = <span class="number">9</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo, bar); <span class="comment">// =&gt; 1, 9</span></div></pre></td></tr></table></figure>
</li>
<li><p><a href="#1.2">1.2</a> <a name="1.2"></a> <strong>复杂类型</strong>: 通过引用的方式存取复杂类型。</p>
<ul>
<li><code>对象</code></li>
<li><code>数组</code></li>
<li><code>函数</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="keyword">const</span> bar = foo;</div><div class="line"></div><div class="line">bar[<span class="number">0</span>] = <span class="number">9</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo[<span class="number">0</span>], bar[<span class="number">0</span>]); <span class="comment">// =&gt; 9, 9</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="references"></a></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><p><a href="#2.1">2.1</a> <a name="2.1"></a> 对所有的引用使用 <code>const</code> ；不要使用 <code>var</code>。</p>
<blockquote>
<p>为什么？这能确保你无法对引用重新赋值，也不会导致出现 bug 或难以理解。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#2.2">2.2</a> <a name="2.2"></a> 如果你一定需要可变动的引用，使用 <code>let</code> 代替 <code>var</code>。</p>
<blockquote>
<p>为什么？因为  <code>let</code> 是块级作用域，而 <code>var</code> 是函数作用域。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  count += <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good, use the let.</span></div><div class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  count += <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#2.3">2.3</a> <a name="2.3"></a> 注意 <code>let</code> 和 <code>const</code> 都是块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// const 和 let 只存在于它们被定义的区块内。</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</div><div class="line">  <span class="keyword">const</span> b = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="objects"></a></p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul>
<li><p><a href="#3.1">3.1</a> <a name="3.1"></a> 使用字面值创建对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> item = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> item = &#123;&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#3.2">3.2</a> <a name="3.2"></a> 如果你的代码在浏览器环境下执行，别使用 <a href="http://es5.github.io/#x7.6.1" rel="external nofollow noopener noreferrer" target="_blank">保留字</a> 作为键值。这样的话在 IE8 不会运行。 <a href="https://github.com/airbnb/javascript/issues/61" rel="external nofollow noopener noreferrer" target="_blank">更多信息</a>。 但在 ES6 模块和服务器端中使用没有问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> superman = &#123;</div><div class="line">  <span class="attr">default</span>: &#123; <span class="attr">clark</span>: <span class="string">'kent'</span> &#125;,</div><div class="line">  <span class="attr">private</span>: <span class="literal">true</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> superman = &#123;</div><div class="line">  <span class="attr">defaults</span>: &#123; <span class="attr">clark</span>: <span class="string">'kent'</span> &#125;,</div><div class="line">  <span class="attr">hidden</span>: <span class="literal">true</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#3.3">3.3</a> <a name="3.3"></a> 使用同义词替换需要使用的保留字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> superman = &#123;</div><div class="line">  <span class="attr">class</span>: <span class="string">'alien'</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> superman = &#123;</div><div class="line">  <span class="attr">klass</span>: <span class="string">'alien'</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> superman = &#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">'alien'</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><a name="es6-computed-properties"></a></p>
</li>
<li><p><a href="#3.4">3.4</a> <a name="3.4"></a> 创建有动态属性名的对象时，使用可被计算的属性名称。</p>
<blockquote>
<p>为什么？因为这样可以让你在一个地方定义所有的对象属性。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKey</span>(<span class="params">k</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">`a key named <span class="subst">$&#123;k&#125;</span>`</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">id</span>: <span class="number">5</span>,</div><div class="line">  <span class="attr">name</span>: <span class="string">'San Francisco'</span>,</div><div class="line">&#125;;</div><div class="line">obj[getKey(<span class="string">'enabled'</span>)] = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">id</span>: <span class="number">5</span>,</div><div class="line">  <span class="attr">name</span>: <span class="string">'San Francisco'</span>,</div><div class="line">  [getKey(<span class="string">'enabled'</span>)]: <span class="literal">true</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><a name="es6-object-shorthand"></a></p>
</li>
<li><p><a href="#3.5">3.5</a> <a name="3.5"></a> 使用对象方法的简写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> atom = &#123;</div><div class="line">  <span class="attr">value</span>: <span class="number">1</span>,</div><div class="line"></div><div class="line">  <span class="attr">addValue</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> atom.value + value;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> atom = &#123;</div><div class="line">  <span class="attr">value</span>: <span class="number">1</span>,</div><div class="line"></div><div class="line">  addValue(value) &#123;</div><div class="line">    <span class="keyword">return</span> atom.value + value;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><a name="es6-object-concise"></a></p>
</li>
<li><p><a href="#3.6">3.6</a> <a name="3.6"></a> 使用对象属性值的简写。</p>
<blockquote>
<p>为什么？因为这样更短更有描述性。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> lukeSkywalker = <span class="string">'Luke Skywalker'</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">lukeSkywalker</span>: lukeSkywalker,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  lukeSkywalker,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#3.7">3.7</a> <a name="3.7"></a> 在对象属性声明前把简写的属性分组。</p>
<blockquote>
<p>为什么？因为这样能清楚地看出哪些属性使用了简写。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> anakinSkywalker = <span class="string">'Anakin Skywalker'</span>;</div><div class="line"><span class="keyword">const</span> lukeSkywalker = <span class="string">'Luke Skywalker'</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">episodeOne</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">twoJedisWalkIntoACantina</span>: <span class="number">2</span>,</div><div class="line">  lukeSkywalker,</div><div class="line">  <span class="attr">episodeThree</span>: <span class="number">3</span>,</div><div class="line">  <span class="attr">mayTheFourth</span>: <span class="number">4</span>,</div><div class="line">  anakinSkywalker,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  lukeSkywalker,</div><div class="line">  anakinSkywalker,</div><div class="line">  <span class="attr">episodeOne</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">twoJedisWalkIntoACantina</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">episodeThree</span>: <span class="number">3</span>,</div><div class="line">  <span class="attr">mayTheFourth</span>: <span class="number">4</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="arrays"></a></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p><a href="#4.1">4.1</a> <a name="4.1"></a> 使用字面值创建数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> items = [];</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#4.2">4.2</a> <a name="4.2"></a> 向数组添加元素时使用 Arrary#push 替代直接赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> someStack = [];</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line">someStack[someStack.length] = <span class="string">'abracadabra'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">someStack.push(<span class="string">'abracadabra'</span>);</div></pre></td></tr></table></figure>
<p><a name="es6-array-spreads"></a></p>
</li>
<li><p><a href="#4.3">4.3</a> <a name="4.3"></a> 使用拓展运算符 <code>...</code> 复制数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> len = items.length;</div><div class="line"><span class="keyword">const</span> itemsCopy = [];</div><div class="line"><span class="keyword">let</span> i;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">  itemsCopy[i] = items[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> itemsCopy = [...items];</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#4.4">4.4</a> <a name="4.4"></a> 使用 Array#from 把一个类数组对象转换成数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.foo'</span>);</div><div class="line"><span class="keyword">const</span> nodes = <span class="built_in">Array</span>.from(foo);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="destructuring"></a></p>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><ul>
<li><p><a href="#5.1">5.1</a> <a name="5.1"></a> 使用解构存取和使用多属性对象。</p>
<blockquote>
<p>为什么？因为解构能减少临时引用属性。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> firstName = user.firstName;</div><div class="line">  <span class="keyword">const</span> lastName = user.lastName;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; firstName, lastName &#125; = obj;</div><div class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// best</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">&#123; firstName, lastName &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#5.2">5.2</a> <a name="5.2"></a> 对数组使用解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> first = arr[<span class="number">0</span>];</div><div class="line"><span class="keyword">const</span> second = arr[<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> [first, second] = arr;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#5.3">5.3</a> <a name="5.3"></a> 需要回传多个值时，使用对象解构，而不是数组解构。</p>
<blockquote>
<p>为什么？增加属性或者改变排序不会改变调用时的位置。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</div><div class="line">  <span class="comment">// then a miracle occurs</span></div><div class="line">  <span class="keyword">return</span> [left, right, top, bottom];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用时需要考虑回调数据的顺序。</span></div><div class="line"><span class="keyword">const</span> [left, __, top] = processInput(input);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</div><div class="line">  <span class="comment">// then a miracle occurs</span></div><div class="line">  <span class="keyword">return</span> &#123; left, right, top, bottom &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用时只选择需要的数据</span></div><div class="line"><span class="keyword">const</span> &#123; left, right &#125; = processInput(input);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="strings"></a></p>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><ul>
<li><p><a href="#6.1">6.1</a> <a name="6.1"></a> 字符串使用单引号 <code>&#39;&#39;</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> name = <span class="string">"Capt. Janeway"</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> name = <span class="string">'Capt. Janeway'</span>;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#6.2">6.2</a> <a name="6.2"></a> 字符串超过 80 个字节应该使用字符串连接号换行。</p>
</li>
<li><p><a href="#6.3">6.3</a> <a name="6.3"></a> 注：过度使用字串连接符号可能会对性能造成影响。<a href="http://jsperf.com/ya-string-concat" rel="external nofollow noopener noreferrer" target="_blank">jsPerf</a> 和 <a href="https://github.com/airbnb/javascript/issues/40" rel="external nofollow noopener noreferrer" target="_blank">讨论</a>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> errorMessage = <span class="string">'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> errorMessage = <span class="string">'This is a super long error that was thrown because \</span></div><div class="line">of Batman. When you stop to think about how Batman had anything to do \</div><div class="line">with this, you would get nowhere \</div><div class="line">fast.';</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> errorMessage = <span class="string">'This is a super long error that was thrown because '</span> +</div><div class="line">  <span class="string">'of Batman. When you stop to think about how Batman had anything to do '</span> +</div><div class="line">  <span class="string">'with this, you would get nowhere fast.'</span>;</div></pre></td></tr></table></figure>
<p><a name="es6-template-literals"></a></p>
</li>
<li><p><a href="#6.4">6.4</a> <a name="6.4"></a> 程序化生成字符串时，使用模板字符串代替字符串连接。</p>
<blockquote>
<p>为什么？模板字符串更为简洁，更具可读性。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'How are you, '</span> + name + <span class="string">'?'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [<span class="string">'How are you, '</span>, name, <span class="string">'?'</span>].join();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">`How are you, <span class="subst">$&#123;name&#125;</span>?`</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="functions"></a></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p><a href="#7.1">7.1</a> <a name="7.1"></a> 使用函数声明代替函数表达式。</p>
<blockquote>
<p>为什么？因为函数声明是可命名的，所以他们在调用栈中更容易被识别。此外，函数声明会把整个函数提升（hoisted），而函数表达式只会把函数的引用变量名提升。这条规则使得<a href="#arrow-functions">箭头函数</a>可以取代函数表达式。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#7.2">7.2</a> <a name="7.2"></a> 函数表达式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 立即调用的函数表达式 (IIFE)</span></div><div class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Welcome to the Internet. Please follow me.'</span>);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#7.3">7.3</a> <a name="7.3"></a> 永远不要在一个非函数代码块（<code>if</code>、<code>while</code> 等）中声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但它们的解析表现不一致。</p>
</li>
<li><p><a href="#7.4">7.4</a> <a name="7.4"></a> <strong>注意:</strong> ECMA-262 把 <code>block</code> 定义为一组语句。函数声明不是语句。<a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf#page=97" rel="external nofollow noopener noreferrer" target="_blank">阅读 ECMA-262 关于这个问题的说明</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">if</span> (currentUser) &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Nope.'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">let</span> test;</div><div class="line"><span class="keyword">if</span> (currentUser) &#123;</div><div class="line">  test = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Yup.'</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#7.5">7.5</a> <a name="7.5"></a> 永远不要把参数命名为 <code>arguments</code>。这将取代原来函数作用域内的 <code>arguments</code> 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">nope</span>(<span class="params">name, options, arguments</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">yup</span>(<span class="params">name, options, args</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a name="es6-rest"></a></p>
</li>
<li><p><a href="#7.6">7.6</a> <a name="7.6"></a> 不要使用 <code>arguments</code>。可以选择 rest 语法 <code>...</code> 替代。</p>
<blockquote>
<p>为什么？使用 <code>...</code> 能明确你要传入的参数。另外 rest 参数是一个真正的数组，而 <code>arguments</code> 是一个类数组。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a name="es6-default-parameters"></a></p>
</li>
<li><p><a href="#7.7">7.7</a> <a name="7.7"></a> 直接给函数的参数指定默认值，不要使用一个变化的函数参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// really bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts</span>) </span>&#123;</div><div class="line">  <span class="comment">// 不！我们不应该改变函数参数。</span></div><div class="line">  <span class="comment">// 更加糟糕: 如果参数 opts 是 false 的话，它就会被设定为一个对象。</span></div><div class="line">  <span class="comment">// 但这样的写法会造成一些 Bugs。</span></div><div class="line">  <span class="comment">//（译注：例如当 opts 被赋值为空字符串，opts 仍然会被下一行代码设定为一个空对象。）</span></div><div class="line">  opts = opts || &#123;&#125;;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// still bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (opts === <span class="keyword">void</span> <span class="number">0</span>) &#123;</div><div class="line">    opts = &#123;&#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#7.8">7.8</a> <a name="7.8"></a> 直接给函数参数赋值时需要避免副作用。</p>
<blockquote>
<p>为什么？因为这样的写法让人感到很困惑。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">a = b++</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);</div><div class="line">&#125;</div><div class="line">count();  <span class="comment">// 1</span></div><div class="line">count();  <span class="comment">// 2</span></div><div class="line">count(<span class="number">3</span>); <span class="comment">// 3</span></div><div class="line">count();  <span class="comment">// 3</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="arrow-functions"></a></p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul>
<li><p><a href="#8.1">8.1</a> <a name="8.1"></a> 当你必须使用函数表达式（或传递一个匿名函数）时，使用箭头函数符号。</p>
<blockquote>
<p>为什么?因为箭头函数创造了新的一个 <code>this</code> 执行环境（译注：参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="external nofollow noopener noreferrer" target="_blank">Arrow functions - JavaScript | MDN</a> 和 <a href="http://toddmotto.com/es6-arrow-functions-syntaxes-and-lexical-scoping/" rel="external nofollow noopener noreferrer" target="_blank">ES6 arrow functions, syntax and lexical scoping</a>），通常情况下都能满足你的需求，而且这样的写法更为简洁。</p>
<p>为什么不？如果你有一个相当复杂的函数，你或许可以把逻辑部分转移到一个函数声明上。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x * x;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> x * x;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#8.2">8.2</a> <a name="8.2"></a> 如果一个函数适合用一行写出并且只有一个参数，那就把花括号、圆括号和 <code>return</code> 都省略掉。如果不是，那就不要省略。</p>
<blockquote>
<p>为什么？语法糖。在链式调用中可读性很高。</p>
<p>为什么不？当你打算回传一个对象的时候。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// good</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">total, n</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> total + n;</div><div class="line">&#125;, <span class="number">0</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="constructors"></a></p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><ul>
<li><p><a href="#9.1">9.1</a> <a name="9.1"></a> 总是使用 <code>class</code>。避免直接操作 <code>prototype</code> 。</p>
<blockquote>
<p>为什么? 因为 <code>class</code> 语法更为简洁更易读。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params">contents = []</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>._queue = [...contents];</div><div class="line">&#125;</div><div class="line">Queue.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">  <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(contents = []) &#123;</div><div class="line">    <span class="keyword">this</span>._queue = [...contents];</div><div class="line">  &#125;</div><div class="line">  pop() &#123;</div><div class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">    <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#9.2">9.2</a> <a name="9.2"></a> 使用 <code>extends</code> 继承。</p>
<blockquote>
<p>为什么？因为 <code>extends</code> 是一个内建的原型继承方法并且不会破坏 <code>instanceof</code>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> inherits = <span class="built_in">require</span>(<span class="string">'inherits'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PeekableQueue</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">  Queue.apply(<span class="keyword">this</span>, contents);</div><div class="line">&#125;</div><div class="line">inherits(PeekableQueue, Queue);</div><div class="line">PeekableQueue.prototype.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekableQueue</span> <span class="keyword">extends</span> <span class="title">Queue</span> </span>&#123;</div><div class="line">  peek() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#9.3">9.3</a> <a name="9.3"></a> 方法可以返回 <code>this</code> 来帮助链式调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">Jedi.prototype.jump = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.jumping = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Jedi.prototype.setHeight = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.height = height;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> luke = <span class="keyword">new</span> Jedi();</div><div class="line">luke.jump(); <span class="comment">// =&gt; true</span></div><div class="line">luke.setHeight(<span class="number">20</span>); <span class="comment">// =&gt; undefined</span></div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jedi</span> </span>&#123;</div><div class="line">  jump() &#123;</div><div class="line">    <span class="keyword">this</span>.jumping = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setHeight(height) &#123;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> luke = <span class="keyword">new</span> Jedi();</div><div class="line"></div><div class="line">luke.jump()</div><div class="line">  .setHeight(<span class="number">20</span>);</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#9.4">9.4</a> <a name="9.4"></a> 可以写一个自定义的 <code>toString()</code> 方法，但要确保它能正常运行并且不会引起副作用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jedi</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</div><div class="line">    <span class="keyword">this</span>.name = options.name || <span class="string">'no name'</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`Jedi - <span class="subst">$&#123;<span class="keyword">this</span>.getName()&#125;</span>`</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="modules"></a></p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul>
<li><p><a href="#10.1">10.1</a> <a name="10.1"></a> 总是使用模组 (<code>import</code>/<code>export</code>) 而不是其他非标准模块系统。你可以编译为你喜欢的模块系统。</p>
<blockquote>
<p>为什么？模块就是未来，让我们开始迈向未来吧。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> AirbnbStyleGuide = <span class="built_in">require</span>(<span class="string">'./AirbnbStyleGuide'</span>);</div><div class="line"><span class="built_in">module</span>.exports = AirbnbStyleGuide.es6;</div><div class="line"></div><div class="line"><span class="comment">// ok</span></div><div class="line"><span class="keyword">import</span> AirbnbStyleGuide <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> AirbnbStyleGuide.es6;</div><div class="line"></div><div class="line"><span class="comment">// best</span></div><div class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#10.2">10.2</a> <a name="10.2"></a> 不要使用通配符 import。</p>
<blockquote>
<p>为什么？这样能确保你只有一个默认 export。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> AirbnbStyleGuide <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">import</span> AirbnbStyleGuide <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#10.3">10.3</a> <a name="10.3"></a>不要从 import 中直接 export。</p>
<blockquote>
<p>为什么？虽然一行代码简洁明了，但让 import 和 export 各司其职让事情能保持一致。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="comment">// filename es6.js</span></div><div class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./airbnbStyleGuide'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="comment">// filename es6.js</span></div><div class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="iterators-and-generators"></a></p>
<h2 id="Iterators-and-Generators"><a href="#Iterators-and-Generators" class="headerlink" title="Iterators and Generators"></a>Iterators and Generators</h2><ul>
<li><p><a href="#11.1">11.1</a> <a name="11.1"></a> 不要使用 iterators。使用高阶函数例如 <code>map()</code> 和 <code>reduce()</code> 替代 <code>for-of</code>。</p>
<blockquote>
<p>为什么？这加强了我们不变的规则。处理纯函数的回调值更易读，这比它带来的副作用更重要。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> numbers) &#123;</div><div class="line">  sum += num;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sum === <span class="number">15</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</div><div class="line">numbers.forEach(<span class="function">(<span class="params">num</span>) =&gt;</span> sum += num);</div><div class="line">sum === <span class="number">15</span>;</div><div class="line"></div><div class="line"><span class="comment">// best (use the functional force)</span></div><div class="line"><span class="keyword">const</span> sum = numbers.reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> total + num, <span class="number">0</span>);</div><div class="line">sum === <span class="number">15</span>;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#11.2">11.2</a> <a name="11.2"></a> 现在还不要使用 generators。</p>
<blockquote>
<p>为什么？因为它们现在还没法很好地编译到 ES5。 (译者注：目前(2016/03) Chrome 和 Node.js 的稳定版本都已支持 generators)</p>
</blockquote>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="properties"></a></p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li><p><a href="#12.1">12.1</a> <a name="12.1"></a> 使用 <code>.</code> 来访问对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> luke = &#123;</div><div class="line">  <span class="attr">jedi</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">28</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> isJedi = luke[<span class="string">'jedi'</span>];</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> isJedi = luke.jedi;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#12.2">12.2</a> <a name="12.2"></a> 当通过变量访问属性时使用中括号 <code>[]</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> luke = &#123;</div><div class="line">  <span class="attr">jedi</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">28</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProp</span>(<span class="params">prop</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> luke[prop];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> isJedi = getProp(<span class="string">'jedi'</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="variables"></a></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p><a href="#13.1">13.1</a> <a name="13.1"></a> 一直使用 <code>const</code> 来声明变量，如果不这样做就会产生全局变量。我们需要避免全局命名空间的污染。<a href="http://www.wikiwand.com/en/Captain_Planet" rel="external nofollow noopener noreferrer" target="_blank">地球队长</a>已经警告过我们了。（译注：全局，global 亦有全球的意思。地球队长的责任是保卫地球环境，所以他警告我们不要造成「全球」污染。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">superPower = <span class="keyword">new</span> SuperPower();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> superPower = <span class="keyword">new</span> SuperPower();</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#13.2">13.2</a> <a name="13.2"></a> 使用 <code>const</code> 声明每一个变量。</p>
<blockquote>
<p>为什么？增加新变量将变的更加容易，而且你永远不用再担心调换错 <code>;</code> 跟 <code>,</code>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> items = getItems(),</div><div class="line">    goSportsTeam = <span class="literal">true</span>,</div><div class="line">    dragonball = <span class="string">'z'</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="comment">// (compare to above, and try to spot the mistake)</span></div><div class="line"><span class="keyword">const</span> items = getItems(),</div><div class="line">    goSportsTeam = <span class="literal">true</span>;</div><div class="line">    dragonball = <span class="string">'z'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> items = getItems();</div><div class="line"><span class="keyword">const</span> goSportsTeam = <span class="literal">true</span>;</div><div class="line"><span class="keyword">const</span> dragonball = <span class="string">'z'</span>;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#13.3">13.3</a> <a name="13.3"></a> 将所有的 <code>const</code> 和 <code>let</code> 分组</p>
<blockquote>
<p>为什么？当你需要把已赋值变量赋值给未赋值变量时非常有用。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">let</span> i, len, dragonball,</div><div class="line">    items = getItems(),</div><div class="line">    goSportsTeam = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">let</span> i;</div><div class="line"><span class="keyword">const</span> items = getItems();</div><div class="line"><span class="keyword">let</span> dragonball;</div><div class="line"><span class="keyword">const</span> goSportsTeam = <span class="literal">true</span>;</div><div class="line"><span class="keyword">let</span> len;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> goSportsTeam = <span class="literal">true</span>;</div><div class="line"><span class="keyword">const</span> items = getItems();</div><div class="line"><span class="keyword">let</span> dragonball;</div><div class="line"><span class="keyword">let</span> i;</div><div class="line"><span class="keyword">let</span> length;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#13.4">13.4</a> <a name="13.4"></a> 在你需要的地方给变量赋值，但请把它们放在一个合理的位置。</p>
<blockquote>
<p>为什么？<code>let</code> 和 <code>const</code> 是块级作用域而不是函数作用域。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  test();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'doing stuff..'</span>);</div><div class="line"></div><div class="line">  <span class="comment">//..other stuff..</span></div><div class="line"></div><div class="line">  <span class="keyword">const</span> name = getName();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (name === <span class="string">'test'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad - unnecessary function call</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">hasName</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> name = getName();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!hasName) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.setFirstName(name);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">hasName</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!hasName) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> name = getName();</div><div class="line">  <span class="keyword">this</span>.setFirstName(name);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="hoisting"></a></p>
<h2 id="Hoisting"><a href="#Hoisting" class="headerlink" title="Hoisting"></a>Hoisting</h2><ul>
<li><p><a href="#14.1">14.1</a> <a name="14.1"></a> <code>var</code> 声明会被提升至该作用域的顶部，但它们赋值不会提升。<code>let</code> 和 <code>const</code> 被赋予了一种称为「<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let" rel="external nofollow noopener noreferrer" target="_blank">暂时性死区（Temporal Dead Zones, TDZ）</a>」的概念。这对于了解为什么 <a href="http://es-discourse.com/t/why-typeof-is-no-longer-safe/15" rel="external nofollow noopener noreferrer" target="_blank">type of 不再安全</a>相当重要。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 我们知道这样运行不了</span></div><div class="line"><span class="comment">// （假设 notDefined 不是全局变量）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(notDefined); <span class="comment">// =&gt; throws a ReferenceError</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 由于变量提升的原因，</span></div><div class="line"><span class="comment">// 在引用变量后再声明变量是可以运行的。</span></div><div class="line"><span class="comment">// 注：变量的赋值 `true` 不会被提升。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(declaredButNotAssigned); <span class="comment">// =&gt; undefined</span></div><div class="line">  <span class="keyword">var</span> declaredButNotAssigned = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译器会把函数声明提升到作用域的顶层，</span></div><div class="line"><span class="comment">// 这意味着我们的例子可以改写成这样：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> declaredButNotAssigned;</div><div class="line">  <span class="built_in">console</span>.log(declaredButNotAssigned); <span class="comment">// =&gt; undefined</span></div><div class="line">  declaredButNotAssigned = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用 const 和 let</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(declaredButNotAssigned); <span class="comment">// =&gt; throws a ReferenceError</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> declaredButNotAssigned); <span class="comment">// =&gt; throws a ReferenceError</span></div><div class="line">  <span class="keyword">const</span> declaredButNotAssigned = <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#14.2">14.2</a> <a name="14.2"></a> 匿名函数表达式的变量名会被提升，但函数内容并不会。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(anonymous); <span class="comment">// =&gt; undefined</span></div><div class="line"></div><div class="line">  anonymous(); <span class="comment">// =&gt; TypeError anonymous is not a function</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> anonymous = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'anonymous function expression'</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#14.3">14.3</a> <a name="14.3"></a> 命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(named); <span class="comment">// =&gt; undefined</span></div><div class="line"></div><div class="line">  named(); <span class="comment">// =&gt; TypeError named is not a function</span></div><div class="line"></div><div class="line">  superPower(); <span class="comment">// =&gt; ReferenceError superPower is not defined</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">superPower</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Flying'</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// the same is true when the function name</span></div><div class="line"><span class="comment">// is the same as the variable name.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(named); <span class="comment">// =&gt; undefined</span></div><div class="line"></div><div class="line">  named(); <span class="comment">// =&gt; TypeError named is not a function</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">named</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'named'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#14.4">14.4</a> <a name="14.4"></a> 函数声明的名称和函数体都会被提升。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  superPower(); <span class="comment">// =&gt; Flying</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">superPower</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Flying'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>想了解更多信息，参考 <a href="http://www.adequatelygood.com/" rel="external nofollow noopener noreferrer" target="_blank">Ben Cherry</a> 的 <a href="http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting" rel="external nofollow noopener noreferrer" target="_blank">JavaScript Scoping &amp; Hoisting</a>。</p>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="comparison-operators--equality"></a></p>
<h2 id="比较运算符和等号"><a href="#比较运算符和等号" class="headerlink" title="比较运算符和等号"></a>比较运算符和等号</h2><ul>
<li><a href="#15.1">15.1</a> <a name="15.1"></a> 优先使用 <code>===</code> 和 <code>!==</code> 而不是 <code>==</code> 和 <code>!=</code>.</li>
<li><p><a href="#15.2">15.2</a> <a name="15.2"></a> 条件表达式例如 <code>if</code> 语句通过抽象方法 <code>ToBoolean</code> 强制计算它们的表达式并且总是遵守下面的规则：</p>
<ul>
<li><strong>对象</strong> 被计算为 <strong>true</strong></li>
<li><strong>Undefined</strong> 被计算为 <strong>false</strong></li>
<li><strong>Null</strong> 被计算为 <strong>false</strong></li>
<li><strong>布尔值</strong> 被计算为 <strong>布尔的值</strong></li>
<li><strong>数字</strong> 如果是 <strong>+0、-0、或 NaN</strong> 被计算为 <strong>false</strong>, 否则为 <strong>true</strong></li>
<li><strong>字符串</strong> 如果是空字符串 <code>&#39;&#39;</code> 被计算为 <strong>false</strong>，否则为 <strong>true</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([<span class="number">0</span>]) &#123;</div><div class="line">  <span class="comment">// true</span></div><div class="line">  <span class="comment">// An array is an object, objects evaluate to true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#15.3">15.3</a> <a name="15.3"></a> 使用简写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">if</span> (name !== <span class="string">''</span>) &#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (name) &#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">if</span> (collection.length &gt; <span class="number">0</span>) &#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (collection.length) &#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#15.4">15.4</a> <a name="15.4"></a> 想了解更多信息，参考 Angus Croll 的 <a href="http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108" rel="external nofollow noopener noreferrer" target="_blank">Truth Equality and JavaScript</a>。</p>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="blocks"></a></p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul>
<li><p><a href="#16.1">16.1</a> <a name="16.1"></a> 使用大括号包裹所有的多行代码块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">if</span> (test)</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (test) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (test) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#16.2">16.2</a> <a name="16.2"></a> 如果通过 <code>if</code> 和 <code>else</code> 使用多行代码块，把 <code>else</code> 放在 <code>if</code> 代码块关闭括号的同一行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">if</span> (test) &#123;</div><div class="line">  thing1();</div><div class="line">  thing2();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  thing3();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (test) &#123;</div><div class="line">  thing1();</div><div class="line">  thing2();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  thing3();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="comments"></a></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li><p><a href="#17.1">17.1</a> <a name="17.1"></a> 使用 <code>/** ... */</code> 作为多行注释。包含描述、指定所有参数和返回值的类型和值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="comment">// make() returns a new element</span></div><div class="line"><span class="comment">// based on the passed in tag name</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// @param &#123;String&#125; tag</span></div><div class="line"><span class="comment">// @return &#123;Element&#125; element</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">tag</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> element;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * make() returns a new element</div><div class="line"> * based on the passed in tag name</div><div class="line"> *</div><div class="line"> * @param &#123;String&#125; tag</div><div class="line"> * @return &#123;Element&#125; element</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">tag</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> element;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#17.2">17.2</a> <a name="17.2"></a> 使用 <code>//</code> 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> active = <span class="literal">true</span>;  <span class="comment">// is current tab</span></div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="comment">// is current tab</span></div><div class="line"><span class="keyword">const</span> active = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'fetching type...'</span>);</div><div class="line">  <span class="comment">// set the default type to 'no type'</span></div><div class="line">  <span class="keyword">const</span> type = <span class="keyword">this</span>._type || <span class="string">'no type'</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> type;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'fetching type...'</span>);</div><div class="line"></div><div class="line">  <span class="comment">// set the default type to 'no type'</span></div><div class="line">  <span class="keyword">const</span> type = <span class="keyword">this</span>._type || <span class="string">'no type'</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> type;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#17.3">17.3</a> <a name="17.3"></a> 给注释增加 <code>FIXME</code> 或 <code>TODO</code> 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 <code>FIXME -- need to figure this out</code> 或者 <code>TODO -- need to implement</code>。</p>
</li>
<li><p><a href="#17.4">17.4</a> <a name="17.4"></a> 使用 <code>// FIXME</code>: 标注问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="comment">// <span class="doctag">FIXME:</span> shouldn't use a global here</span></div><div class="line">    total = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#17.5">17.5</a> <a name="17.5"></a> 使用 <code>// TODO</code>: 标注问题的解决方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> total should be configurable by an options param</span></div><div class="line">    <span class="keyword">this</span>.total = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="whitespace"></a></p>
<h2 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h2><ul>
<li><p><a href="#18.1">18.1</a> <a name="18.1"></a> 使用 2 个空格作为缩进。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">∙∙∙∙<span class="keyword">const</span> name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">∙<span class="keyword">const</span> name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">∙∙<span class="keyword">const</span> name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#18.2">18.2</a> <a name="18.2"></a> 在花括号前放一个空格。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line">dog.set(<span class="string">'attr'</span>,&#123;</div><div class="line">  <span class="attr">age</span>: <span class="string">'1 year'</span>,</div><div class="line">  <span class="attr">breed</span>: <span class="string">'Bernese Mountain Dog'</span>,</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">dog.set(<span class="string">'attr'</span>, &#123;</div><div class="line">  <span class="attr">age</span>: <span class="string">'1 year'</span>,</div><div class="line">  <span class="attr">breed</span>: <span class="string">'Bernese Mountain Dog'</span>,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#18.3">18.3</a> <a name="18.3"></a> 在控制语句（<code>if</code>、<code>while</code> 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">if</span>(isJedi) &#123;</div><div class="line">  fight ();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (isJedi) &#123;</div><div class="line">  fight();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fight</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log (<span class="string">'Swooosh!'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fight</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Swooosh!'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#18.4">18.4</a> <a name="18.4"></a> 使用空格把运算符隔开。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> x=y+<span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> x = y + <span class="number">5</span>;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#18.5">18.5</a> <a name="18.5"></a> 在文件末尾插入一个空行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;)(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;)(<span class="keyword">this</span>);↵</div><div class="line">↵</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// good</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;)(<span class="keyword">this</span>);↵</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#18.5">18.5</a> <a name="18.5"></a> 在使用长方法链时进行缩进。使用前面的点 <code>.</code> 强调这是方法调用而不是新语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">$(<span class="string">'#items'</span>).find(<span class="string">'.selected'</span>).highlight().end().find(<span class="string">'.open'</span>).updateCount();</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line">$(<span class="string">'#items'</span>).</div><div class="line">  find(<span class="string">'.selected'</span>).</div><div class="line">    highlight().</div><div class="line">    end().</div><div class="line">  find(<span class="string">'.open'</span>).</div><div class="line">    updateCount();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">$(<span class="string">'#items'</span>)</div><div class="line">  .find(<span class="string">'.selected'</span>)</div><div class="line">    .highlight()</div><div class="line">    .end()</div><div class="line">  .find(<span class="string">'.open'</span>)</div><div class="line">    .updateCount();</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> leds = stage.selectAll(<span class="string">'.led'</span>).data(data).enter().append(<span class="string">'svg:svg'</span>).class(<span class="string">'led'</span>, <span class="literal">true</span>)</div><div class="line">    .attr(<span class="string">'width'</span>, (radius + margin) * <span class="number">2</span>).append(<span class="string">'svg:g'</span>)</div><div class="line">    .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + (radius + margin) + <span class="string">','</span> + (radius + margin) + <span class="string">')'</span>)</div><div class="line">    .call(tron.led);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> leds = stage.selectAll(<span class="string">'.led'</span>)</div><div class="line">    .data(data)</div><div class="line">  .enter().append(<span class="string">'svg:svg'</span>)</div><div class="line">    .classed(<span class="string">'led'</span>, <span class="literal">true</span>)</div><div class="line">    .attr(<span class="string">'width'</span>, (radius + margin) * <span class="number">2</span>)</div><div class="line">  .append(<span class="string">'svg:g'</span>)</div><div class="line">    .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + (radius + margin) + <span class="string">','</span> + (radius + margin) + <span class="string">')'</span>)</div><div class="line">    .call(tron.led);</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#18.6">18.6</a> <a name="18.6"></a> 在块末和新语句前插入空行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">if</span> (foo) &#123;</div><div class="line">  <span class="keyword">return</span> bar;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> baz;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (foo) &#123;</div><div class="line">  <span class="keyword">return</span> bar;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> baz;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  foo() &#123;</div><div class="line">  &#125;,</div><div class="line">  bar() &#123;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line"><span class="keyword">return</span> obj;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  foo() &#123;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  bar() &#123;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">return</span> obj;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="commas"></a></p>
<h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2><ul>
<li><p><a href="#19.1">19.1</a> <a name="19.1"></a> 行首逗号：<strong>不需要</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> story = [</div><div class="line">    once</div><div class="line">  , upon</div><div class="line">  , aTime</div><div class="line">];</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> story = [</div><div class="line">  once,</div><div class="line">  upon,</div><div class="line">  aTime,</div><div class="line">];</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> hero = &#123;</div><div class="line">    <span class="attr">firstName</span>: <span class="string">'Ada'</span></div><div class="line">  , <span class="attr">lastName</span>: <span class="string">'Lovelace'</span></div><div class="line">  , <span class="attr">birthYear</span>: <span class="number">1815</span></div><div class="line">  , <span class="attr">superPower</span>: <span class="string">'computers'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> hero = &#123;</div><div class="line">  <span class="attr">firstName</span>: <span class="string">'Ada'</span>,</div><div class="line">  <span class="attr">lastName</span>: <span class="string">'Lovelace'</span>,</div><div class="line">  <span class="attr">birthYear</span>: <span class="number">1815</span>,</div><div class="line">  <span class="attr">superPower</span>: <span class="string">'computers'</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#19.2">19.2</a> <a name="19.2"></a> 增加结尾的逗号: <strong>需要</strong>。</p>
<blockquote>
<p>为什么? 这会让 git diffs 更干净。另外，像 babel 这样的转译器会移除结尾多余的逗号，也就是说你不必担心老旧浏览器的<a href="es5/README.md#commas">尾逗号问题</a>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad - git diff without trailing comma</span></div><div class="line"><span class="keyword">const</span> hero = &#123;</div><div class="line">     <span class="attr">firstName</span>: <span class="string">'Florence'</span>,</div><div class="line">-    lastName: <span class="string">'Nightingale'</span></div><div class="line">+    lastName: <span class="string">'Nightingale'</span>,</div><div class="line">+    inventorOf: [<span class="string">'coxcomb graph'</span>, <span class="string">'modern nursing'</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good - git diff with trailing comma</span></div><div class="line"><span class="keyword">const</span> hero = &#123;</div><div class="line">     <span class="attr">firstName</span>: <span class="string">'Florence'</span>,</div><div class="line">     <span class="attr">lastName</span>: <span class="string">'Nightingale'</span>,</div><div class="line">+    inventorOf: [<span class="string">'coxcomb chart'</span>, <span class="string">'modern nursing'</span>],</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> hero = &#123;</div><div class="line">  <span class="attr">firstName</span>: <span class="string">'Dana'</span>,</div><div class="line">  <span class="attr">lastName</span>: <span class="string">'Scully'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> heroes = [</div><div class="line">  <span class="string">'Batman'</span>,</div><div class="line">  <span class="string">'Superman'</span></div><div class="line">];</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> hero = &#123;</div><div class="line">  <span class="attr">firstName</span>: <span class="string">'Dana'</span>,</div><div class="line">  <span class="attr">lastName</span>: <span class="string">'Scully'</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> heroes = [</div><div class="line">  <span class="string">'Batman'</span>,</div><div class="line">  <span class="string">'Superman'</span>,</div><div class="line">];</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="semicolons"></a></p>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><ul>
<li><p><a href="#20.1">20.1</a> <a name="20.1"></a> <strong>使用分号</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> name = <span class="string">'Skywalker'</span></div><div class="line">  <span class="keyword">return</span> name</div><div class="line">&#125;)()</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> name = <span class="string">'Skywalker'</span>;</div><div class="line">  <span class="keyword">return</span> name;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">// good (防止函数在两个 IIFE 合并时被当成一个参数)</span></div><div class="line">;<span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> name = <span class="string">'Skywalker'</span>;</div><div class="line">  <span class="keyword">return</span> name;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p><a href="http://stackoverflow.com/a/7365214/1712802" rel="external nofollow noopener noreferrer" target="_blank">Read more</a>.</p>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="type-casting--coercion"></a></p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li><a href="#21.1">21.1</a> <a name="21.1"></a> 在语句开始时执行类型转换。</li>
<li><p><a href="#21.2">21.2</a> <a name="21.2"></a> 字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  =&gt; this.reviewScore = 9;</span></div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> totalScore = <span class="keyword">this</span>.reviewScore + <span class="string">''</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> totalScore = <span class="built_in">String</span>(<span class="keyword">this</span>.reviewScore);</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#21.3">21.3</a> <a name="21.3"></a> 对数字使用 <code>parseInt</code> 转换，并带上类型转换的基数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> inputValue = <span class="string">'4'</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> val = <span class="keyword">new</span> <span class="built_in">Number</span>(inputValue);</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> val = +inputValue;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> val = inputValue &gt;&gt; <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> val = <span class="built_in">parseInt</span>(inputValue);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> val = <span class="built_in">Number</span>(inputValue);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> val = <span class="built_in">parseInt</span>(inputValue, <span class="number">10</span>);</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#21.4">21.4</a> <a name="21.4"></a> 如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决<a href="http://jsperf.com/coercion-vs-casting/3" rel="external nofollow noopener noreferrer" target="_blank">性能问题</a>时，留个注释说清楚原因和你的目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// good</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用 parseInt 导致我的程序变慢，</div><div class="line"> * 改成使用位操作转换数字快多了。</div><div class="line"> */</div><div class="line"><span class="keyword">const</span> val = inputValue &gt;&gt; <span class="number">0</span>;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#21.5">21.5</a> <a name="21.5"></a> <strong>注:</strong> 小心使用位操作运算符。数字会被当成 <a href="http://es5.github.io/#x4.3.19" rel="external nofollow noopener noreferrer" target="_blank">64 位值</a>，但是位操作运算符总是返回 32 位的整数（<a href="http://es5.github.io/#x11.7" rel="external nofollow noopener noreferrer" target="_blank">参考</a>）。位操作处理大于 32 位的整数值时还会导致意料之外的行为。<a href="https://github.com/airbnb/javascript/issues/109" rel="external nofollow noopener noreferrer" target="_blank">关于这个问题的讨论</a>。最大的 32 位整数是 2,147,483,647：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2147483647</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; 2147483647</span></div><div class="line"><span class="number">2147483648</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; -2147483648</span></div><div class="line"><span class="number">2147483649</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; -2147483647</span></div></pre></td></tr></table></figure>
</li>
<li><p><a href="#21.6">21.6</a> <a name="21.6"></a> 布尔:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> age = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> hasAge = <span class="keyword">new</span> <span class="built_in">Boolean</span>(age);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> hasAge = <span class="built_in">Boolean</span>(age);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> hasAge = !!age;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="naming-conventions"></a></p>
<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ul>
<li><p><a href="#22.1">22.1</a> <a name="22.1"></a> 避免单字母命名。命名应具备描述性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">q</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ..stuff..</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#22.2">22.2</a> <a name="22.2"></a> 使用驼峰式命名对象、函数和实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> OBJEcttsssss = &#123;&#125;;</div><div class="line"><span class="keyword">const</span> this_is_my_object = &#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> thisIsMyObject = &#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisIsMyFunction</span>(<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#22.3">22.3</a> <a name="22.3"></a> 使用帕斯卡式命名构造函数或类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">user</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = options.name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> bad = <span class="keyword">new</span> user(&#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'nope'</span>,</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(options) &#123;</div><div class="line">    <span class="keyword">this</span>.name = options.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> good = <span class="keyword">new</span> User(&#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'yup'</span>,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#22.4">22.4</a> <a name="22.4"></a> 不要使用下划线 <code>_</code> 结尾或开头来命名属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">this</span>.__firstName__ = <span class="string">'Panda'</span>;</div><div class="line"><span class="keyword">this</span>.firstName_ = <span class="string">'Panda'</span>;</div><div class="line"><span class="keyword">this</span>._firstName = <span class="string">'Panda'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">this</span>.firstName = <span class="string">'Panda'</span>;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#22.5">22.5</a> <a name="22.5"></a> 别保存 <code>this</code> 的引用。使用箭头函数或 Function#bind。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(self);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(that);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#22.6">22.6</a> <a name="22.6"></a> 如果你的文件只输出一个类，那你的文件名必须和类名完全保持一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file contents</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckBox</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> CheckBox;</div><div class="line"></div><div class="line"><span class="comment">// in some other file</span></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">import</span> CheckBox <span class="keyword">from</span> <span class="string">'./checkBox'</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">import</span> CheckBox <span class="keyword">from</span> <span class="string">'./check_box'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">import</span> CheckBox <span class="keyword">from</span> <span class="string">'./CheckBox'</span>;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#22.7">22.7</a> <a name="22.7"></a> 当你导出默认的函数时使用驼峰式命名。你的文件名必须和函数名完全保持一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeStyleGuide</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> makeStyleGuide;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#22.8">22.8</a> <a name="22.8"></a> 当你导出单例、函数库、空对象时使用帕斯卡式命名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> AirbnbStyleGuide = &#123;</div><div class="line">  <span class="attr">es6</span>: &#123;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> AirbnbStyleGuide;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="accessors"></a></p>
<h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><ul>
<li><a href="#23.1">23.1</a> <a name="23.1"></a> 属性的存取函数不是必须的。</li>
<li><p><a href="#23.2">23.2</a> <a name="23.2"></a> 如果你需要存取函数时使用 <code>getVal()</code> 和 <code>setVal(&#39;hello&#39;)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">dragon.age();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">dragon.getAge();</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line">dragon.age(<span class="number">25</span>);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">dragon.setAge(<span class="number">25</span>);</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#23.3">23.3</a> <a name="23.3"></a> 如果属性是布尔值，使用 <code>isVal()</code> 或 <code>hasVal()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">if</span> (!dragon.age()) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (!dragon.hasAge()) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#23.4">23.4</a> <a name="23.4"></a> 创建 <code>get()</code> 和 <code>set()</code> 函数是可以的，但要保持一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jedi</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</div><div class="line">    <span class="keyword">const</span> lightsaber = options.lightsaber || <span class="string">'blue'</span>;</div><div class="line">    <span class="keyword">this</span>.set(<span class="string">'lightsaber'</span>, lightsaber);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  set(key, val) &#123;</div><div class="line">    <span class="keyword">this</span>[key] = val;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  get(key) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[key];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="events"></a></p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li><p><a href="#24.1">24.1</a> <a name="24.1"></a> 当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。例如，不好的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">$(<span class="keyword">this</span>).trigger(<span class="string">'listingUpdated'</span>, listing.id);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">$(<span class="keyword">this</span>).on(<span class="string">'listingUpdated'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e, listingId</span>) </span>&#123;</div><div class="line">  <span class="comment">// do something with listingId</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>更好的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// good</span></div><div class="line">$(<span class="keyword">this</span>).trigger(<span class="string">'listingUpdated'</span>, &#123; <span class="attr">listingId</span> : listing.id &#125;);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">$(<span class="keyword">this</span>).on(<span class="string">'listingUpdated'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e, data</span>) </span>&#123;</div><div class="line">  <span class="comment">// do something with data.listingId</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
</li>
</ul>
<h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><ul>
<li><p><a href="#25.1">25.1</a> <a name="25.1"></a> 使用 <code>$</code> 作为存储 jQuery 对象的变量名前缀。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> sidebar = $(<span class="string">'.sidebar'</span>);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> $sidebar = $(<span class="string">'.sidebar'</span>);</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#25.2">25.2</a> <a name="25.2"></a> 缓存 jQuery 查询。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setSidebar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  $(<span class="string">'.sidebar'</span>).hide();</div><div class="line"></div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line"></div><div class="line">  $(<span class="string">'.sidebar'</span>).css(&#123;</div><div class="line">    <span class="string">'background-color'</span>: <span class="string">'pink'</span></div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setSidebar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> $sidebar = $(<span class="string">'.sidebar'</span>);</div><div class="line">  $sidebar.hide();</div><div class="line"></div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line"></div><div class="line">  $sidebar.css(&#123;</div><div class="line">    <span class="string">'background-color'</span>: <span class="string">'pink'</span></div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#25.3">25.3</a> <a name="25.3"></a> 对 DOM 查询使用层叠 <code>$(&#39;.sidebar ul&#39;)</code> 或 父元素 &gt; 子元素 <code>$(&#39;.sidebar &gt; ul&#39;)</code>。 <a href="http://jsperf.com/jquery-find-vs-context-sel/16" rel="external nofollow noopener noreferrer" target="_blank">jsPerf</a></p>
</li>
<li><p><a href="#25.4">25.4</a> <a name="25.4"></a> 对有作用域的 jQuery 对象查询使用 <code>find</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">$(<span class="string">'ul'</span>, <span class="string">'.sidebar'</span>).hide();</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line">$(<span class="string">'.sidebar'</span>).find(<span class="string">'ul'</span>).hide();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">$(<span class="string">'.sidebar ul'</span>).hide();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">$(<span class="string">'.sidebar &gt; ul'</span>).hide();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">$sidebar.find(<span class="string">'ul'</span>).hide();</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="ecmascript-5-compatibility"></a></p>
<h2 id="ECMAScript-5-兼容性"><a href="#ECMAScript-5-兼容性" class="headerlink" title="ECMAScript 5 兼容性"></a>ECMAScript 5 兼容性</h2><ul>
<li><a href="#26.1">26.1</a> <a name="26.1"></a> 参考 <a href="https://twitter.com/kangax/" rel="external nofollow noopener noreferrer" target="_blank">Kangax</a> 的 ES5 <a href="http://kangax.github.com/es5-compat-table/" rel="external nofollow noopener noreferrer" target="_blank">兼容性</a>。</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="ecmascript-6-styles"></a></p>
<h2 id="ECMAScript-6-规范"><a href="#ECMAScript-6-规范" class="headerlink" title="ECMAScript 6 规范"></a>ECMAScript 6 规范</h2><ul>
<li><a href="#27.1">27.1</a> <a name="27.1"></a> 以下是链接到 ES6 各个特性的列表。</li>
</ul>
<ol>
<li><a href="#arrow-functions">箭头函数</a></li>
<li><a href="#constructors">类</a></li>
<li><a href="#es6-object-shorthand">对象方法简写</a></li>
<li><a href="#es6-object-concise">对象属性简写</a></li>
<li><a href="#es6-computed-properties">对象中的可计算属性</a></li>
<li><a href="#es6-template-literals">模板字符串</a></li>
<li><a href="#destructuring">解构</a></li>
<li><a href="#es6-default-parameters">默认参数</a></li>
<li><a href="#es6-rest">Rest</a></li>
<li><a href="#es6-array-spreads">数组 Spreads</a></li>
<li><a href="#references">Let 及 Const</a></li>
<li><a href="#iterators-and-generators">迭代器和生成器</a></li>
<li><a href="#modules">模块</a></li>
</ol>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="testing"></a></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li><p><a href="#28.1">28.1</a> <a name="28.1"></a> <strong>Yup.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="performance"></a></p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li><a href="http://kellegous.com/j/2013/01/26/layout-performance/" rel="external nofollow noopener noreferrer" target="_blank">On Layout &amp; Web Performance</a></li>
<li><a href="http://jsperf.com/string-vs-array-concat/2" rel="external nofollow noopener noreferrer" target="_blank">String vs Array Concat</a></li>
<li><a href="http://jsperf.com/try-catch-in-loop-cost" rel="external nofollow noopener noreferrer" target="_blank">Try/Catch Cost In a Loop</a></li>
<li><a href="http://jsperf.com/bang-function" rel="external nofollow noopener noreferrer" target="_blank">Bang Function</a></li>
<li><a href="http://jsperf.com/jquery-find-vs-context-sel/13" rel="external nofollow noopener noreferrer" target="_blank">jQuery Find vs Context, Selector</a></li>
<li><a href="http://jsperf.com/innerhtml-vs-textcontent-for-script-text" rel="external nofollow noopener noreferrer" target="_blank">innerHTML vs textContent for script text</a></li>
<li><a href="http://jsperf.com/ya-string-concat" rel="external nofollow noopener noreferrer" target="_blank">Long String Concatenation</a></li>
<li><a href="https://www.quora.com/JavaScript-programming-language-Are-Javascript-functions-like-map-reduce-and-filter-already-optimized-for-traversing-array/answer/Quildreen-Motta" rel="external nofollow noopener noreferrer" target="_blank">Are Javascript functions like <code>map()</code>, <code>reduce()</code>, and <code>filter()</code> optimized for traversing arrays?</a></li>
<li>等等…</li>
</ul>
<p><strong><a href="#table-of-contents">⬆ 返回目录</a></strong></p>
<p><a name="resources"></a></p>
<h2 id="相关资源（英文）"><a href="#相关资源（英文）" class="headerlink" title="相关资源（英文）"></a>相关资源（英文）</h2><p><strong>了解 ES6</strong></p>
<ul>
<li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html" rel="external nofollow noopener noreferrer" target="_blank">ECMA 2015 (ES6) 规范草案</a></li>
<li><a href="http://exploringjs.com/" rel="external nofollow noopener noreferrer" target="_blank">ExploringJS</a></li>
<li><a href="https://kangax.github.io/compat-table/es6/" rel="external nofollow noopener noreferrer" target="_blank">ES6 兼容性表</a></li>
<li><a href="http://es6-features.org/" rel="external nofollow noopener noreferrer" target="_blank">ES6 特性全面概况</a></li>
</ul>
<p><strong>看看这个</strong></p>
<ul>
<li><a href="http://es5.github.com/" rel="external nofollow noopener noreferrer" target="_blank">Annotated ECMAScript 5.1</a></li>
</ul>
<p><strong>工具</strong></p>
<ul>
<li>代码风格检查器（Lint）<ul>
<li><a href="http://eslint.org/" rel="external nofollow noopener noreferrer" target="_blank">ESlint</a> - <a href="https://github.com/airbnb/javascript/blob/master/linters/.eslintrc" rel="external nofollow noopener noreferrer" target="_blank">Airbnb Style .eslintrc</a></li>
<li><a href="http://www.jshint.com/" rel="external nofollow noopener noreferrer" target="_blank">JSHint</a> - <a href="https://github.com/airbnb/javascript/blob/master/linters/jshintrc" rel="external nofollow noopener noreferrer" target="_blank">Airbnb Style .jshintrc</a></li>
<li><a href="https://github.com/jscs-dev/node-jscs" rel="external nofollow noopener noreferrer" target="_blank">JSCS</a> - <a href="https://github.com/jscs-dev/node-jscs/blob/master/presets/airbnb.json" rel="external nofollow noopener noreferrer" target="_blank">Airbnb Style Preset</a></li>
</ul>
</li>
</ul>
<p><strong>拓展阅读</strong></p>
<ul>
<li><a href="http://javascriptweblog.wordpress.com/2010/10/25/understanding-javascript-closures/" rel="external nofollow noopener noreferrer" target="_blank">Understanding JavaScript Closures</a> - Angus Croll</li>
<li><a href="http://www.2ality.com/2013/06/basic-javascript.html" rel="external nofollow noopener noreferrer" target="_blank">Basic JavaScript for the impatient programmer</a> - Dr. Axel Rauschmayer</li>
<li><a href="http://youmightnotneedjquery.com/" rel="external nofollow noopener noreferrer" target="_blank">You Might Not Need jQuery</a> - Zack Bloom &amp; Adam Schwartz</li>
<li><a href="https://github.com/lukehoban/es6features" rel="external nofollow noopener noreferrer" target="_blank">ES6 Features</a> - Luke Hoban</li>
<li><a href="https://github.com/bendc/frontend-guidelines" rel="external nofollow noopener noreferrer" target="_blank">Frontend Guidelines</a> - Benjamin De Cock</li>
</ul>
<p><strong>书籍</strong></p>
<ul>
<li><a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742" rel="external nofollow noopener noreferrer" target="_blank">JavaScript: The Good Parts</a> - Douglas Crockford</li>
<li><a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752" rel="external nofollow noopener noreferrer" target="_blank">JavaScript Patterns</a> - Stoyan Stefanov</li>
<li><a href="http://www.amazon.com/JavaScript-Design-Patterns-Recipes-Problem-Solution/dp/159059908X" rel="external nofollow noopener noreferrer" target="_blank">Pro JavaScript Design Patterns</a>  - Ross Harmes and Dustin Diaz</li>
<li><a href="http://www.amazon.com/High-Performance-Web-Sites-Essential/dp/0596529309" rel="external nofollow noopener noreferrer" target="_blank">High Performance Web Sites: Essential Knowledge for Front-End Engineers</a> - Steve Souders</li>
<li><a href="http://www.amazon.com/Maintainable-JavaScript-Nicholas-C-Zakas/dp/1449327680" rel="external nofollow noopener noreferrer" target="_blank">Maintainable JavaScript</a> - Nicholas C. Zakas</li>
<li><a href="http://www.amazon.com/JavaScript-Web-Applications-Alex-MacCaw/dp/144930351X" rel="external nofollow noopener noreferrer" target="_blank">JavaScript Web Applications</a> - Alex MacCaw</li>
<li><a href="http://www.amazon.com/Pro-JavaScript-Techniques-John-Resig/dp/1590597273" rel="external nofollow noopener noreferrer" target="_blank">Pro JavaScript Techniques</a> - John Resig</li>
<li><a href="http://www.amazon.com/Smashing-Node-js-JavaScript-Everywhere-Magazine/dp/1119962595" rel="external nofollow noopener noreferrer" target="_blank">Smashing Node.js: JavaScript Everywhere</a> - Guillermo Rauch</li>
<li><a href="http://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/193398869X" rel="external nofollow noopener noreferrer" target="_blank">Secrets of the JavaScript Ninja</a> - John Resig and Bear Bibeault</li>
<li><a href="http://humanjavascript.com/" rel="external nofollow noopener noreferrer" target="_blank">Human JavaScript</a> - Henrik Joreteg</li>
<li><a href="http://superherojs.com/" rel="external nofollow noopener noreferrer" target="_blank">Superhero.js</a> - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy</li>
<li><a href="http://jsbooks.revolunet.com/" rel="external nofollow noopener noreferrer" target="_blank">JSBooks</a> - Julien Bouquillon</li>
<li><a href="http://manning.com/vinegar/" rel="external nofollow noopener noreferrer" target="_blank">Third Party JavaScript</a> - Ben Vinegar and Anton Kovalyov</li>
<li><a href="http://amzn.com/0321812182" rel="external nofollow noopener noreferrer" target="_blank">Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript</a> - David Herman</li>
<li><a href="http://eloquentjavascript.net/" rel="external nofollow noopener noreferrer" target="_blank">Eloquent JavaScript</a> - Marijn Haverbeke</li>
</ul>
<h2 id="修订"><a href="#修订" class="headerlink" title="修订"></a>修订</h2><p>我们鼓励您派生本指南和更改规则以适应您的团队需求。您可以在下方列出对本风格指南的修改，以便定期更新本指南而无需处理合并冲突。</p>
<h1 id=""><a href="#" class="headerlink" title="};"></a>};</h1>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#types&quot;&gt;类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#references&quot;&gt;引用&lt;/a&gt;&lt;/l
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发标准" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E6%A0%87%E5%87%86/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="代码风格标准" scheme="http://wiki.haoqiao.me/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>Airbnb CSS 代码风格标准</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E6%A0%87%E5%87%86/Airbnb%20Css%20%E6%A0%87%E5%87%86/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/开发标准/Airbnb Css 标准/</id>
    <published>2017-09-04T03:23:22.000Z</published>
    <updated>2017-09-04T03:24:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#terminology">术语</a><ul>
<li><a href="#rule-declaration">规则声明</a></li>
<li><a href="#selectors">选择器</a></li>
<li><a href="#properties">属性</a></li>
</ul>
</li>
<li><a href="#css">CSS</a><ul>
<li><a href="#formatting">格式</a></li>
<li><a href="#comments">注释</a></li>
<li><a href="#oocss-and-bem">OOCSS 和 BEM</a></li>
<li><a href="#id-selectors">ID 选择器</a></li>
<li><a href="#javascript-hooks">JavaScript 钩子</a></li>
<li><a href="#border">边框</a></li>
</ul>
</li>
<li><a href="#sass">Sass</a><ul>
<li><a href="#syntax">语法</a></li>
<li><a href="#ordering-of-property-declarations">排序</a></li>
<li><a href="#variables">变量</a></li>
<li><a href="#mixins">Mixins</a></li>
<li><a href="#extend-directive">扩展指令</a></li>
<li><a href="#nested-selectors">嵌套选择器</a></li>
</ul>
</li>
</ol>
<p><a name="terminology"></a></p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><a name="rule-declaration"></a></p>
<h3 id="规则声明"><a href="#规则声明" class="headerlink" title="规则声明"></a>规则声明</h3><p>我们把一个（或一组）选择器和一组属性称之为 “规则声明”。举个例子：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.listing</span> &#123;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">1.2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a name="selectors"></a></p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>在规则声明中，“选择器” 负责选取 DOM 树中的元素，这些元素将被定义的属性所修饰。选择器可以匹配 HTML 元素，也可以匹配一个元素的类名、ID, 或者元素拥有的属性。以下是选择器的例子：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.my-element-class</span> &#123;</div><div class="line">  <span class="comment">/* ... */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-attr">[aria-hidden]</span> &#123;</div><div class="line">  <span class="comment">/* ... */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a name="properties"></a></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>最后，属性决定了规则声明里被选择的元素将得到何种样式。属性以键值对形式存在，一个规则声明可以包含一或多个属性定义。以下是属性定义的例子：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* some selector */</span> &#123;</div><div class="line">  <span class="attribute">background</span>: <span class="number">#f1f1f1</span>;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a name="css"></a></p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p><a name="formatting"></a></p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul>
<li>使用 2 个空格作为缩进。</li>
<li>类名建议使用破折号代替驼峰法。如果你使用 BEM，也可以使用下划线（参见下面的 <a href="#oocss-and-bem">OOCSS 和 BEM</a>）。</li>
<li>不要使用 ID 选择器。</li>
<li>在一个规则声明中应用了多个选择器时，每个选择器独占一行。</li>
<li>在规则声明的左大括号 <code>{</code> 前加上一个空格。</li>
<li>在属性的冒号 <code>:</code> 后面加上一个空格，前面不加空格。</li>
<li>规则声明的右大括号 <code>}</code> 独占一行。</li>
<li>规则声明之间用空行分隔开。</li>
</ul>
<p><strong>Bad</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.avatar&#123;</div><div class="line">    border-radius:50%;</div><div class="line">    border:2px solid white; &#125;</div><div class="line">.no, .nope, .not_good &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div><div class="line">#lol-no &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Good</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.avatar &#123;</div><div class="line">  border-radius: 50%;</div><div class="line">  border: 2px solid white;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.one,</div><div class="line">.selector,</div><div class="line">.per-line &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a name="comments"></a></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>建议使用行注释 (在 Sass 中是 <code>//</code>) 代替块注释。</li>
<li>建议注释独占一行。避免行末注释。</li>
<li>给没有自注释的代码写上详细说明，比如：<ul>
<li>为什么用到了 z-index</li>
<li>兼容性处理或者针对特定浏览器的 hack</li>
</ul>
</li>
</ul>
<p><a name="oocss-and-bem"></a></p>
<h3 id="OOCSS-和-BEM"><a href="#OOCSS-和-BEM" class="headerlink" title="OOCSS 和 BEM"></a>OOCSS 和 BEM</h3><p>出于以下原因，我们鼓励使用 OOCSS 和 BEM 的某种组合：</p>
<ul>
<li>可以帮助我们理清 CSS 和 HTML 之间清晰且严谨的关系。</li>
<li>可以帮助我们创建出可重用、易装配的组件。</li>
<li>可以减少嵌套，降低特定性。</li>
<li>可以帮助我们创建出可扩展的样式表。</li>
</ul>
<p><strong>OOCSS</strong>，也就是 “Object Oriented CSS（面向对象的CSS）”，是一种写 CSS 的方法，其思想就是鼓励你把样式表看作“对象”的集合：创建可重用性、可重复性的代码段让你可以在整个网站中多次使用。</p>
<p>参考资料：</p>
<ul>
<li>Nicole Sullivan 的 <a href="https://github.com/stubbornella/oocss/wiki" rel="external nofollow noopener noreferrer" target="_blank">OOCSS wiki</a></li>
<li>Smashing Magazine 的 <a href="http://www.smashingmagazine.com/2011/12/12/an-introduction-to-object-oriented-css-oocss/" rel="external nofollow noopener noreferrer" target="_blank">Introduction to OOCSS</a></li>
</ul>
<p><strong>BEM</strong>，也就是 “Block-Element-Modifier”，是一种用于 HTML 和 CSS 类名的<em>命名约定</em>。BEM 最初是由 Yandex 提出的，要知道他们拥有巨大的代码库和可伸缩性，BEM 就是为此而生的，并且可以作为一套遵循 OOCSS 的参考指导规范。</p>
<ul>
<li>CSS Trick 的 <a href="https://css-tricks.com/bem-101/" rel="external nofollow noopener noreferrer" target="_blank">BEM 101</a></li>
<li>Harry Roberts 的 <a href="http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/" rel="external nofollow noopener noreferrer" target="_blank">introduction to BEM</a></li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"listing-card listing-card--featured"</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"listing-card__title"</span>&gt;</span>Adorable 2BR in the sunny Mission<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"listing-card__content"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Vestibulum id ligula porta felis euismod semper.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.listing-card</span> &#123; &#125;</div><div class="line"><span class="selector-class">.listing-card--featured</span> &#123; &#125;</div><div class="line"><span class="selector-class">.listing-card__title</span> &#123; &#125;</div><div class="line"><span class="selector-class">.listing-card__content</span> &#123; &#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>.listing-card</code> 是一个块（block），表示高层次的组件。</li>
<li><code>.listing-card__title</code> 是一个元素（element），它属于 <code>.listing-card</code> 的一部分，因此块是由元素组成的。</li>
<li><code>.listing-card--featured</code> 是一个修饰符（modifier），表示这个块与 <code>.listing-card</code> 有着不同的状态或者变化。</li>
</ul>
<p><a name="id-selectors"></a></p>
<h3 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a>ID 选择器</h3><p>在 CSS 中，虽然可以通过 ID 选择元素，但大家通常都会把这种方式列为反面教材。ID 选择器给你的规则声明带来了不必要的高<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity" rel="external nofollow noopener noreferrer" target="_blank">优先级</a>，而且 ID 选择器是不可重用的。</p>
<p>想要了解关于这个主题的更多内容，参见 <a href="http://csswizardry.com/2014/07/hacks-for-dealing-with-specificity/" rel="external nofollow noopener noreferrer" target="_blank">CSS Wizardry 的文章</a>，文章中有关于如何处理优先级的内容。</p>
<p><a name="javascript-hooks"></a></p>
<h3 id="JavaScript-钩子"><a href="#JavaScript-钩子" class="headerlink" title="JavaScript 钩子"></a>JavaScript 钩子</h3><p>避免在 CSS 和 JavaScript 中绑定相同的类。否则开发者在重构时通常会出现以下情况：轻则浪费时间在对照查找每个要改变的类，重则因为害怕破坏功能而不敢作出更改。</p>
<p>我们推荐在创建用于特定 JavaScript 的类名时，添加 <code>.js-</code> 前缀：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary js-request-to-book"</span>&gt;</span>Request to Book<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p><a name="border"></a></p>
<h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>在定义无边框样式时，使用 <code>0</code> 代替 <code>none</code>。</p>
<p><strong>Bad</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.foo</span> &#123;</div><div class="line">  <span class="attribute">border</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Good</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.foo</span> &#123;</div><div class="line">  <span class="attribute">border</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a name="sass"></a></p>
<h2 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h2><p><a name="syntax"></a></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li>使用 <code>.scss</code> 的语法，不使用 <code>.sass</code> 原本的语法。</li>
<li>CSS 和 <code>@include</code> 声明按照以下逻辑排序（参见下文）</li>
</ul>
<p><a name="ordering-of-property-declarations"></a></p>
<h3 id="属性声明的排序"><a href="#属性声明的排序" class="headerlink" title="属性声明的排序"></a>属性声明的排序</h3><ol>
<li><p>属性声明</p>
<p> 首先列出除去 <code>@include</code> 和嵌套选择器之外的所有属性声明。</p>
 <figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.btn-green</span> &#123;</div><div class="line">  <span class="attribute">background</span>: green;</div><div class="line">  <span class="attribute">font-weight</span>: bold;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>@include</code> 声明</p>
<p> 紧随后面的是 <code>@include</code>，这样可以使得整个选择器的可读性更高。</p>
 <figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.btn-green</span> &#123;</div><div class="line">  <span class="attribute">background</span>: green;</div><div class="line">  <span class="attribute">font-weight</span>: bold;</div><div class="line">  @<span class="keyword">include</span> transition(background 0.5s ease);</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>嵌套选择器</p>
<p> <em>如果有必要</em>用到嵌套选择器，把它们放到最后，在规则声明和嵌套选择器之间要加上空白，相邻嵌套选择器之间也要加上空白。嵌套选择器中的内容也要遵循上述指引。</p>
 <figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.btn</span> &#123;</div><div class="line">  <span class="attribute">background</span>: green;</div><div class="line">  <span class="attribute">font-weight</span>: bold;</div><div class="line">  @<span class="keyword">include</span> transition(background 0.5s ease);</div><div class="line"></div><div class="line">  <span class="selector-class">.icon</span> &#123;</div><div class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><a name="variables"></a></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量名应使用破折号（例如 <code>$my-variable</code>）代替 camelCased 和 snake_cased 风格。对于仅用在当前文件的变量，可以在变量名之前添加下划线前缀（例如 <code>$_my-variable</code>）。</p>
<p><a name="mixins"></a></p>
<h3 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h3><p>为了让代码遵循 DRY 原则（Don’t Repeat Yourself）、增强清晰性或抽象化复杂性，应该使用 mixin，这与那些命名良好的函数的作用是异曲同工的。虽然 mixin 可以不接收参数，但要注意，假如你不压缩负载（比如通过 gzip），这样会导致最终的样式包含不必要的代码重复。</p>
<p><a name="extend-directive"></a></p>
<h3 id="扩展指令"><a href="#扩展指令" class="headerlink" title="扩展指令"></a>扩展指令</h3><p>应避免使用 <code>@extend</code> 指令，因为它并不直观，而且具有潜在风险，特别是用在嵌套选择器的时候。即便是在顶层占位符选择器使用扩展，如果选择器的顺序最终会改变，也可能会导致问题。（比如，如果它们存在于其他文件，而加载顺序发生了变化）。其实，使用 @extend 所获得的大部分优化效果，gzip 压缩已经帮助你做到了，因此你只需要通过 mixin 让样式表更符合 DRY 原则就足够了。</p>
<p><a name="nested-selectors"></a></p>
<h3 id="嵌套选择器"><a href="#嵌套选择器" class="headerlink" title="嵌套选择器"></a>嵌套选择器</h3><p><strong>请不要让嵌套选择器的深度超过 3 层！</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.page-container</span> &#123;</div><div class="line">  <span class="selector-class">.content</span> &#123;</div><div class="line">    <span class="selector-class">.profile</span> &#123;</div><div class="line">      <span class="comment">// STOP!</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当遇到以上情况的时候，你也许是这样写 CSS 的：</p>
<ul>
<li>与 HTML 强耦合的（也是脆弱的）<em>—或者—</em></li>
<li>过于具体（强大）<em>—或者—</em></li>
<li>没有重用</li>
</ul>
<p>再说一遍: <strong>永远不要嵌套 ID 选择器！</strong></p>
<p>如果你始终坚持要使用 ID 选择器（劝你三思），那也不应该嵌套它们。如果你正打算这么做，你需要先重新检查你的标签，或者指明原因。如果你想要写出风格良好的 HTML 和 CSS，你是<strong>不</strong>应该这样做的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#terminology&quot;&gt;术语&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#rule-declaration
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发标准" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E6%A0%87%E5%87%86/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="代码风格标准" scheme="http://wiki.haoqiao.me/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>React项目开发一些摘要</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/React/React%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%80%E4%BA%9B%E6%91%98%E8%A6%81/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/框架/React/React项目开发一些摘要/</id>
    <published>2017-08-22T06:30:41.000Z</published>
    <updated>2017-08-22T06:55:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React动画"><a href="#React动画" class="headerlink" title="React动画"></a>React动画</h1><h3 id="input-css-demo"><a href="#input-css-demo" class="headerlink" title="input css demo"></a>input css demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">.input &#123;</div><div class="line">  transition: width .35s linear;</div><div class="line">  outline: none;</div><div class="line">  border: none;</div><div class="line">  border-radius: 4px;</div><div class="line">  padding: 10px;</div><div class="line">  font-size: 20px;</div><div class="line">  width: 150px;</div><div class="line">  background-color: #dddddd;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.input-focused &#123;</div><div class="line">  width: 240px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class App extends Component &#123;</div><div class="line">  state = &#123;</div><div class="line">    focused: false</div><div class="line">  &#125;</div><div class="line">  componentDidMount() &#123;</div><div class="line">    this.input.addEventListener(&apos;focus&apos;, this.focus);</div><div class="line">    this.input.addEventListener(&apos;blur&apos;, this.focus);</div><div class="line">  &#125;</div><div class="line">  focus = () =&gt; &#123;</div><div class="line">    this.setState((state) =&gt; (&#123; focused: !state.focused &#125;))</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;div className=&quot;App&quot;&gt;</div><div class="line">        &lt;div className=&quot;container&quot;&gt;</div><div class="line">          &lt;input</div><div class="line">            ref=&#123;input =&gt; this.input = input&#125;</div><div class="line">            className=&#123;[&apos;input&apos;, this.state.focused &amp;&amp; &apos;input-focused&apos;].join(&apos; &apos;)&#125;</div><div class="line">          /&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="input-js-demo"><a href="#input-js-demo" class="headerlink" title="input js demo"></a>input js demo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class App extends Component &#123;</div><div class="line">  state = &#123;</div><div class="line">    disabled: true,</div><div class="line">  &#125;</div><div class="line">  onChange = (e) =&gt; &#123;</div><div class="line">    const length = e.target.value.length;</div><div class="line">    if (length &gt;= 4) &#123;</div><div class="line">      this.setState(() =&gt; (&#123; disabled: false &#125;))</div><div class="line">    &#125; else if (!this.state.disabled) &#123;</div><div class="line">      this.setState(() =&gt; (&#123; disabled: true &#125;))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    const label = this.state.disabled ? &apos;Disabled&apos; : &apos;Submit&apos;;</div><div class="line">    return (</div><div class="line">      &lt;div className=&quot;App&quot;&gt;</div><div class="line">        &lt;button</div><div class="line">          style=&#123;Object.assign(&#123;&#125;, styles.button, !this.state.disabled &amp;&amp; styles.buttonEnabled)&#125;</div><div class="line">          disabled=&#123;this.state.disabled&#125;</div><div class="line">        &gt;&#123;label&#125;&lt;/button&gt;</div><div class="line">        &lt;input</div><div class="line">          style=&#123;styles.input&#125;</div><div class="line">          onChange=&#123;this.onChange&#125;</div><div class="line">        /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = &#123;</div><div class="line">  input: &#123;</div><div class="line">    width: 200,</div><div class="line">    outline: &apos;none&apos;,</div><div class="line">    fontSize: 20,</div><div class="line">    padding: 10,</div><div class="line">    border: &apos;none&apos;,</div><div class="line">    backgroundColor: &apos;#ddd&apos;,</div><div class="line">    marginTop: 10,</div><div class="line">  &#125;,</div><div class="line">  button: &#123;</div><div class="line">    width: 180,</div><div class="line">    height: 50,</div><div class="line">    border: &apos;none&apos;,</div><div class="line">    borderRadius: 4,</div><div class="line">    fontSize: 20,</div><div class="line">    cursor: &apos;pointer&apos;,</div><div class="line">    transition: &apos;.25s all&apos;,</div><div class="line">  &#125;,</div><div class="line">  buttonEnabled: &#123;</div><div class="line">    backgroundColor: &apos;#ffc107&apos;,</div><div class="line">    width: 220,</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="一些库和其他"><a href="#一些库和其他" class="headerlink" title="一些库和其他"></a>一些库和其他</h4><p><a href="https://medium.com/react-native-training/react-animations-in-depth-433e2b3f0e8e" rel="external nofollow noopener noreferrer" target="_blank">react-animations</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;React动画&quot;&gt;&lt;a href=&quot;#React动画&quot; class=&quot;headerlink&quot; title=&quot;React动画&quot;&gt;&lt;/a&gt;React动画&lt;/h1&gt;&lt;h3 id=&quot;input-css-demo&quot;&gt;&lt;a href=&quot;#input-css-demo&quot; cla
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="框架" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="React" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/React/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://wiki.haoqiao.me/tags/React/"/>
    
      <category term="技术栈" scheme="http://wiki.haoqiao.me/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>React-Es6对照表</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/React/React-ES6%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/框架/React/React-ES6对照表/</id>
    <published>2017-07-23T06:30:41.000Z</published>
    <updated>2017-07-23T06:36:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整理在 React 中 ES5、ES6+ 常见用法对照表。</p>
<h2 id="1-Modules"><a href="#1-Modules" class="headerlink" title="1. Modules"></a>1. Modules</h2><p>随着 Web 技术的进展，模组化开发已经成为一个重要课题。关于 JavaScript 模组化我们这边不详述，建议读者参考 <a href="http://huangxuan.me/js-module-7day/#/" rel="external nofollow noopener noreferrer" target="_blank">这份投影片</a> 和 <a href="http://justineo.github.io/singles/writing-modular-js/" rel="external nofollow noopener noreferrer" target="_blank">这篇文章</a>。</p>
<p>ES5 若使用 CommonJS 标准，一般使用 <code>require()</code> 用法引入模组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"><span class="keyword">var</span> MyComponent = <span class="built_in">require</span>(<span class="string">'./MyComponent'</span>);</div></pre></td></tr></table></figure>
<p>输出则是使用 <code>module.exports</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = MyComponent;</div></pre></td></tr></table></figure>
<p>ES6+ <code>import</code> 用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./MyComponent'</span>;</div></pre></td></tr></table></figure>
<p>输出则是使用 <code>export default</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-Classes"><a href="#2-Classes" class="headerlink" title="2. Classes"></a>2. Classes</h2><p>在 React 中组件（Component）是组成视觉页面的基础。在 ES5 中我们使用 <code>React.createClass()</code> 来建立 Component，而在 ES6+ 则是用 <a href="https://babeljs.io/docs/learn-es2015/#classes" rel="external nofollow noopener noreferrer" target="_blank">Classes</a> 继承 <code>React.Component</code> 来建立 Component。若是有写过 Java 等物件导向语言（OOP）的读者应该对于这种写法比较不陌生，不过要注意的是 JavaScript 仍是原型继承类型的物件导向程式语言，只是使用 <code>Classes</code> 让物件导向使用上更加直观。对于选择 <code>class</code> 使用上还有疑惑的读者建议可以阅读 <a href="https://toddmotto.com/react-create-class-versus-component/" rel="external nofollow noopener noreferrer" target="_blank">React.createClass versus extends React.Component</a> 这篇文章。</p>
<p>ES5 <code>React.createClass()</code> 用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Photo = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">images</span> <span class="attr">alt</span>=<span class="string">&#123;this.props.description&#125;</span> <span class="attr">src</span>=<span class="string">&#123;this.props.src&#125;</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">ReactDOM.render(<span class="tag">&lt;<span class="name">Photo</span> /&gt;</span>, document.getElementById('main'));</div></pre></td></tr></table></figure>
<p>ES6+ <code>class</code> 用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Photo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">images</span> <span class="attr">alt</span>=<span class="string">&#123;this.props.description&#125;</span> <span class="attr">src</span>=<span class="string">&#123;this.props.src&#125;</span> /&gt;</span>;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">ReactDOM.render(<span class="tag">&lt;<span class="name">Photo</span> /&gt;</span>, document.getElementById('main'));</div></pre></td></tr></table></figure>
<p>在 ES5 我们会在 <code>componentWillMount</code> 生命周期定义希望在 <code>render</code> 前执行，且只会执行一次的任务：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Photo = React.createClass(&#123;</div><div class="line">  <span class="attr">componentWillMount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在 ES6+ 则是定义在 <code>constructor</code> 建构子中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Photo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="comment">// 原本在 componentWillMount 操作的动作可以放在这</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-Method-definition"><a href="#3-Method-definition" class="headerlink" title="3. Method definition"></a>3. Method definition</h2><p>在 ES6 中我们使用 <code>Method</code> 可以忽略 <code>function</code> 和 <code>,</code>，使用上更为简洁！ES5 <code>React.createClass()</code> 用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Photo = React.createClass(&#123;</div><div class="line">  <span class="attr">handleClick</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;,</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>ES6+ class 用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Photo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  handleClick(e) &#123;&#125;</div><div class="line">  render() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-Property-initializers"><a href="#4-Property-initializers" class="headerlink" title="4. Property initializers"></a>4. Property initializers</h2><p>Component 属性值是资料传递重要的元素，在 ES5 中我们使用 <code>propTypes</code> 和  <code>getDefaultProps</code> 来定义属性（props）的预设值和型别：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Todo = React.createClass(&#123;</div><div class="line">  <span class="attr">getDefaultProps</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">checked</span>: <span class="literal">false</span>,</div><div class="line">      <span class="attr">maxLength</span>: <span class="number">10</span>,</div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">propTypes</span>: &#123;</div><div class="line">    <span class="attr">checked</span>: React.PropTypes.bool.isRequired,</div><div class="line">    <span class="attr">maxLength</span>: React.PropTypes.number.isRequired</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span>();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在 ES6+ 中我们则是参考 <a href="https://github.com/jeffmo/es-class-fields-and-static-properties" rel="external nofollow noopener noreferrer" target="_blank">ES7 property initializers</a> 使用 <code>class</code> 中的静态属性（static properties）来定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> defaultProps = &#123;</div><div class="line">    <span class="attr">checked</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">maxLength</span>: <span class="number">10</span>,</div><div class="line">  &#125;; <span class="comment">// 注意有分号</span></div><div class="line">  <span class="keyword">static</span> propTypes = &#123;</div><div class="line">    <span class="attr">checked</span>: React.PropTypes.bool.isRequired,</div><div class="line">    <span class="attr">maxLength</span>: React.PropTypes.number.isRequired</div><div class="line">  &#125;;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span>();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6+ 另外一种写法，可以留意一下，主要是看各团队喜好和规范，选择合适的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span></div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Todo.defaultProps = &#123;</div><div class="line">    checked: false,</div><div class="line">    maxLength: 10,</div><div class="line">&#125;;</div><div class="line">Todo.propTypes = &#123;</div><div class="line">    checked: React.PropTypes.bool.isRequired,</div><div class="line">    maxLength: React.PropTypes.number.isRequired,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="5-State"><a href="#5-State" class="headerlink" title="5. State"></a>5. State</h2><p>在 React 中 <code>Props</code> 和 <code>State</code> 是资料流传递的重要元素，不同的是 <code>state</code> 可更动，可以去执行一些运算。在 ES5 中我们使用 <code>getInitialState</code> 去初始化 <code>state</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Todo = React.createClass(&#123;</div><div class="line">    <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">maxLength</span>: <span class="keyword">this</span>.props.maxLength,</div><div class="line">        &#125;;</div><div class="line">    &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在 ES6+ 中我们初始化 <code>state</code> 有两种写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    state = &#123;</div><div class="line">        <span class="attr">maxLength</span>: <span class="keyword">this</span>.props.maxLength,</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外一种写法，使用在建构式初始化。比较推荐使用这种方式，方便做一些运算：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            <span class="attr">maxLength</span>: <span class="keyword">this</span>.props.maxLength,</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-Arrow-functions"><a href="#6-Arrow-functions" class="headerlink" title="6. Arrow functions"></a>6. Arrow functions</h2><p>在讲 <code>Arrow functions</code> 之前，我们先聊聊在 React 中 <code>this</code> 和它所代表的 <code>context</code>。在 ES5 中，我们使用 <code>React.createClass()</code> 来建立 Component，而在 <code>React.createClass()</code> 下，预设帮你绑定好 <code>method</code> 的 <code>this</code>，你毋须自行绑定。所以你可以看到像是下面的例子，<code>callback function</code> handleButtonClick 中的  <code>this</code> 是指到 component 的实例（instance），而非触发事件的物件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> TodoBtn = React.createClass(&#123;</div><div class="line">    <span class="attr">handleButtonClick</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="comment">// 此 this 指到 component 的实例（instance），而非 button</span></div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">showOptionsModal</span>: <span class="literal">true</span>&#125;);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">                <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleButtonClick&#125;</span>&gt;</span>&#123;this.props.label&#125;<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        )</div><div class="line">    &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>然而自动绑定这种方式反而会让人容易误解，所以在 ES6+ 推荐使用 <code>bind</code> 绑定 <code>this</code> 或使用 <code>Arrow functions</code>（它会绑定当前 <code>scope</code> 的 <code>this context</code>）两种方式，你可以参考下面例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoBtn</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span></div><div class="line">&#123;</div><div class="line">    handleButtonClick(e)&#123;</div><div class="line">        <span class="comment">// 确认绑定 this 指到 component instance</span></div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">toggle</span>: <span class="literal">true</span>&#125;);</div><div class="line">    &#125;</div><div class="line">    render()&#123;</div><div class="line">        <span class="comment">// 这边可以用 this.handleButtonClick.bind(this) 手动绑定或是 Arrow functions () =&gt; &#123;&#125; 用法</span></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">                <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleButtonClick.bind(this)&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;(e)</span>=&gt;</span> &#123;this.handleButtonClick(e)&#125; &#125;&gt;&#123;this.props.label&#125;<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        )</div><div class="line">    &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Arrow functions</code> 虽然一开始看起来有点怪异，但其实观念很简单：一个简化的函数。函数基本上就是参数（不一定要有参数）、表达式、回传值（也可能是回传 undefined）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// Arrow functions 的一些例子</div><div class="line">()=&gt;7</div><div class="line">e=&gt;e+2</div><div class="line">()=&gt;&#123;</div><div class="line">    alert(&apos;XD&apos;);</div><div class="line">&#125;</div><div class="line">(a,b)=&gt;a+b</div><div class="line">e=&gt;&#123;</div><div class="line">    if (e == 2)&#123;</div><div class="line">        return 2;</div><div class="line">    &#125;</div><div class="line">    return 100/e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过要注意的是无论是 <code>bind</code> 或是 <code>Arrow functions</code>，每次执行回传都是指到一个新的函数，若需要再调用到这个函数，请记得先把它存起来：</p>
<p>错误用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoBtn</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">    componentWillMount()&#123;</div><div class="line">        Btn.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleButtonClick.bind(<span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line">    componentDidmount()&#123;</div><div class="line">        Btn.removeEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleButtonClick.bind(<span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line">    onAppPaused(event)&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正确用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoBtn</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.handleButtonClick = <span class="keyword">this</span>.handleButtonClick.bind(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    componentWillMount()&#123;</div><div class="line">        Btn.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleButtonClick);</div><div class="line">    &#125;</div><div class="line">    componentDidMount()&#123;</div><div class="line">        Btn.removeEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleButtonClick);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更多 Arrows and Lexical This 特性可以<a href="https://babeljs.io/docs/learn-es2015/#arrows" rel="external nofollow noopener noreferrer" target="_blank">参考这个文件</a>。</p>
<h2 id="7-Dynamic-property-names-amp-template-strings"><a href="#7-Dynamic-property-names-amp-template-strings" class="headerlink" title="7. Dynamic property names &amp; template strings"></a>7. Dynamic property names &amp; template strings</h2><p>以前在 ES5 我们要动态设定属性名称时，往往需要多写几行程式码才能达到目标：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Todo = React.createClass(&#123;</div><div class="line">  <span class="attr">onChange</span>: <span class="function"><span class="keyword">function</span>(<span class="params">inputName, e</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> stateToSet = &#123;&#125;;</div><div class="line">    stateToSet[inputName + <span class="string">'Value'</span>] = e.target.value;</div><div class="line">    <span class="keyword">this</span>.setState(stateToSet);</div><div class="line">  &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>但在 ES6+中，透过 <a href="https://babeljs.io/blog/2015/06/07/react-on-es6-plus" rel="external nofollow noopener noreferrer" target="_blank">enhancements to object literals</a> 和 <a href="https://babeljs.io/docs/learn-es2015/#template-strings" rel="external nofollow noopener noreferrer" target="_blank">template strings</a> 可以轻松完成动态设定属性名称的任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Todo extends React.Component &#123;</div><div class="line">  onChange(inputName, e) &#123;</div><div class="line">    this.setState(&#123;</div><div class="line">      [`$&#123;inputName&#125;Value`]: e.target.value,</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Template Strings 是一种语法糖（syntactic sugar），方便我们组织字串（这边也用上 <code>let</code>、<code>const</code> 变数和常数宣告的方式，和 <code>var</code> 的 <code>function scope</code> 不同的是它们是属于 <code>block scope</code>，亦即生存域存在于 <code>{}</code> 间）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Interpolate variable bindings</span></div><div class="line"><span class="keyword">const</span> name = <span class="string">"Bob"</span>, <span class="keyword">let</span> = <span class="string">"today"</span>;</div><div class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span> \\ Hello Bob, how are you today?</div></pre></td></tr></table></figure>
<h2 id="8-Destructuring-amp-spread-attributes"><a href="#8-Destructuring-amp-spread-attributes" class="headerlink" title="8. Destructuring &amp; spread attributes"></a>8. Destructuring &amp; spread attributes</h2><p>在 React 的 Component 中，父组件利用 <code>props</code> 来传递资料到子组件是常见作法，然而我们有时会希望只传递部分资料，此时 ES6+ 中的 <a href="https://babeljs.io/docs/learn-es2015/#destructuring" rel="external nofollow noopener noreferrer" target="_blank">Destructuring</a> 和 <a href="https://facebook.github.io/react/docs/jsx-spread.html" rel="external nofollow noopener noreferrer" target="_blank">JSX 的 Spread Attributes
</a> ，<code>...</code> Spread Attributes 主要是用来迭代物件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">var</span> &#123;</div><div class="line">      className,</div><div class="line">      ...others,  <span class="comment">// ...others 包含 this.props 除了 className 外所有值。this.props = &#123;value: 'true', title: 'header', className: 'content'&#125;</span></div><div class="line">    &#125; = <span class="keyword">this</span>.props;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">TodoList</span> &#123;<span class="attr">...others</span>&#125; /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleLoadMoreClick&#125;</span>&gt;</span>Load more<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但使用上要注意的是若是有重复的属性值则以后来覆蓋，下面的例子中若 <code>...this.props</code>，有 <code>className</code>，则被后来的 <code>main</code> 所覆蓋：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div &#123;...this.props&#125; className=<span class="string">"main"</span>&gt;</div><div class="line">  …</div><div class="line">&lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure>
<p>而 <code>Destructuring</code> 也可以用在简化 <code>Module</code> 的引入上，这边我们先用 ES5 中引入方式来看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react-native'</span>);</div><div class="line"><span class="keyword">var</span> Component = React.component;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">Text</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> HelloWorld;</div></pre></td></tr></table></figure>
<p>以下 ES5 写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var React = require(&apos;react-native&apos;);</div><div class="line">var View = React.View;</div></pre></td></tr></table></figure>
<p>在 ES6+ 则可以直接使用 <code>Destructuring</code> 这种简化方式来引入模组中的组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 这边等于上面的写法</div><div class="line">var &#123; View &#125; = require(&apos;react-native&apos;);</div></pre></td></tr></table></figure>
<p>更进一步可以使用 <code>import</code> 语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123;</div><div class="line">  View,</div><div class="line">  Component,</div><div class="line">  Text,</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">Text</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> HelloWorld;</div></pre></td></tr></table></figure>
<h2 id="9-Mixins"><a href="#9-Mixins" class="headerlink" title="9. Mixins"></a>9. Mixins</h2><p>在 ES5 中，我们可以使用 <code>Mixins</code> 的方式去让不同的 Component 共用相似的功能，重用我们的程式码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> PureRenderMixin = <span class="built_in">require</span>(<span class="string">'react-addons-pure-render-mixin'</span>);</div><div class="line">React.createClass(&#123;</div><div class="line">  <span class="attr">mixins</span>: [PureRenderMixin],</div><div class="line"></div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;this.props.className&#125;</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>但由于官方不打算在 ES6+ 中继续推行 <code>Mixins</code>，若还是希望使用，可以参考看看<a href="https://www.npmjs.com/package/es6-class-mixin" rel="external nofollow noopener noreferrer" target="_blank">第三方套件</a>或是<a href="https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775" rel="external nofollow noopener noreferrer" target="_blank">这个文件的用法</a>。</p>
<h2 id="10-Default-Parameters"><a href="#10-Default-Parameters" class="headerlink" title="10. Default Parameters"></a>10. Default Parameters</h2><p>以前 ES5 我们函数要使用预设值需要这样使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> link = <span class="function"><span class="keyword">function</span> (<span class="params">height, color</span>) </span>&#123;  </div><div class="line">    <span class="keyword">var</span> height = height || <span class="number">50</span>;  </div><div class="line">    <span class="keyword">var</span> color = color || <span class="string">'red'</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在 ES6+ 的函数可以支援预设值，让程式码更为简洁：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> link = <span class="function"><span class="keyword">function</span>(<span class="params">height = <span class="number">50</span>, color = <span class="string">'red'</span></span>) </span>&#123;  </div><div class="line">  ...  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;整理在 React 中 ES5、ES6+ 常见用法对照表。&lt;/p&gt;
&lt;h2 id=&quot;1-Modules&quot;&gt;&lt;a href=&quot;#1-Modul
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="框架" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="React" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/React/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://wiki.haoqiao.me/tags/React/"/>
    
      <category term="表" scheme="http://wiki.haoqiao.me/tags/%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解React技术栈</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/React/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3React%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/框架/React/深入理解React技术栈/</id>
    <published>2017-07-23T06:30:41.000Z</published>
    <updated>2017-07-23T08:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><h3 id="父组件向子组件"><a href="#父组件向子组件" class="headerlink" title="父组件向子组件"></a>父组件向子组件</h3><p><code>Props</code></p>
<h3 id="子组件向父组件"><a href="#子组件向父组件" class="headerlink" title="子组件向父组件"></a>子组件向父组件</h3><ol>
<li>利用回调函数</li>
</ol>
<p>利用<code>this.props.onChange</code></p>
<ol>
<li>利用自定义事件机制</li>
</ol>
<h3 id="跨组件通信方式"><a href="#跨组件通信方式" class="headerlink" title="跨组件通信方式"></a>跨组件通信方式</h3><p>利用context -&gt; 利用redux</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;组件间通信&quot;&gt;&lt;a href=&quot;#组件间通信&quot; class=&quot;headerlink&quot; title=&quot;组件间通信&quot;&gt;&lt;/a&gt;组件间通信&lt;/h2&gt;&lt;h3 id=&quot;父组件向子组件&quot;&gt;&lt;a href=&quot;#父组件向子组件&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="框架" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="React" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/React/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://wiki.haoqiao.me/tags/React/"/>
    
      <category term="技术栈" scheme="http://wiki.haoqiao.me/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>this</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Ecmascript/this/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/基础/Ecmascript/this/</id>
    <published>2017-07-13T04:51:28.000Z</published>
    <updated>2017-07-13T06:12:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><blockquote>
<p>this总是指向函数的直接调用者（而非间接调用者）</p>
</blockquote>
<p>this在运行时绑定，上下文取决于函数调用时各种条件，和函数声明的位置没关系，只取决于函数的调用方式</p>
<h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><p>隐式绑定,对象属性引用链中只有最后一层在调用位置起作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function foo() &#123; console.log(this.a) &#125;</div><div class="line">var obj2 = &#123; a: 42, foo: foo &#125;</div><div class="line">var obj1 = &#123; a: 2, obj2: obj2 &#125;</div><div class="line">var obj3 = &#123; a: 233, foo: foo &#125;</div><div class="line">obj3.foo() //2333 obj1.obj2.foo() //42</div></pre></td></tr></table></figure>
<p>隐式丢失</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function foo() &#123; console.log(this.a) &#125;</div><div class="line"></div><div class="line">function doFoo(fn) &#123; fn() &#125;</div><div class="line">var obj3 = &#123; a: 233, foo: foo &#125;</div><div class="line">var a = &quot;windows&quot;</div><div class="line">doFoo(obj3.foo) // windows obj3.foo() //233</div></pre></td></tr></table></figure>
<p>显示绑定 call apply</p>
<p>new 绑定<br>创建一个新对象<br>新对象被执行[prototype]链接</p>
<p>新对象会绑定到函数调用的this<br>返回这个新对象</p>
<p>优先级从高到低：new,显示,隐式,默认</p>
<p>*在全局运行上下文中（在任何函数体外部），this指代全局对象</p>
<p><code>console.log(this===window);// true</code></p>
<h2 id="call与apply-bind的区别"><a href="#call与apply-bind的区别" class="headerlink" title="call与apply,bind的区别"></a>call与apply,bind的区别</h2><blockquote>
<p>call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向</p>
<p>call, apply方法区别是,从第二个参数起, call方法参数将依次传递给借用的方法作参数, 而apply直接将这些参数放到一个数组中再传递, 最后借用方法的参数列表是一样的.</p>
<p>在知道调用函数的参数数量时，使用 call() 的性能会优于 apply()。</p>
<p>主要在实现的过程中 apply() 需要完成额外的操作（判断第二个参数类数组的长度，etc.）更严谨的说法是，当有this指向或者执行参数时，call的性能要明显优于apply。</p>
</blockquote>
<p> bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this.</p>
<p>传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var foo = &#123; bar: 1, eventBind: function() &#123;</div><div class="line">   $(&apos;.someClass&apos;).on(&apos;click&apos;, function(event) &#123; </div><div class="line">    console.log(this.bar); &#125;.bind(this));</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var obj = &#123; x: 81, &#125;;</div><div class="line">var foo = &#123;</div><div class="line">    getX: function() &#123;</div><div class="line">        return this.x;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">console.log(foo.getX.bind(obj)()); //81</div><div class="line">console.log(foo.getX.call(obj)); //81 </div><div class="line">console.log(foo.getX.apply(obj)); //81</div></pre></td></tr></table></figure>
<ul>
<li>实现BIND函数</li>
</ul>
<p>基本原理就是使用 apply() 与闭包，返回包含 apply() 的闭包使得 apply() 绑定指定作用域，但并未执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Function.prototype.bind = Function.prototype.bind || function (context) &#123;</div><div class="line">  var self = this;</div><div class="line">  return function () &#123;</div><div class="line">    return self.apply(context, arguments);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前置&quot;&gt;&lt;a href=&quot;#前置&quot; class=&quot;headerlink&quot; title=&quot;前置&quot;&gt;&lt;/a&gt;前置&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;this总是指向函数的直接调用者（而非间接调用者）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;this在运行时绑定
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Ecmascript" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Ecmascript/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Javascript" scheme="http://wiki.haoqiao.me/tags/Javascript/"/>
    
      <category term="this" scheme="http://wiki.haoqiao.me/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Ecmascript/%E9%97%AD%E5%8C%85/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/基础/Ecmascript/闭包/</id>
    <published>2017-07-13T04:51:28.000Z</published>
    <updated>2017-07-13T06:15:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><code>ES5中JS没有块作用域，只有函数作用域</code></p>
<blockquote>
<p>函数作用域的含义是指，属于这个函数内部全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用。)<br>在任意代码片段外部添加包装函数，可以将内部的变量和函数定义”隐藏起来”,外部作用域无法访问包装函数内部的任何内容</p>
</blockquote>
<p>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的</p>
<p>每一段javascript代码(全局代码或函数)都有一个与之关联的作用域链，这个作用域链是一个对象列表或者链条，这组对象定义了这段代码作用域中的变量。对一个对象查找x的属性，如果没有继续在作用域链里的列表里一个个找，如果没找到抛出一个引用错误异常</p>
<p>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找， 直至全局函数，这种组织形式就是作用域链。</p>
<p>javascript只有函数作用域，它的含义是属于函数内部全部变量都可以在整个函数的范围内使用及复用。 每一段javascript代码(全局代码或函数)都有一个与之关联的作用域链，这个作用域链是一个对象列表或者链条，它不仅包含当前作用域还包含上层作用域，这组对象定义了这段代码作用域中的变量。对一个对象查找x的属性，如果没有继续在作用域链里的列表里一个个找，如果没找到抛出一个引用错误异常 作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><code>闭包是指有权访问函数作用域的变量的函数</code></p>
<blockquote>
<p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时产生了闭包。</p>
</blockquote>
<p>javascript的函数可以嵌套在其他函数中定义，它们可以通过访问它们被定义时所处的作用域中的任何变量。这就构成了闭包。</p>
<p>javascript用作用域链来实现闭包,作用域链由执行环境维护</p>
<blockquote>
<p>当一个函数执行后，通常会被垃圾回收器将内部作用域销毁。但是该内部中函数引用产生的闭包阻止了回收，使得该作用域一直存活，供内部函数随时引用</p>
<p>创建闭包的方式，就是在一个函数内部创建另一个函数</p>
<p>利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部</p>
<p>只要使用了回调函数，就是在使用闭包</p>
</blockquote>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><p>函数嵌套函数</p>
</li>
<li><p>函数内部可以引用外部的参数和变量</p>
</li>
<li><p>参数和变量不会被垃圾回收机制回收</p>
</li>
</ul>
<h2 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h2><p>在循环中尽管函数在各个迭代中被定义，但是它们被封闭在一个共享的全局作用域中。因此共享一个变量I</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i) &#125;, i * <span class="number">1000</span>)</div><div class="line">&#125;</div><div class="line"> <span class="comment">// 每隔一秒输出五次6</span></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="直接用立即表达式包装创建作用域-是不够的"><a href="#直接用立即表达式包装创建作用域-是不够的" class="headerlink" title="直接用立即表达式包装创建作用域 是不够的"></a>直接用立即表达式包装创建作用域 是不够的</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">     (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">         setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i) &#125;, i * <span class="number">1000</span>)</div><div class="line">     &#125;)()</div><div class="line"> &#125; <span class="comment">// 每隔一秒输出五次6</span></div><div class="line"></div></pre></td></tr></table></figure>
<h3 id="在立即表达式中需要有自己的变量，来保存迭代中的值"><a href="#在立即表达式中需要有自己的变量，来保存迭代中的值" class="headerlink" title="在立即表达式中需要有自己的变量，来保存迭代中的值"></a>在立即表达式中需要有自己的变量，来保存迭代中的值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">     (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">         <span class="keyword">var</span> j = i</div><div class="line">         setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(j) &#125;, j * <span class="number">1000</span>)</div><div class="line">     &#125;)()</div><div class="line"> &#125;<span class="comment">// 每隔一秒输出1,2,3,4,5</span></div><div class="line"></div><div class="line">   </div><div class="line"></div><div class="line"> </div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;  <span class="comment">// j = i</span></div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, j);</div><div class="line">        &#125;, <span class="number">1000</span>);</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0 1 2 3 4</span></div><div class="line"></div><div class="line"></div><div class="line">利用 JS 中基本类型（Primitive Type）的参数传递是按值传递（Pass by Value）的特征</div><div class="line"></div><div class="line"><span class="keyword">var</span> output = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    output(i);  <span class="comment">// 这里传过去的 i 值被复制了</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> tasks = []; <span class="comment">// 这里存放异步操作的 Promise</span></div><div class="line"><span class="keyword">const</span> output = <span class="function">(<span class="params">i</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line">        resolve();</div><div class="line">    &#125;, <span class="number">1000</span> * i);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 生成全部的异步操作</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    tasks.push(output(i));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 异步操作完成之后，输出最后的 i</span></div><div class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">&#125;);</div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="封装！设计私有的方法和变量"><a href="#封装！设计私有的方法和变量" class="headerlink" title="封装！设计私有的方法和变量"></a>封装！设计私有的方法和变量</h3><p>全局变量可能会造成命名冲突，使用闭包不用担心这个问题，因为它是私有化，加强了封装性，这样保护变量的安全</p>
<h3 id="实现模块模式"><a href="#实现模块模式" class="headerlink" title="实现模块模式"></a>实现模块模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">2</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(a) &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">something</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"2333"</span>) &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> &#123; <span class="attr">bar</span>: bar, <span class="attr">something</span>: something &#125; </div><div class="line">&#125;</div><div class="line">    <span class="keyword">var</span> baz = foo()</div><div class="line">    baz.something() <span class="comment">//2333</span></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="缺点与应用"><a href="#缺点与应用" class="headerlink" title="缺点与应用"></a>缺点与应用</h2><p>由于它是驻留在内存中，会增大内存使用量，使用不当很容易造成内存泄露，降低程序的性能</p>
<p>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">var</span> arr = [];</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</div><div class="line">         arr.push((<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">             <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                 <span class="keyword">return</span> n * n;</div><div class="line">             &#125;</div><div class="line">         &#125;)(i));</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> arr;</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">var</span> results = count();</div><div class="line"> <span class="keyword">var</span> f1 = results[<span class="number">0</span>];</div><div class="line"> <span class="keyword">var</span> f2 = results[<span class="number">1</span>];</div><div class="line"> <span class="keyword">var</span> f3 = results[<span class="number">2</span>];</div><div class="line"> f1(); <span class="comment">// 1 </span></div><div class="line"> f2(); <span class="comment">// 4 </span></div><div class="line"> f3(); <span class="comment">// 9</span></div><div class="line"></div></pre></td></tr></table></figure>
<h3 id="手写once函数，传入函数参数只执行一次（闭包）"><a href="#手写once函数，传入函数参数只执行一次（闭包）" class="headerlink" title="手写once函数，传入函数参数只执行一次（闭包）"></a>手写once函数，传入函数参数只执行一次（闭包）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> singleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//缓存实例 </span></div><div class="line">    <span class="keyword">var</span> instance;</div><div class="line">    <span class="keyword">var</span> randomNum = <span class="built_in">Math</span>.random(); <span class="comment">//单例初始化代码  </span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//如果没有初始化，则初始化，否则返回已经执行的结果。 </span></div><div class="line">        <span class="keyword">return</span> randomNum;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!instance) &#123; instance = init(); &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;)()</div><div class="line"><span class="built_in">console</span>.log(singleton);</div><div class="line"><span class="built_in">console</span>.log(singleton);</div><div class="line"></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ES5中JS没有块作用域，只有函数作用域&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数作用域的含义是指，属
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Ecmascript" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Ecmascript/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Javascript" scheme="http://wiki.haoqiao.me/tags/Javascript/"/>
    
      <category term="闭包" scheme="http://wiki.haoqiao.me/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>ES6</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Ecmascript/ES6/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/基础/Ecmascript/ES6/</id>
    <published>2017-07-13T04:51:28.000Z</published>
    <updated>2017-07-13T06:09:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><blockquote>
<p>它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）<br>一是为各种数据结构，提供一个统一的、简便的访问接口；<br>二是使得数据结构的成员能够按某种次序排列；<br>三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费</p>
</blockquote>
<p>Iterator的遍历过程是这样的。<br>   （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。<br>   （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。<br>  （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。<br>  （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>]);  </div><div class="line"></div><div class="line">       it.next() <span class="comment">// &#123; value: "a", done: false &#125;  </span></div><div class="line">       it.next() <span class="comment">// &#123; value: "b", done: false &#125;  </span></div><div class="line">       it.next() <span class="comment">// &#123; value: undefined, done: true &#125;  </span></div><div class="line">       <span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;  </div><div class="line">         <span class="keyword">var</span> nextIndex = <span class="number">0</span>;  </div><div class="line">         <span class="keyword">return</span> &#123;  </div><div class="line">           <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">             <span class="keyword">return</span> nextIndex &lt; array.length ?  </div><div class="line">               &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :  </div><div class="line">               &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;  </div><div class="line">           &#125;  </div><div class="line">         &#125;;  </div><div class="line">       &#125;</div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>let可以将变量绑定到所在的任意作用域{…}中,它为声明的变量隐式劫持了所在的块作用域，也就是花括号中的块，每进入一次花括号就生成了一个块级域</p>
<p> let 的暂存死区与错误</p>
<ul>
<li>重复Let定义同一个变量会抛出错误</li>
<li>在let定义之前引用会抛出引用错误<br>let的作用域是块，而var的作用域是函数</li>
</ul>
<p>*TDZ (暂时性死区)。指代码中的变量还没有初始化而不能被引用的情况。</p>
<pre><code>* {  
  a = 2; ERROR  
  let a;  

  }
</code></pre><ul>
<li>原理：var 会变量提升，let 不会。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;  </div><div class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;  </div><div class="line">      <span class="keyword">var</span> x = <span class="number">2</span>;  <span class="comment">// 同样的变量!  </span></div><div class="line">      <span class="built_in">console</span>.log(x);  <span class="comment">// 2  </span></div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2  </span></div><div class="line">  &#125;  </div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;  </div><div class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;  </div><div class="line">      <span class="keyword">let</span> x = <span class="number">2</span>;  <span class="comment">// 不同的变量  </span></div><div class="line">      <span class="built_in">console</span>.log(x);  <span class="comment">// 2  </span></div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 1  </span></div><div class="line">  &#125;</div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><blockquote>
<p>用于将函数内部的<code>this</code>延伸到上一层作用域中。即上一次的上下文会穿透到内层。  </p>
<p>箭头对上下文的绑定是强制的，无法通过apply或call方法改变。</p>
<p>使用了块语句的箭头函数不会自动返回值，你需要使用 return 语句将所需值返回</p>
</blockquote>
<h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><p><code>Symbol 是JavaScript ES6 的原始数据类型</code></p>
<p><code>它能避免命名冲突的风险</code></p>
<p>调用Symbol()创建一个新的symbol，它的值与其它任何值皆不相等</p>
<p>JavaScript中最常见的对象检查的特性会忽略symbol键。例如，for-in循环只会遍历对象的字符串键，symbol键直接跳过，Object.keys(obj)和Object.getOwnPropertyNames(obj)也是一样。但是symbols也不完全是私有的：用新的APIObject.getOwnPropertySymbols(obj)就可以列出对象的symbol键。另一个新的API，Reflect.ownKeys(obj)，会同时返回字符串键和symbol键</p>
<h2 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h2><ul>
<li>for-of 循环语句通过方法调用来遍历各种 集合。数组、Maps 对象、Sets 对象</li>
<li>不会遍历自定义属性，不会遍历普通对象</li>
<li>可以正确响应 break、continue 和 return 语句</li>
<li>支持类数组遍历, 支持字符串字符遍历</li>
</ul>
<h2 id="generators"><a href="#generators" class="headerlink" title="generators"></a>generators</h2><ul>
<li>Generator 函数是一个状态机，封装了多个内部状态，执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态</li>
<li>两个特征。<br>一是，function关键字与函数名之间有一个星号；<br>二是，函数体内部使用yield语句，定义不同的内部状态（yield在英语里的意思就是“产出”）</li>
</ul>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息</p>
<p>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。</p>
<p>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变</p>
<p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的</p>
<p>Promise新建后就会立即执行</p>
<p>Promise是一个对象，充当异步操作和回调函数之间的中介。</p>
<pre><code>* var promise = new Promise(function(resolve, reject) {  
    // 异步操作的代码  

    if (/* 异步操作成功 */){  
      resolve(value);  
    } else {  
      reject(error);  
    }  
  });
</code></pre><ul>
<li>每一个异步函数立刻返回一个Promise对象，每个对象指定回调函数，在异步任务完成后调用。</li>
<li><p>Promise有三种状态:pending 未完成,resolved 已完成,rejected 失败。最终状态只有成功和失败。通过then方法添加两个回调函数处理resolved状态和rejected状态，一旦状态改变就调用。</p>
<ul>
<li>po.then(function(value) {<br>  // success<br>}, function(value) {<br>  // failure<br>});</li>
</ul>
</li>
<li><p>优点在于流程清晰，让回调函数变成规范链式写法，可以为多个异步操作指定同一个回调，可以为多个回调指定同一个错误处理方法。如果一个任务已经完成，再往上添加回调，会立刻执行。无须担心错过某个事件。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;  </div><div class="line">    <span class="comment">// ... some code  </span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;  </div><div class="line">      resolve(value);  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">      reject(error);  </div><div class="line">    &#125;  </div><div class="line">  &#125;);  </div><div class="line"></div><div class="line">  promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;  </div><div class="line">    <span class="comment">// success  </span></div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;  </div><div class="line">    <span class="comment">// failure  </span></div><div class="line">  &#125;);  </div><div class="line"></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  </div><div class="line">      setTimeout(resolve, ms, <span class="string">'done'</span>);  </div><div class="line">    &#125;);  </div><div class="line">  &#125;  </div><div class="line"></div><div class="line">  timeout(<span class="number">100</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;  </div><div class="line">    <span class="built_in">console</span>.log(value);  </div><div class="line">  &#125;);</div><div class="line"></div><div class="line">* <span class="built_in">Promise</span>对象实现的Ajax操作</div><div class="line">     * <span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;  </div><div class="line">         <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;  </div><div class="line">           <span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();  </div><div class="line">           client.open(<span class="string">"GET"</span>, url);  </div><div class="line">           client.onreadystatechange = handler;  </div><div class="line">           client.responseType = <span class="string">"json"</span>;  </div><div class="line">           client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);  </div><div class="line">           client.send();  </div><div class="line"></div><div class="line">           <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">             <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;  </div><div class="line">               <span class="keyword">return</span>;  </div><div class="line">             &#125;  </div><div class="line">             <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;  </div><div class="line">               resolve(<span class="keyword">this</span>.response);  </div><div class="line">             &#125; <span class="keyword">else</span> &#123;  </div><div class="line">               reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));  </div><div class="line">             &#125;  </div><div class="line">           &#125;;  </div><div class="line">         &#125;);  </div><div class="line"></div><div class="line">         <span class="keyword">return</span> promise;  </div><div class="line">       &#125;;  </div><div class="line"></div><div class="line">       getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;  </div><div class="line">         <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);  </div><div class="line">       &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;  </div><div class="line">         <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);  </div><div class="line">       &#125;);</div><div class="line"> </div><div class="line">* 用法</div><div class="line">     * 加载图片</div><div class="line">          * <span class="keyword">var</span> preloadImage = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;  </div><div class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;  </div><div class="line">                <span class="keyword">var</span> image = <span class="keyword">new</span> Image();  </div><div class="line">                image.onload  = resolve;  </div><div class="line">                image.onerror = reject;  </div><div class="line">                image.src = path;  </div><div class="line">              &#125;);  </div><div class="line">            &#125;;</div><div class="line">     * Ajax</div><div class="line">          * <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">term</span>) </span>&#123;  </div><div class="line">              <span class="keyword">var</span> url = <span class="string">'http://example.com/search?q='</span> + term;  </div><div class="line">              <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();  </div><div class="line">              <span class="keyword">var</span> result;  </div><div class="line"></div><div class="line">              <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;  </div><div class="line">                xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);  </div><div class="line">                xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;  </div><div class="line">                  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;  </div><div class="line">                    result = <span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.responseText);  </div><div class="line">                    resolve(result);  </div><div class="line">                  &#125;  </div><div class="line">                &#125;;  </div><div class="line">                xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;  </div><div class="line">                  reject(e);  </div><div class="line">                &#125;;  </div><div class="line">                xhr.send();  </div><div class="line">              &#125;);  </div><div class="line"></div><div class="line">              <span class="keyword">return</span> p;  </div><div class="line">            &#125;  </div><div class="line"></div><div class="line">            search(<span class="string">"Hello World"</span>).then(<span class="built_in">console</span>.log, <span class="built_in">console</span>.error);</div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><blockquote>
<p>模板字符串中嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性还能调用函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var x = 1;  </div><div class="line">var y = 2;  </div><div class="line"></div><div class="line">`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`  </div><div class="line">       // &quot;1 + 2 = 3&quot;  </div><div class="line"></div><div class="line">`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`  </div><div class="line">       // &quot;1 + 4 = 5&quot;  </div><div class="line"></div><div class="line">var obj = &#123;x: 1, y: 2&#125;;  </div><div class="line">`$&#123;obj.x + obj.y&#125;`  </div><div class="line">       // 3  </div><div class="line"></div><div class="line">function fn() &#123;  </div><div class="line">         return &quot;Hello World&quot;;  </div><div class="line">       &#125;  </div><div class="line"></div><div class="line">`foo $&#123;fn()&#125; bar`  </div><div class="line">// foo Hello World bar</div></pre></td></tr></table></figure>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;  </div><div class="line">    <span class="keyword">var</span> b = <span class="number">10</span>;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings, ...values</span>) </span>&#123;  </div><div class="line">      <span class="built_in">console</span>.log(strings[<span class="number">0</span>]); <span class="comment">// "Hello "  </span></div><div class="line">      <span class="built_in">console</span>.log(strings[<span class="number">1</span>]); <span class="comment">// " world "  </span></div><div class="line">      <span class="built_in">console</span>.log(strings[<span class="number">2</span>]); <span class="comment">// ""  </span></div><div class="line">      <span class="built_in">console</span>.log(values[<span class="number">0</span>]);  <span class="comment">// 15  </span></div><div class="line">      <span class="built_in">console</span>.log(values[<span class="number">1</span>]);  <span class="comment">// 50  </span></div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="string">"Bazinga!"</span>;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;  </div><div class="line">    <span class="comment">// "Bazinga!"</span></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><blockquote>
<p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>
</blockquote>
<p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    * <span class="built_in">Array</span>.from(arrayLike,x =&gt;x *x);<span class="comment">// 等同于   </span></div><div class="line"></div><div class="line">       <span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span>x *x);  </div><div class="line"></div><div class="line">       <span class="built_in">Array</span>.from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],(x)=&gt;x *x)<span class="comment">// [1, 4, 9]</span></div><div class="line"></div><div class="line">* <span class="keyword">let</span> arrayLike =&#123;<span class="string">'0'</span>:<span class="string">'a'</span>,<span class="string">'1'</span>:<span class="string">'b'</span>,<span class="string">'2'</span>:<span class="string">'c'</span>,<span class="attr">length</span>:<span class="number">3</span>&#125;;<span class="comment">// ES5的写法   </span></div><div class="line">  <span class="keyword">var</span> arr1 =[].slice.call(arrayLike);<span class="comment">// ['a', 'b', 'c'] // ES6的写法</span></div><div class="line">   </div><div class="line">  <span class="keyword">let</span> arr2 =<span class="built_in">Array</span>.from(arrayLike);<span class="comment">// ['a', 'b', 'c']</span></div><div class="line">* 只要是部署了Iterator接口的数据结构，<span class="built_in">Array</span>.from都能将其转为数组</div><div class="line">* 如果参数是一个真正的数组，<span class="built_in">Array</span>.from会返回一个一模一样的新数组,而且这两个数组不会引用同一份数据。a != b</div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><blockquote>
<p>Array.of方法用于将一组值，转换为数组</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>,<span class="number">11</span>,<span class="number">8</span>)<span class="comment">// [3,11,8]   </span></div><div class="line"></div><div class="line">      <span class="built_in">Array</span>.of(<span class="number">3</span>)<span class="comment">// [3]   </span></div><div class="line"></div><div class="line">      <span class="built_in">Array</span>.of(<span class="number">3</span>).length<span class="comment">// 1</span></div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>)</span>&#123;  </div><div class="line">   <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);  </div><div class="line"> &#125;</div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="数组实例的find-和findIndex"><a href="#数组实例的find-和findIndex" class="headerlink" title="数组实例的find()和findIndex()"></a>数组实例的find()和findIndex()</h2><ul>
<li><p>find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组</p>
</li>
<li><p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1</p>
</li>
<li><p>indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* [<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)  </div><div class="line">    <span class="comment">// -1  </span></div><div class="line"></div><div class="line">    [<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))  </div><div class="line">    <span class="comment">// 0</span></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="entries-，keys-和values"><a href="#entries-，keys-和values" class="headerlink" title="entries()，keys()和values()"></a>entries()，keys()和values()</h2><blockquote>
<p>keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* <span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;  </div><div class="line">        <span class="built_in">console</span>.log(index);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">// 0  </span></div><div class="line">      <span class="comment">// 1  </span></div><div class="line"></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;  </div><div class="line">        <span class="built_in">console</span>.log(elem);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">// 'a'  </span></div><div class="line">      <span class="comment">// 'b'  </span></div><div class="line"></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;  </div><div class="line">        <span class="built_in">console</span>.log(index, elem);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">// 0 "a"  </span></div><div class="line">      <span class="comment">// 1 "b"</span></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><blockquote>
<p>用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* <span class="comment">// arguments变量的写法  </span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();  </div><div class="line">  &#125;  </div><div class="line"></div><div class="line">  <span class="comment">// rest参数的写法  </span></div><div class="line">  <span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</div><div class="line">* <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;  </div><div class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;  </div><div class="line">      array.push(item);  </div><div class="line">      <span class="built_in">console</span>.log(item);  </div><div class="line">    &#125;);  </div><div class="line">  &#125;  </div><div class="line"></div><div class="line">  <span class="keyword">var</span> a = [];  </div><div class="line">  push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="扩展运算符-…"><a href="#扩展运算符-…" class="headerlink" title="扩展运算符(…)"></a>扩展运算符(…)</h2><blockquote>
<p>rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，用于展开数组。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">     * <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;  </div><div class="line">         array.push(...items);  </div><div class="line">       &#125;  </div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;  </div><div class="line">         <span class="keyword">return</span> x + y;  </div><div class="line">       &#125;  </div><div class="line"></div><div class="line">       <span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];  </div><div class="line">       add(...numbers) <span class="comment">// 42</span></div><div class="line">* 替代数组的apply方法</div><div class="line">     * <span class="comment">// ES5的写法  </span></div><div class="line">       <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;  </div><div class="line">         <span class="comment">// ...  </span></div><div class="line">       &#125;  </div><div class="line">       <span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];  </div><div class="line">       f.apply(<span class="literal">null</span>, args);  </div><div class="line"></div><div class="line">       <span class="comment">// ES6的写法  </span></div><div class="line">       <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;  </div><div class="line">         <span class="comment">// ...  </span></div><div class="line">       &#125;  </div><div class="line">       <span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];  </div><div class="line">       f(...args);</div><div class="line">     * <span class="comment">// ES5的写法  </span></div><div class="line">       <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])  </div><div class="line"></div><div class="line">       <span class="comment">// ES6的写法  </span></div><div class="line">       <span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])  </div><div class="line"></div><div class="line">       <span class="comment">// 等同于  </span></div><div class="line">       <span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</div><div class="line">     * <span class="comment">// ES5的写法  </span></div><div class="line">       <span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];  </div><div class="line">       <span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];  </div><div class="line">       <span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);  </div><div class="line"></div><div class="line">       <span class="comment">// ES6的写法  </span></div><div class="line">       <span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];  </div><div class="line">       <span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];  </div><div class="line">       arr1.push(...arr2);</div><div class="line">* 合并数组</div><div class="line">     * <span class="comment">// ES5  </span></div><div class="line">       [<span class="number">1</span>, <span class="number">2</span>].concat(more)  </div><div class="line">       <span class="comment">// ES6  </span></div><div class="line">       [<span class="number">1</span>, <span class="number">2</span>, ...more]  </div><div class="line"></div><div class="line">       <span class="keyword">var</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];  </div><div class="line">       <span class="keyword">var</span> arr2 = [<span class="string">'c'</span>];  </div><div class="line">       <span class="keyword">var</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];  </div><div class="line"></div><div class="line">       <span class="comment">// ES5的合并数组  </span></div><div class="line">       arr1.concat(arr2, arr3);  </div><div class="line">       <span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]  </span></div><div class="line"></div><div class="line">       <span class="comment">// ES6的合并数组  </span></div><div class="line">       [...arr1, ...arr2, ...arr3]  </div><div class="line">       <span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p>函数的name属性，返回该函数的函数名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function foo()&#123;&#125;foo.name// &quot;foo&quot;</div></pre></td></tr></table></figure>
<h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><blockquote>
<p>它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* Object.is(&apos;foo&apos;, &apos;foo&apos;)  </div><div class="line">    // true  </div><div class="line">    Object.is(&#123;&#125;, &#123;&#125;)  </div><div class="line">    // false</div></pre></td></tr></table></figure>
<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><blockquote>
<p>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</p>
<p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* <span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;  </div><div class="line"></div><div class="line">    <span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;  </div><div class="line">    <span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;  </div><div class="line"></div><div class="line">    <span class="built_in">Object</span>.assign(target, source1, source2);  </div><div class="line">    target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="属性遍历"><a href="#属性遍历" class="headerlink" title="属性遍历"></a>属性遍历</h2><ul>
<li>for…in<ul>
<li>for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）</li>
</ul>
</li>
<li>Object.keys(obj)<ul>
<li>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）</li>
</ul>
</li>
<li>Object.getOwnPropertyNames(obj)<ul>
<li>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）</li>
</ul>
</li>
<li>Object.getOwnPropertySymbols(obj)<ul>
<li>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性</li>
</ul>
</li>
<li>Reflect.ownKeys(obj)<ul>
<li>Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举</li>
</ul>
</li>
</ul>
<h2 id="proto属性"><a href="#proto属性" class="headerlink" title="proto属性"></a><strong>proto</strong>属性</h2><ul>
<li><p>用来读取或设置当前对象的prototype对象</p>
</li>
<li><p><strong>proto</strong>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署</p>
</li>
<li><p><strong>proto</strong>调用的是Object.prototype.<strong>proto</strong></p>
</li>
</ul>
<h2 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h2><blockquote>
<p>Object.setPrototypeOf方法的作用与<strong>proto</strong>相同，用来设置一个对象的prototype对象，返回参数对象本身</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* let proto = &#123;&#125;;  </div><div class="line">       let obj = &#123; x: 10 &#125;;  </div><div class="line">       Object.setPrototypeOf(obj, proto);  </div><div class="line"></div><div class="line">       proto.y = 20;  </div><div class="line">       proto.z = 40;  </div><div class="line"></div><div class="line">       obj.x // 10  </div><div class="line">       obj.y // 20  </div><div class="line">       obj.z // 40</div></pre></td></tr></table></figure>
<h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p>用于读取一个对象的原型对象</p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><ul>
<li>解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种 变量</li>
<li>[ variable1, variable2, …, variableN ] = array;</li>
<li>解构赋值允许指定默认值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let[x,y =&apos;b&apos;]=[&apos;a&apos;] // x=&apos;a&apos;, y=&apos;b&apos;</div><div class="line">let[x,y =&apos;b&apos;] = [&apos;a&apos;,undefined];// x=&apos;a&apos;, y=&apos;b&apos;</div></pre></td></tr></table></figure>
<ul>
<li>对象的结构赋值</li>
</ul>
<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* <span class="keyword">var</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];  </div><div class="line">   <span class="built_in">console</span>.log(foo);  </div><div class="line">   <span class="comment">// 1  </span></div><div class="line">   <span class="built_in">console</span>.log(bar);  </div><div class="line">   <span class="comment">// 2  </span></div><div class="line">   <span class="built_in">console</span>.log(baz);  </div><div class="line">   <span class="comment">// 3</span></div><div class="line">* <span class="keyword">var</span> [,,third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];  </div><div class="line">   <span class="built_in">console</span>.log(third);  </div><div class="line">   <span class="comment">// "baz"</span></div><div class="line">* <span class="keyword">var</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];   </div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(tail); <span class="comment">// [2, 3, 4]</span></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a>Set 和 Map</h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<ul>
<li>方法<ul>
<li>add(value)：添加某个值，返回Set结构本身</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值</li>
</ul>
</li>
<li>遍历<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();  </div><div class="line"></div><div class="line">      [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));  </div><div class="line"></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;  </div><div class="line">        <span class="built_in">console</span>.log(i);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">// 2 3 5 4  </span></div><div class="line">      <span class="comment">// 例一  </span></div><div class="line">      <span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);  </div><div class="line">      [...set]  </div><div class="line">      <span class="comment">// [1, 2, 3, 4]  </span></div><div class="line"></div><div class="line">      <span class="comment">// 例二  </span></div><div class="line">      <span class="keyword">var</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);  </div><div class="line">      items.size <span class="comment">// 5  </span></div><div class="line"></div><div class="line">      <span class="comment">// 例三  </span></div><div class="line">      <span class="function"><span class="keyword">function</span> <span class="title">divs</span> (<span class="params"></span>) </span>&#123;  </div><div class="line">        <span class="keyword">return</span> [...document.querySelectorAll(<span class="string">'div'</span>)];  </div><div class="line">      &#125;  </div><div class="line"></div><div class="line">      <span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(divs());  </div><div class="line">      set.size <span class="comment">// 56  </span></div><div class="line"></div><div class="line">      <span class="comment">// 类似于  </span></div><div class="line">      divs().forEach(<span class="function"><span class="params">div</span> =&gt;</span> set.add(div));  </div><div class="line">      set.size <span class="comment">// 56</span></div><div class="line"></div></pre></td></tr></table></figure>
<blockquote>
<p>ES6提供了Map数据结构。<br>它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。<br>也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();  </div><div class="line">      <span class="keyword">var</span> o = &#123;<span class="attr">p</span>: <span class="string">'Hello World'</span>&#125;;  </div><div class="line"></div><div class="line">      m.set(o, <span class="string">'content'</span>)  </div><div class="line">      m.get(o) <span class="comment">// "content"  </span></div><div class="line"></div><div class="line">      m.has(o) <span class="comment">// true  </span></div><div class="line">      m.delete(o) <span class="comment">// true  </span></div><div class="line">      m.has(o) <span class="comment">// false  </span></div><div class="line"></div><div class="line">      <span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([  </div><div class="line">        [<span class="string">'name'</span>, <span class="string">'张三'</span>],  </div><div class="line">        [<span class="string">'title'</span>, <span class="string">'Author'</span>]  </div><div class="line">      ]);  </div><div class="line"></div><div class="line">      map.size <span class="comment">// 2  </span></div><div class="line">      map.has(<span class="string">'name'</span>) <span class="comment">// true  </span></div><div class="line">      map.get(<span class="string">'name'</span>) <span class="comment">// "张三"  </span></div><div class="line">      map.has(<span class="string">'title'</span>) <span class="comment">// true  </span></div><div class="line">      map.get(<span class="string">'title'</span>) <span class="comment">// "Author"</span></div><div class="line"></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Iterator&quot;&gt;&lt;a href=&quot;#Iterator&quot; class=&quot;headerlink&quot; title=&quot;Iterator&quot;&gt;&lt;/a&gt;Iterator&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Ecmascript" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Ecmascript/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Javascript" scheme="http://wiki.haoqiao.me/tags/Javascript/"/>
    
      <category term="ES6" scheme="http://wiki.haoqiao.me/tags/ES6/"/>
    
  </entry>
  
</feed>
