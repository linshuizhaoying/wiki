<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>临水照影&#39;s Wiki</title>
  <subtitle>我们需要不断回顾才能真正记忆。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wiki.haoqiao.me/"/>
  <updated>2018-04-15T00:44:56.000Z</updated>
  <id>http://wiki.haoqiao.me/</id>
  
  <author>
    <name>linshuizhaoying</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/React/react/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/框架/React/react/</id>
    <published>2018-03-28T00:35:28.000Z</published>
    <updated>2018-04-15T00:44:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-组件的生命周期、通信方式"><a href="#React-组件的生命周期、通信方式" class="headerlink" title="React 组件的生命周期、通信方式"></a>React 组件的生命周期、通信方式</h1><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>1.创建阶段</p>
<p>该阶段主要发生在创建组件类的时候，即调用 React.createClass 时触发。<br>这个阶段只会触发一个 getDefaultProps 方法，该方法返回一个对象并缓存起来。然后与父组件指定的 props 对象合并，最后赋值给 this.props 作为该组件的默认属性。<br>props属性介绍：<br>1，props 是一个对象，是组件用来接收外面传来的参数的。<br>2，组件内部是不允许修改自己的 props 属性，只能通过父组件来修改。上面的 getDefaultProps 方法便是处理 props 的默认值的。</p>
<p>2.实例化阶段</p>
<p>该阶段主要发生在实例化组件类的时候，也就是该组件类被调用的时候触发。这个阶段会触发一系列的流程，按执行顺序如下：<br>（1）getInitialState：初始化组件的 state 的值。其返回值会赋值给组件的 this.state 属性。<br>（2）componentWillMount：根据业务逻辑来对 state 进行相应的操作。<br>（3）render：根据 state 的值，生成页面需要的虚拟 DOM 结构，并返回该结构。<br>（4）componentDidMount：对根据虚拟 DOM 结构而生的真实 DOM 进行相应的处理。组件内部可以通过 ReactDOM.findDOMNode(this) 来获取当前组件的节点，然后就可以像 Web 开发中那样操作里面的 DOM 元素了。<br>state属性介绍：<br>它是用来存储组件自身需要的数据。它是可以改变的，它的每次改变都会引发组件的更新。这也是 ReactJS 中的关键点之一。<br>即每次数据的更新都是通过修改 state 属性的值，然后 ReactJS 内部会监听 state 属性的变化，一旦发生变化，就会触发组件的 render 方法来更新 DOM 结构。</p>
<p>3.更新阶段</p>
<p>这主要发生在用户操作之后或者父组件有更新的时候，此时会根据用户的操作行为进行相应得页面结构的调整。这个阶段也会触发一系列的流程，按执行顺序如下：<br>（1）componentWillReceiveProps：当组件接收到新的 props 时，会触发该函数。在改函数中，通常可以调用 this.setState 方法来完成对 state 的修改。<br>（2）shouldComponentUpdate：该方法用来拦截新的 props 或 state，然后根据事先设定好的判断逻辑，做出最后要不要更新组件的决定。<br>（3）componentWillUpdate：当上面的方法拦截返回 true 的时候，就可以在该方法中做一些更新之前的操作。<br>（4）render：根据一系列的 diff 算法，生成需要更新的虚拟 DOM 数据。（注意：在 render 中最好只做数据和模板的组合，不应进行 state 等逻辑的修改，这样组件结构更加清晰）<br>（5）componentDidUpdate：该方法在组件的更新已经同步到 DOM 中去后触发，我们常在该方法中做一 DOM 操作。</p>
<p>4.销毁阶段<br>这个阶段只会触发一个叫 componentWillUnmount 的方法。<br>当组件需要从 DOM 中移除的时候，我们通常会做一些取消事件绑定、移除虚拟 DOM 中对应的组件数据结构、销毁一些无效的定时器等工作。这些事情都可以在这个方法中处理。</p>
<h2 id="父子组件间通信"><a href="#父子组件间通信" class="headerlink" title="父子组件间通信"></a>父子组件间通信</h2><p>这种情况下很简单，就是通过 props 属性传递</p>
<h2 id="非父子组件间的通信"><a href="#非父子组件间的通信" class="headerlink" title="非父子组件间的通信"></a>非父子组件间的通信</h2><p>使用全局事件 Pub/Sub 模式，在 componentDidMount 里面订阅事件，在 componentWillUnmount 里面取消订阅，当收到事件触发的时候调用 setState 更新 UI。</p>
<p>直接怼redux 或 Mobx</p>
<h1 id="手写实现-React-高阶组件"><a href="#手写实现-React-高阶组件" class="headerlink" title="手写实现 React 高阶组件"></a>手写实现 React 高阶组件</h1><blockquote>
<p>高阶函数是至少满足下列一个条件的函数：</p>
<p>接受一个或多个函数作为输入<br>输出一个函数</p>
<p>高阶组件就是接受一个组件作为参数并返回一个新组件的函数。这里需要注意高阶组件是一个函数，并不是组件，这一点一定要注意。</p>
</blockquote>
<h2 id="基于属性代理的方式"><a href="#基于属性代理的方式" class="headerlink" title="基于属性代理的方式"></a>基于属性代理的方式</h2><p>属性代理是最常见的高阶组件的使用方式，上述描述的高阶组件就是这种方式。它通过做一些操作，将被包裹组件的props和新生成的props一起传递给此组件，这称之为属性代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">export default function withHeader(WrappedComponent) &#123;</div><div class="line">  return class HOC extends Component &#123;</div><div class="line">    render() &#123;</div><div class="line">      const newProps = &#123;</div><div class="line">        test:&apos;hoc&apos;</div><div class="line">      &#125;</div><div class="line">      // 透传props，并且传递新的newProps</div><div class="line">      return &lt;div&gt;</div><div class="line">        &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="基于反向继承的方式"><a href="#基于反向继承的方式" class="headerlink" title="基于反向继承的方式"></a>基于反向继承的方式</h2><p>这种方式返回的React组件继承了被传入的组件，所以它能够访问到的区域、权限更多，相比属性代理方式，它更像打入组织内部，对其进行修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">export default function (WrappedComponent) &#123;</div><div class="line">  return class Inheritance extends WrappedComponent &#123;</div><div class="line">    componentDidMount() &#123;</div><div class="line">      // 可以方便地得到state，做一些更深入的修改。</div><div class="line">      console.log(this.state);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">      return super.render();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="组合-Compose"><a href="#组合-Compose" class="headerlink" title="组合 Compose"></a>组合 Compose</h2><p>compose可以帮助我们组合任意个（包括0个）高阶函数，例如compose(a,b,c)返回一个新的函数d，函数d依然接受一个函数作为入参，只不过在内部会依次调用c,b,a，从表现层对使用者保持透明。<br>基于这个特性，我们便可以非常便捷地为某个组件增强或减弱其特征，只需要去变更compose函数里的参数个数便可。<br>compose函数实现方式有很多种，这里推荐其中一个recompact.compose，详情见下方参考类库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const enhance = compose(withHeader,withLoading);</div><div class="line">@enhance</div><div class="line">class Demo extends Component&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="手写实现一个-Redux-中的-reducer-state-action-gt-newState"><a href="#手写实现一个-Redux-中的-reducer-state-action-gt-newState" class="headerlink" title="手写实现一个 Redux 中的 reducer (state, action) =&gt; newState"></a>手写实现一个 Redux 中的 reducer (state, action) =&gt; newState</h1><p>Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参数，返回一个新的State。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">let reducer = function(state, action) &#123;</div><div class="line">  if(!state) &#123;</div><div class="line">    return &#123;counter: 0&#125;;</div><div class="line">  &#125;</div><div class="line">  switch(action.type) &#123;</div><div class="line">    case &apos;ADD&apos;:</div><div class="line">      return &#123;counter: state.counter+1&#125;;</div><div class="line">    case &apos;DEL&apos;:</div><div class="line">      return &#123;counter: state.counter-1&#125;;</div><div class="line">    default:</div><div class="line">      return state;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="React-受控组件和非受控组件的区别"><a href="#React-受控组件和非受控组件的区别" class="headerlink" title="React 受控组件和非受控组件的区别"></a>React 受控组件和非受控组件的区别</h1><p>受控组件与其它React组件行为一样，其所有状态属性的更改都由React 来控制，也就是说它根据组件的props和state来改变组件的UI表现形式.</p>
<p>非受控组件即组件的状态改变不受控制.<br>非受控组件一般没什么用途，其值并非受父组件控制，它的值受其自身控制。但是，我们可以对其添加一个ref属性，这样可以获得对非受控组件渲染后底层DOM元素的访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">一个受控组件有如下过程：</div><div class="line"></div><div class="line">通过getInitialState设置defaultValue</div><div class="line">&lt;input&gt;渲染时设置默认值</div><div class="line">onChange事件触发后，调用相关处理器</div><div class="line">change事件处理更新state</div><div class="line">重新渲染&lt;input&gt;</div></pre></td></tr></table></figure>
<h2 id="假设有一个列表的数据，React-如何更快的加载数据？（优化方法）"><a href="#假设有一个列表的数据，React-如何更快的加载数据？（优化方法）" class="headerlink" title="假设有一个列表的数据，React 如何更快的加载数据？（优化方法）"></a>假设有一个列表的数据，React 如何更快的加载数据？（优化方法）</h2><p>在 React.js 处理列表就是用 map 来处理、渲染的。</p>
<p>React.js 的是非常高效的，它高效依赖于所谓的 Virtual-DOM 策略。简单来说，能复用的话 React.js 就会尽量复用，没有必要的话绝对不碰 DOM。对于列表元素来说也是这样，但是处理列表元素的复用性会有一个问题：元素可能会在一个列表中改变位置。</p>
<p>React.js 就简单的通过 key 来判断出来，这两个列表元素只是交换了位置，可以尽量复用元素内部的结构。</p>
<p>对于用表达式套数组罗列到页面上的元素，都要为每个元素加上 key 属性，这个 key 必须是每个元素唯一的标识。一般来说，key 的值可以直接后台数据返回的 id，因为后台的 id 都是唯一的。</p>
<h1 id="React的this-setState设计的原因，为什么不让用户自己来"><a href="#React的this-setState设计的原因，为什么不让用户自己来" class="headerlink" title="React的this.setState设计的原因，为什么不让用户自己来"></a>React的this.setState设计的原因，为什么不让用户自己来</h1><p>setState不会立刻改变React组件中state的值；<br>setState通过引发一次组件的更新过程来引发重新绘制；<br>多次setState函数调用产生的效果会合并。</p>
<p>当setState被调用时，能驱动组件的更新过程，引发componentDidUpdate、render等一系列函数的调用。</p>
<p>当shouldComponentUpdate函数被调用的时候，this.state没有得到更新。<br>当componentWillUpdate函数被调用的时候，this.state依然没有得到更新。</p>
<p>直到render函数被调用的时候，this.state才得到更新。</p>
<p>(或者，当shouldComponentUpdate函数返回false，这时候更新过程就被中断了，render函数也不会被调用了，这时候React不会放弃掉对this.state的更新的，所以虽然不调用render，依然会更新this.state。）</p>
<p>如果你没兴趣去记住React的生命周期（虽然你应该记住），那就可以简单认为，直到下一次render函数调用时（或者下一次shouldComponentUpdate返回false时）才得到更新的this.state。</p>
<p>如果传递给this.setState的参数不是一个对象而是一个函数，那游戏规则就变了。</p>
<p>这个函数会接收到两个参数，第一个是当前的state值，第二个是当前的props，这个函数应该返回一个对象，这个对象代表想要对this.state的更改，换句话说，之前你想给this.setState传递什么对象参数，在这种函数里就返回什么对象，不过，计算这个对象的方法有些改变，不再依赖于this.state，而是依赖于输入参数state。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;React-组件的生命周期、通信方式&quot;&gt;&lt;a href=&quot;#React-组件的生命周期、通信方式&quot; class=&quot;headerlink&quot; title=&quot;React 组件的生命周期、通信方式&quot;&gt;&lt;/a&gt;React 组件的生命周期、通信方式&lt;/h1&gt;&lt;h2 id=&quot;组
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="框架" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="React" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/React/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js 基础" scheme="http://wiki.haoqiao.me/tags/js-%E5%9F%BA%E7%A1%80/"/>
    
      <category term="react" scheme="http://wiki.haoqiao.me/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>算法面试考点</title>
    <link href="http://wiki.haoqiao.me/wiki/%E8%BF%9B%E9%98%B6/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/"/>
    <id>http://wiki.haoqiao.me/wiki/进阶/算法/算法面试考点/</id>
    <published>2018-03-28T00:33:53.000Z</published>
    <updated>2018-03-28T00:34:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手写代码找出二叉树节点的最长距离？"><a href="#手写代码找出二叉树节点的最长距离？" class="headerlink" title="手写代码找出二叉树节点的最长距离？"></a>手写代码找出二叉树节点的最长距离？</h2><h2 id="手写代码实现链表的逆序？"><a href="#手写代码实现链表的逆序？" class="headerlink" title="手写代码实现链表的逆序？"></a>手写代码实现链表的逆序？</h2><h2 id="手写代码找出数组中的最长递增序列？"><a href="#手写代码找出数组中的最长递增序列？" class="headerlink" title="手写代码找出数组中的最长递增序列？"></a>手写代码找出数组中的最长递增序列？</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;手写代码找出二叉树节点的最长距离？&quot;&gt;&lt;a href=&quot;#手写代码找出二叉树节点的最长距离？&quot; class=&quot;headerlink&quot; title=&quot;手写代码找出二叉树节点的最长距离？&quot;&gt;&lt;/a&gt;手写代码找出二叉树节点的最长距离？&lt;/h2&gt;&lt;h2 id=&quot;手写代码实
    
    </summary>
    
      <category term="进阶" scheme="http://wiki.haoqiao.me/categories/%E8%BF%9B%E9%98%B6/"/>
    
      <category term="算法" scheme="http://wiki.haoqiao.me/categories/%E8%BF%9B%E9%98%B6/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://wiki.haoqiao.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试考点" scheme="http://wiki.haoqiao.me/tags/%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS</title>
    <link href="http://wiki.haoqiao.me/wiki/%E8%BF%9B%E9%98%B6/%E5%AE%89%E5%85%A8/HTTPS/"/>
    <id>http://wiki.haoqiao.me/wiki/进阶/安全/HTTPS/</id>
    <published>2018-03-27T00:30:46.000Z</published>
    <updated>2018-03-27T00:42:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://cattail.me/tech/2015/11/30/how-https-works.html" rel="external nofollow noopener noreferrer" target="_blank">HTTPS工作原理</a></p>
<h2 id="HTTPS-服务端和客户端连接的原理？（SSL-验证原理）"><a href="#HTTPS-服务端和客户端连接的原理？（SSL-验证原理）" class="headerlink" title="HTTPS 服务端和客户端连接的原理？（SSL 验证原理）"></a>HTTPS 服务端和客户端连接的原理？（SSL 验证原理）</h2><ol>
<li>[明文] 客户端发送随机数client_random和支持的加密方式列表</li>
<li>[明文] 服务器返回随机数server_random ，选择的加密方式和服务器证书链</li>
<li>[RSA] 客户端验证服务器证书，使用证书中的公钥加密premaster secret 发送给服务端</li>
<li>服务端使用私钥解密premaster secret</li>
<li>两端分别通过client_random，server_random 和premaster secret 生成master secret，用于对称加密后续通信内容</li>
</ol>
<p>HTTPS采用共享密钥加密和公开密钥加密混合的加密方式，在交换密钥对环节使用公开密钥加密方式（防止被监听泄漏密钥）加密共享的密钥，在随后的通信过程中使用共享密钥的方式使用共享的密钥进行加解密。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;资料&quot;&gt;&lt;a href=&quot;#资料&quot; class=&quot;headerlink&quot; title=&quot;资料&quot;&gt;&lt;/a&gt;资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://cattail.me/tech/2015/11/30/how-https-works.html&quot; rel=
    
    </summary>
    
      <category term="进阶" scheme="http://wiki.haoqiao.me/categories/%E8%BF%9B%E9%98%B6/"/>
    
      <category term="安全" scheme="http://wiki.haoqiao.me/categories/%E8%BF%9B%E9%98%B6/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://wiki.haoqiao.me/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="HTTPS" scheme="http://wiki.haoqiao.me/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>浏览器</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/基础/计算机基础/浏览器/</id>
    <published>2018-03-26T00:20:43.000Z</published>
    <updated>2018-04-04T00:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" rel="external nofollow noopener noreferrer" target="_blank">浏览器的工作原理：新式网络浏览器幕后揭秘</a></p>
<h1 id="浏览器解析过程"><a href="#浏览器解析过程" class="headerlink" title="浏览器解析过程"></a>浏览器解析过程</h1><p>浏览器接收到html代码，可能是一份完整的文档，也可能是一个chunk，即开始解析。解析过程是先构建dom树，再根据dom树构建渲染树，最后浏览器将渲染树绘制到页面上。    </p>
<p>  构建dom树的过程即根据html代码自上而下进行构建，当遇到script文件加载／执行会阻塞后面dom树的构建（javascript可能会改变dom树），而遇到css文件则会阻塞渲染树的构建，即dom树依然继续构建（除非遇到script标签并且css文件依旧未加载完成），但不会渲染绘制到页面上。而无论哪个阻塞，该加载的文件还是会加载，例如html文档中的其他css／js／图片文件。另外javascript被加载后就会被执行，执行的过程也阻塞树的构建。是执行完了才解析其他内容，而不是执行完了才加载其他内容。</p>
<p>默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。<br>JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性。<br>存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外：</p>
<p>当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。<br>JavaScript 可以查询和修改 DOM 与 CSSOM。<br>CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。<br>所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：</p>
<p>CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。<br>JavaScript 应尽量少影响 DOM 的构建。</p>
<ul>
<li><p>HTML解析出DOM Tree</p>
</li>
<li><p>CSS解析出Style Rules</p>
</li>
<li><p>将二者关联生成Render Tree</p>
</li>
<li><p>Layout 根据Render Tree计算每个节点的信息</p>
</li>
<li><p>Painting 根据计算好的信息绘制整个页面</p>
</li>
</ul>
<p>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading<br>HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容<br>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素<br>当文档完成解析，document.readState变成interactive<br>所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()<br>浏览器在Document对象上触发DOMContentLoaded事件<br>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件<br>显示页面（HTML解析过程中会逐步显示页面）</p>
<h1 id="浏览器不同内核之间的区别"><a href="#浏览器不同内核之间的区别" class="headerlink" title="浏览器不同内核之间的区别"></a>浏览器不同内核之间的区别</h1><ul>
<li>由于IE的高市场占有率，微软也很长时间没有更新Trident内核，这导致了二个结果</li>
<li>1，Trident内核和W3C标准脱节。</li>
<li><p>2，Trident内核的大量Bug等安全问题没有得到解决，加上一些专家学者公开自己认为IE浏览器不安全的观点，使很多用户开始转向其他浏览器，FF,Opera就是这时期兴起的。</p>
</li>
<li><p>Gecko：这是Firefox 和 Flock 所采用内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</p>
</li>
<li><p>Presto：Opera 采用的是 Presto内核，Presto内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理JS脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</p>
</li>
<li><p>Webkit：Webkit 是 Safari 采用的内核，不过 Safari 是苹果系统下的浏览器(虽然也有windows版，但是比较少)，所以只简单介绍一下这个内核的优点和缺点，优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;资料&quot;&gt;&lt;a href=&quot;#资料&quot; class=&quot;headerlink&quot; title=&quot;资料&quot;&gt;&lt;/a&gt;资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.html5rocks.com/zh/tutorials/internals/howbrowsers
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机基础" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://wiki.haoqiao.me/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="浏览器" scheme="http://wiki.haoqiao.me/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>推送系统源码学习(技术篇)</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%AE%9E%E4%B9%A0/2018-03-25-%E6%8E%A8%E9%80%81%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/实习/2018-03-25-推送系统源码学习/</id>
    <published>2018-03-25T10:40:00.000Z</published>
    <updated>2018-03-29T12:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  周二上午到达广州，下午到部门实习，这次的任务是基于原有的推送项目做一些需求增加。<br>  一开始还是很慌的，因为现有系统已经在公司内部跑了，因此压力还是很大的。不过好在导师开发的，带着我过了一遍，然后我也很尽力的死磕源码，边读边做笔记。然后晚上开始了解整个需求，导师将其进行分期分配，第二天就直接开始做需求了，因此是边做边学习的节奏，踩了不少坑，主要是不了解系统，而且用的技术栈是16年的，而且导师在那个时候设计的思想很超前，感觉学习价值很大，因此在周末专门花点时间去梳理和学习。</p>
<h1 id="项目源码解析"><a href="#项目源码解析" class="headerlink" title="项目源码解析"></a>项目源码解析</h1><p>整个项目目录如下:</p>
<p>前端架构 采用</p>
<ul>
<li>react 15.4.0</li>
<li>redux 4.4.5</li>
<li>react-router 2.6.1 </li>
<li>redux 3.5.2 </li>
<li>redux-router 2.1.2</li>
<li>redux-thunk 2.0.1</li>
</ul>
<p>看上去是比较老的技术栈，一开始我也觉得好老啊，但是在这样的技术栈上，却有令人惊艳的设计思想。感觉自己还需要学的地方很多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">.</div><div class="line">├── base.less // 设定了一些基础UI的样式 重写覆盖了一些</div><div class="line">├── common.less // 颜色样式</div><div class="line">├── components // 核心两个组件</div><div class="line">    组件这块封装了 antd 2.7 的组件，提供了一些特殊处理的接口</div><div class="line">│   ├── TableFilter // 列表筛选组件 </div><div class="line">│   │   ├── CascaderSelectorFilter  // 级联选择组件</div><div class="line">│   │   │   └── index.jsx</div><div class="line">│   │   ├── DateRangeFilter // 时间筛选组件</div><div class="line">│   │   │   └── index.jsx</div><div class="line">│   │   ├── KeywordFilter // 关键词筛选</div><div class="line">│   │   │   └── index.jsx</div><div class="line">│   │   ├── RangeFilter // 范围筛选</div><div class="line">│   │   │   └── index.jsx</div><div class="line">│   │   ├── SelectFilter // 选择筛选</div><div class="line">│   │   │   └── index.jsx</div><div class="line">│   │   ├── TableFilter.md</div><div class="line">│   │   ├── TreeSelectFilter // 树形结构级联筛选</div><div class="line">│   │   │   └── index.jsx</div><div class="line">│   │   ├── index.jsx // 根据传入参数返回对应组件</div><div class="line">│   │   └── style.less</div><div class="line">│   └── WULIComponents</div><div class="line">│       ├── WULICheckList // 多选类别</div><div class="line">│       │   ├── index.jsx </div><div class="line">│       │   └── style.less</div><div class="line">│       ├── WULIConfirmDialog // 操作确认对话框</div><div class="line">│       │   ├── WULIConfirmDialog.md</div><div class="line">│       │   ├── index.jsx</div><div class="line">│       │   └── style.less</div><div class="line">│       ├── WULIDisplayList // 列表</div><div class="line">│       │   ├── ListItem</div><div class="line">│       │   │   ├── index.jsx</div><div class="line">│       │   │   └── style.less</div><div class="line">│       │   ├── index.jsx</div><div class="line">│       │   └── style.less</div><div class="line">│       ├── WULIExpandButton //扩展按钮</div><div class="line">│       │   ├── index.jsx</div><div class="line">│       │   └── style.less</div><div class="line">│       ├── WULIFormItem // 表单</div><div class="line">│       │   ├── CheckGroup</div><div class="line">│       │   │   ├── index.jsx</div><div class="line">│       │   │   └── style.less</div><div class="line">│       │   ├── CheckedInput</div><div class="line">│       │   │   ├── index.jsx</div><div class="line">│       │   │   └── style.less</div><div class="line">│       │   ├── Display</div><div class="line">│       │   │   ├── index.jsx</div><div class="line">│       │   │   └── style.less</div><div class="line">│       │   ├── Input</div><div class="line">│       │   │   ├── index.jsx</div><div class="line">│       │   │   └── style.less</div><div class="line">│       │   ├── Select</div><div class="line">│       │   │   ├── index.jsx</div><div class="line">│       │   │   └── style.less</div><div class="line">│       │   └── Textarea</div><div class="line">│       │       ├── index.jsx</div><div class="line">│       │       └── style.less</div><div class="line">│       ├── WULIGlobalLoading // 全局的加载</div><div class="line">│       │   ├── WULIGlobalLoading.md</div><div class="line">│       │   └── index.jsx</div><div class="line">│       ├── WULIHeader // 这里提供了头部的渲染内容，支持action传入，主要是action</div><div class="line">│       │   ├── WULIHeader.md</div><div class="line">│       │   ├── index.jsx</div><div class="line">│       │   └── style.less</div><div class="line">│       ├── WULIList // 列表的配置，这里生成了多页的选择，配置基本都是调用的时候传入</div><div class="line">│       │   ├── index.jsx</div><div class="line">│       │   └── style.less</div><div class="line">│       ├── WULIListItem</div><div class="line">│       │   ├── index.jsx</div><div class="line">│       │   └── style.less</div><div class="line">│       ├── WULILoginDialog // 这个组件可以删掉的。。。写了居然没用用过</div><div class="line">│       │   ├── index.jsx</div><div class="line">│       │   └── style.less</div><div class="line">│       ├── WULINotification</div><div class="line">│       │   ├── WULINotification.md</div><div class="line">│       │   └── index.jsx</div><div class="line">│       ├── WULISelectableList // 写了同样没调用</div><div class="line">│       │   ├── ListItem</div><div class="line">│       │   │   ├── index.jsx</div><div class="line">│       │   │   └── style.less</div><div class="line">│       │   ├── index.jsx</div><div class="line">│       │   └── style.less</div><div class="line">│       ├── WULISider</div><div class="line">│       │   ├── WULISider.md</div><div class="line">│       │   ├── index.jsx</div><div class="line">│       │   └── style.less</div><div class="line">│       ├── WULITable</div><div class="line">│       │   ├── DataTable.jsx</div><div class="line">│       │   ├── SimpleSearch.jsx</div><div class="line">│       │   ├── TableActions.jsx</div><div class="line">│       │   ├── index.jsx</div><div class="line">│       │   └── style.less</div><div class="line">│       ├── WULITableList</div><div class="line">│       │   ├── index.jsx</div><div class="line">│       │   └── style.less</div><div class="line">│       ├── WULIToast</div><div class="line">│       │   ├── WULIToast.md</div><div class="line">│       │   └── index.jsx</div><div class="line">│       └── index.js</div><div class="line">├── containers</div><div class="line">│   └── Root  // 把路由和 props.store 注入到页面</div><div class="line">│       └── index.jsx </div><div class="line">├── index.jsx </div><div class="line">├── middlewares</div><div class="line">│   └── request.js // 封装了 ajax, 一些错误捕获方法</div><div class="line">├── modules</div><div class="line">│   ├── action_generator.js </div><div class="line">    // 自动生成 action 配置</div><div class="line">       分成四类</div><div class="line">       ajax,对分页 pagination 做了细致处理，</div><div class="line">          joinActionLoading 和 loading ？？</div><div class="line">          filter ？？？</div><div class="line">          </div><div class="line">      isModal 弹框类型</div><div class="line"></div><div class="line">      isSetter 设置值</div><div class="line"></div><div class="line">      如果不是以上类型，则会生成 action $&#123;module&#125;_$&#123;name&#125;</div><div class="line">     </div><div class="line">      </div><div class="line">    </div><div class="line"></div><div class="line">│   ├── common // UI 模块 userInfo login logout loading 生成</div><div class="line">│   │   ├── actions.js </div><div class="line">           // 配置一些系统基本的动作比如登录登出Loading，并用 action_generator 生成</div><div class="line"></div><div class="line">│   │   ├── constants.js // 基本的 constants</div><div class="line">│   │   ├── index.js</div><div class="line">│   │   └── reducer.js // 基本的 reducer</div><div class="line">│   ├── defines.js // 定义 action 状态 load success fail </div><div class="line">│   ├── dialog // confirm 模块 生成</div><div class="line">│   │   ├── action.js</div><div class="line">│   │   ├── constants.js</div><div class="line">│   │   ├── index.js</div><div class="line">│   │   └── reducer.js</div><div class="line">│   ├── message // 消息 和 提示 模块生成</div><div class="line">│   │   ├── actions.js</div><div class="line">│   │   ├── constants.js</div><div class="line">│   │   ├── index.js</div><div class="line">│   │   └── reducer.js</div><div class="line">│   ├── notice // 推送 api 模块 生成</div><div class="line">│   │   ├── actions.js</div><div class="line">│   │   ├── constants.js</div><div class="line">│   │   ├── index.js</div><div class="line">│   │   ├── reducer.js</div><div class="line">│   │   └── tools.js</div><div class="line">│   ├── reducer_generator.js </div><div class="line">        // 自动生成 reducer 配置</div><div class="line"></div><div class="line">│   ├── tools.js  // 拼接动作字符串</div><div class="line">│   └── userSelector</div><div class="line">│       ├── actions.js</div><div class="line">│       ├── constants.js</div><div class="line">│       ├── index.js</div><div class="line">│       └── reducer.js</div><div class="line">├── pages</div><div class="line">│   ├── AddPage // 添加消息页面</div><div class="line">│   │   ├── business.jsx // 逻辑模块 新功能的状态和功能往里面塞</div><div class="line">│   │   ├── containers // 视图模块 </div><div class="line">│   │   │   ├── ContentPart  // 推送详情</div><div class="line">│   │   │   │   ├── index.jsx</div><div class="line">│   │   │   │   ├── selector.js // 从 store 里拿数据</div><div class="line">│   │   │   │   └── style.css</div><div class="line">│   │   │   └── UserPart // 用户列表</div><div class="line">│   │   │       ├── index.jsx</div><div class="line">│   │   │       ├── selector.js</div><div class="line">│   │   │       └── style.css</div><div class="line">│   │   ├── index.jsx // 页面容器</div><div class="line">│   │   ├── rules.js // 一些表单校验规则</div><div class="line">│   │   ├── selector.js</div><div class="line">│   │   └── style.css</div><div class="line">│   ├── App</div><div class="line">│   │   ├── components</div><div class="line">│   │   │   ├── Breadcrumb // 面包屑导航</div><div class="line">│   │   │   │   ├── index.jsx</div><div class="line">│   │   │   │   └── style.css</div><div class="line">│   │   │   └── Sider // 左边栏</div><div class="line">│   │   │       ├── index.jsx</div><div class="line">│   │   │       └── style.css</div><div class="line">│   │   ├── index.jsx // 后台进入页面</div><div class="line">│   │   ├── selector.js</div><div class="line">│   │   └── style.css</div><div class="line">│   ├── DetailPage // 消息详情页</div><div class="line">│   │   ├── business.jsx // 逻辑处理页面</div><div class="line">│   │   ├── components</div><div class="line">│   │   │   ├── Basic // 基本信息</div><div class="line">│   │   │   │   ├── index.jsx</div><div class="line">│   │   │   │   └── style.css</div><div class="line">│   │   │   └── ReplyModal // 回复框</div><div class="line">│   │   │       ├── index.jsx</div><div class="line">│   │   │       └── style.css</div><div class="line">│   │   ├── containers</div><div class="line">│   │   │   ├── ReplyList</div><div class="line">│   │   │   │   ├── ReplyListTable.jsx</div><div class="line">│   │   │   │   ├── index.jsx</div><div class="line">│   │   │   │   ├── selector.js</div><div class="line">│   │   │   │   └── style.css</div><div class="line">│   │   │   └── StatusList</div><div class="line">│   │   │       ├── StatusListTable.jsx</div><div class="line">│   │   │       ├── index.jsx</div><div class="line">│   │   │       ├── selector.js</div><div class="line">│   │   │       └── style.css</div><div class="line">│   │   ├── index.jsx</div><div class="line">│   │   ├── selector.js</div><div class="line">│   │   └── style.css</div><div class="line">│   ├── LoginPage</div><div class="line">│   │   ├── components</div><div class="line">│   │   │   └── LoginForm</div><div class="line">│   │   │       ├── index.jsx</div><div class="line">│   │   │       └── style.css</div><div class="line">│   │   ├── index.jsx</div><div class="line">│   │   ├── style.css</div><div class="line">│   │   └── style.less</div><div class="line">│   ├── MyListPage</div><div class="line">│   │   ├── business.jsx</div><div class="line">│   │   ├── components</div><div class="line">│   │   │   └── NoticeTable</div><div class="line">│   │   │       └── index.jsx</div><div class="line">│   │   ├── index.jsx</div><div class="line">│   │   ├── selector.js</div><div class="line">│   │   └── style.css</div><div class="line">│   └── _common</div><div class="line">│       ├── components</div><div class="line">│       │   ├── Dropdown</div><div class="line">│       │   │   ├── index.jsx</div><div class="line">│       │   │   └── style.css</div><div class="line">│       │   └── UserList</div><div class="line">│       │       └── index.jsx</div><div class="line">│       └── containers</div><div class="line">│           ├── ConfirmDialog</div><div class="line">│           │   ├── index.jsx</div><div class="line">│           │   └── selector.js</div><div class="line">│           ├── Notification</div><div class="line">│           │   ├── index.jsx</div><div class="line">│           │   └── selector.js</div><div class="line">│           ├── Toast</div><div class="line">│           │   ├── index.jsx</div><div class="line">│           │   └── selector.js</div><div class="line">│           └── UserSelector</div><div class="line">│               ├── ImportTab</div><div class="line">│               │   ├── Info</div><div class="line">│               │   │   └── index.jsx</div><div class="line">│               │   └── index.jsx</div><div class="line">│               ├── business.jsx</div><div class="line">│               ├── index.jsx</div><div class="line">│               ├── selector.js</div><div class="line">│               └── style.css</div><div class="line">├── rootReducer.js</div><div class="line">├── routes.jsx</div><div class="line">├── store</div><div class="line">│   ├── configureStore.js</div><div class="line">│   └── schemas.js</div><div class="line">└── utils</div><div class="line">    ├── defines.js</div><div class="line">    ├── tools.js</div><div class="line">    └── validator.js</div></pre></td></tr></table></figure>
<p>后端是采用 node + koa + mysql + redis 这个就不分析了。</p>
<p>主要就是 切分了service层。这个我之前学习过。</p>
<h1 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a>思想分析</h1><h2 id="action生成器"><a href="#action生成器" class="headerlink" title="action生成器"></a>action生成器</h2><p>  一开始就以配置优先先入为止，这是暑期实习的时候听到分享的一部分，没想到16年已经实践并应用了。而且导师说那个时候写的很爽。</p>
<p>  从最初的磕磕碰碰到后面比较熟练的调用，我终于明白写的很爽的体验，而且不止是写的爽，代码的组织条理性都很值得学习，很多地方都考虑的很周全。</p>
<p>  这里先将最主要的几个部分进行分析。</p>
<p>  按照18年的 react 技术栈，可以选择的流行全家桶 一般也是 react + redux /mobx + 异步处理中间件。</p>
<p>  按照我毕设的选型我是选择了 react + redux + rxjs中间件，基础还是一样的 constants + actions + reducers.</p>
<p>   不过动作的触发是由 rxjs 中间件拦截，有对应的epics去做数据的拉取，然后再构造一个动作去保存到本地的reducer。这个好处是层次分明，从store -&gt; action -&gt; rxjs -&gt; action -&gt; reducer。而且维护起来很方便。就是有个不好，你必须一开始将很多细节考虑清楚，不然你遗漏一个需求，需要更新好几个文件的内容。</p>
<p>   而配置优先的概念的提出就是解决这个问题，这个很久以前隐隐有看到过相关概念，去年正式接触，到现在真的看到实现代码。感觉有些东西真的是要看到实践才明白是怎么一回事。</p>
<p>  首先配置优先不仅仅是框架的配置，而且一些组件的配置也可以同样。 </p>
<p>  首先肯定是代码组织结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"> /module</div><div class="line"> </div><div class="line">    /核心数据流</div><div class="line">      action.js</div><div class="line">      reducer.js</div><div class="line">      constants.js</div><div class="line">      index.js</div><div class="line">      </div><div class="line">action_generator.js</div><div class="line">reducer_generator.js</div><div class="line">defines.js</div><div class="line">tools.js</div></pre></td></tr></table></figure>
<p>感觉比较精髓的一个是action和reducer的生成器，一个是将一个完整的核心动作都组织结合在一起。</p>
<p>actions 生成器，它通过传入的参数自动生成配置，这个要有业务的积累才能够将大部分的action抽象出来，然后再根据配置生成适合的。</p>
<p>为了保证 action 的唯一性，我们需要传入一个参数作为前缀，一般用页面名作为前缀。</p>
<p>为了用配置的方式写 actions，考虑把 actions 用 json 数组的方式传进来，这样可以用到 map 函数来遍历并且生成每一个 action。<br>－ 最后要将所有的 action 组装成一个变量 export 出去，再对原有的 import 方法进行修改就可以了</p>
<p>因此学习这个的时候跪着看完~</p>
<p>首先先讨论一下我们究竟需要什么样的action。</p>
<p>第一个肯定就是普通的数据，比如一些简单的交互产生的数据，存到本地，然后需要的时候获取或者更新。</p>
<p>第二种就是常用的异步获取数据，远程拿数据然后存本地。(这里其实要考虑的地方还是比较多的)</p>
<p>以上两种场景是最常用的。</p>
<p>但是如果想的再全一点会有这设定：<br>isModal</p>
<p>这样似乎是包含完全了。</p>
<p>但是项目中是这么划分的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">isAjax: 异步操作，会自动生成 $&#123;module&#125;_$&#123;name&#125;_LOAD, $&#123;module&#125;_$&#123;name&#125;_SUCCESS,</div><div class="line"> *   $&#123;module&#125;_$&#123;name&#125;_FAIL 三个 action，其搭配的配置项如下：</div><div class="line"> ... pagination</div><div class="line"> ... filter</div><div class="line"></div><div class="line">isModal 弹框类型，会生成 reducer: $&#123;name&#125;Show, 并且生成 action: $&#123;module&#125;_show&#123;Name&#125;,</div><div class="line"> *   $&#123;module&#125;_hide&#123;Name&#125; 和 $&#123;module&#125;_toggle&#123;Name&#125;</div><div class="line"></div><div class="line">isSetter: 设置值类型，会生成 reducer: $&#123;name&#125;,</div><div class="line"> *   并且生成 action: $&#123;module&#125;_set$&#123;Name&#125; 和 $&#123;module&#125;_clear$&#123;Name&#125;</div><div class="line"></div><div class="line">如果不是以上类型，则会生成 action $&#123;module&#125;_$&#123;name&#125;</div></pre></td></tr></table></figure>
<p>这里就会感觉有点矛盾，为什么要区分 isSetter 和 默认的生成项呢。</p>
<p>通过对其间的配置以及后面 reducer 生成器的一些代码，从而推导出作者其实是想让 action 变得更加纯粹一点。</p>
<p>isSetter 用于之前说的需要对交互或者一些数据做本地化存储，典型的例子就是token，用户请求需要带着 token 校验用户身份。需要做本地的存储，方便在其它地方能够随时调用。</p>
<p>而默认的 <code>action ${module}_${name}</code> 它只是一个动作，它是可以再触发后去通过更改一些原来就有的状态，或者通过触发其它动作来实现，典型的例子就是Loading了。</p>
<p>而且从上面的代码 我们可以看出 <code>${module}_${name}_LOAD</code> 很多都是配置的。</p>
<p>这里的配置是 按照这样的来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">export const getAction = (actionPrefix, actionName, actionStatus) =&gt;</div><div class="line">  `$&#123;actionPrefix&#125;_$&#123;actionName&#125;$&#123;actionStatus ? `_$&#123;actionStatus&#125;` : &apos;&apos;&#125;`;</div></pre></td></tr></table></figure>
<p> <code>module</code> 对应的是 <code>${actionPrefix}</code>,这是在对应的模块目录下的 <code>constants.js</code> 中定义的。 </p>
<p><code>isAjax</code> 会有三个状态，加载，失败，成功。<br>先生成三个 <code>constants</code>, 用于定义动作描述。</p>
<p>然后对应生成三种 <code>Action</code>，这里需要接受一些 <code>ajax</code> 特定的参数，比如 <code>Api</code>, <code>method</code> , <code>sucCallback</code>, <code>errCallback</code>。</p>
<p>如果分页还要根据对象生成 <code>set${toCamel(name)}Page</code> 并且生成 无前缀的同名action。</p>
<p>这里有个细节是为了可读性，需要做驼峰命名处理。</p>
<p>如果需要过滤器，需要 <code>set${toCamel(name)}Filter</code> 与 <code>clear${toCamel(name)}Filter</code> 俩个 constants 和 action.</p>
<p>如果是 Modal 类型，就需要考虑 Modal 的几个状态，show || hide || toggle.分别生成对应的 constans 与 action</p>
<p>然后是 setter, 它有 set 与 clear</p>
<p>当以上选择都没有，说明要建立一个纯action,以前缀+模块名命名生成。</p>
<p>简单输出一下生成的结构。</p>
<p><img src="media/15220630587183.jpg" alt=""></p>
<h2 id="reducer-生成器"><a href="#reducer-生成器" class="headerlink" title="reducer 生成器"></a>reducer 生成器</h2><p>然后是自动生成 reducer,这个和aciton是一一对应的。</p>
<p>传统的reducer 就是拦截动作，然后根据状态对 数据初始化赋值，或者更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">典型的写法：</div><div class="line"></div><div class="line">const initialState = &#123;</div><div class="line">   loadingState: &apos;&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const loading = (state = initialState, action: Action) =&gt; &#123;</div><div class="line">  // console.log(action)</div><div class="line">  switch (action.type) &#123;</div><div class="line">    case LOADING_START:</div><div class="line">    return &#123;</div><div class="line">      ...state,</div><div class="line">      loadingState: &apos;start&apos;</div><div class="line">    &#125;</div><div class="line">    case LOADING_SUCCESS:</div><div class="line">    return &#123;</div><div class="line">      ...state,</div><div class="line">      loadingState: &apos;success&apos;</div><div class="line">    &#125;</div><div class="line">    case LOADING_ERROR:</div><div class="line">    return &#123;</div><div class="line">      ...state,</div><div class="line">      loadingState: &apos;error&apos;</div><div class="line">    &#125;</div><div class="line">    default:</div><div class="line">      return state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以这个load 为例子，我们可以看到 Load 的多个状态与数据都一一对应.</p>
<p>因此 reducer 生成器也是基于此，但是 reducer 生成器和 action 有区别，那就是需要的配置项更多。因为会涉及到异步去拿数据。</p>
<p> reducer generator 相关配置</p>
<ul>
<li>basics: 基本的 reducer，为一个数组，会往 module 中增加新的 reducer，每一个元素的配置如下</li>
<li>name: reducer 的名字</li>
<li>initialState: state 初始值</li>
<li>mappers: 为一个数组，表示从 action 到 state 的相应，每一个元素配置如下</li>
<li>action: 响应的 action，会自动合成为 ${module}_action</li>
<li>nextState: 为一个函数，传入参数为 (state, action)，返回值为下一个 state<br>*</li>
<li>extras: 为通过 action 配置而自动生成的 reducer 的补充配置</li>
<li>name: reducer 的名字</li>
<li>mappers: 为一个数组，表示从 action 到 state 的相应，每一个元素配置如下</li>
<li>action: 响应的 action，会自动合成为 ${module}_action</li>
<li>nextState: 为一个函数，传入参数为 (state, action)，返回值为下一个 state</li>
</ul>
<p>reducer 生成器它一开始需要根据通过 action 的配置来生成一些常用的 reducer 和 额外的 action。这个主要就是遍历加组合对象。</p>
<p>比如常见的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">switch (action.type) &#123;</div><div class="line">    case xxx:</div><div class="line">      return true;</div><div class="line">    default:</div><div class="line">      return state;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>将其视为一种类型的 action</p>
<p>约定生成对应的reducer。</p>
<p>reducer 生成器还有一种形式就是不根据aciton的配置而是单独写配置然后生成。</p>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">extras: [</div><div class="line">   &#123;</div><div class="line">     name: &apos;xxx&apos;,</div><div class="line">     mappers: [</div><div class="line">       &#123;</div><div class="line">         action: &apos;xxx&apos;,</div><div class="line">         nextState: (state, action) =&gt; action.data.checked ?</div><div class="line">           add(...) :</div><div class="line">           delete(..)</div><div class="line">       &#125;</div><div class="line">     ]</div><div class="line">   &#125;</div><div class="line"> ]</div></pre></td></tr></table></figure>
<p>需要做的就是根据name，然后读取配置，然后生成。也可以直接 写reducer 通过<code>combineReducers</code>暴露出来。</p>
<p>通过配置生成所有的 action 和 reducer 的方法，可以让开发效率大增。但是通过对一些模块的了解，发现 reducer 这块覆盖场景虽然广，但是有些地方并不需要考虑使用，然后就是学习成本是有点高的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;  周二上午到达广州，下午到部门实习，这次的任务是基于原有的推送项目做一些需求增加。&lt;br&gt;  一开始还是很慌的，因为现有系统已经在公司内部
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="实习" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="实习" scheme="http://wiki.haoqiao.me/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="CVTE" scheme="http://wiki.haoqiao.me/tags/CVTE/"/>
    
      <category term="技术篇" scheme="http://wiki.haoqiao.me/tags/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/基础/计算机基础/HTTP/</id>
    <published>2018-03-24T00:17:33.000Z</published>
    <updated>2018-03-24T00:29:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" rel="external nofollow noopener noreferrer" target="_blank">MDN HTTP response codes</a></p>
<p><a href="https://www.cnblogs.com/lyzg/p/5125934.html" rel="external nofollow noopener noreferrer" target="_blank">强缓存与协商缓存</a></p>
<h1 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h1><p>HTTP有两类报文：请求报文和响应报文。</p>
<p>HTTP请求报文</p>
<p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。</p>
<h2 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h2><p>请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</p>
<p>User-Agent：产生请求的浏览器类型。</p>
<p>Accept：客户端可识别的内容类型列表。</p>
<p>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</p>
<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>
<h2 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h2><p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>
<h2 id="304-和-200-区别"><a href="#304-和-200-区别" class="headerlink" title="304 和 200 区别"></a>304 和 200 区别</h2><p>HTTP 304 未改变说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法（safe），例如GET 或HEAD 或在请求中附带了头部信息： If-None-Match 或If-Modified-Since。</p>
<p>如果是 200 OK ，响应会带有头部 Cache-Control, Content-Location, Date, ETag, Expires，和 Vary.</p>
<blockquote>
<p>很多浏览器的 开发者工具 会发出额外的请求，以达到 304 的目的，这样可以把资源以本地缓存的形式展现给开发者。</p>
</blockquote>
<h1 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h1><p>1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；</p>
<p>2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；</p>
<p>3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p>
<p>4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。</p>
<p>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：</p>
<p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header</p>
<p>2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</p>
<p>3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。</p>
<p>4）如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。</p>
<p>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：</p>
<p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header，如：</p>
<p>2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</p>
<p>3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</p>
<p>4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</p>
<p>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。</p>
<p>这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires：</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</p>
<p>【Last-Modified，If-Modified-Since】的控制缓存的原理是：</p>
<p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间：</p>
<p>2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值：</p>
<p>3）服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header：</p>
<p>4）浏览器收到304的响应后，就会从缓存中加载资源。</p>
<p>5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</p>
<p>【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：</p>
<p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：</p>
<p>2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值：</p>
<p>3）服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化：</p>
<p>4）浏览器收到304的响应后，就会从缓存中加载资源。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;参考网站&quot;&gt;&lt;a href=&quot;#参考网站&quot; class=&quot;headerlink&quot; title=&quot;参考网站&quot;&gt;&lt;/a&gt;参考网站&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Sta
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机基础" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://wiki.haoqiao.me/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="HTTP" scheme="http://wiki.haoqiao.me/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>CSS 世界</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Css/CSS%20%E4%B8%96%E7%95%8C/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/基础/Css/CSS 世界/</id>
    <published>2018-03-19T04:56:10.000Z</published>
    <updated>2018-03-29T00:33:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="css-流体布局下额宽度分离原则"><a href="#css-流体布局下额宽度分离原则" class="headerlink" title="css 流体布局下额宽度分离原则"></a>css 流体布局下额宽度分离原则</h2><p>css 中的 width属性 不与 影响宽度的 padding/border/margin 属性共存。</p>
<p>不能出现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">.box&#123; width: 100px; border: 1px solid;&#125;</div></pre></td></tr></table></figure>
<p>而用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">.father&#123; width:100px; &#125;</div><div class="line">.son &#123; margin: ...; padding: ...; &#125;</div></pre></td></tr></table></figure>
<h2 id="box-sizing-的初衷"><a href="#box-sizing-的初衷" class="headerlink" title="box-sizing 的初衷"></a>box-sizing 的初衷</h2><p>解决替换元素宽度自适应问题。</p>
<p><a href="http://demo.cssworld.cn/3/2-9.php" rel="external nofollow noopener noreferrer" target="_blank">demo</a></p>
<p>让 <code>textarea</code> <code>input</code> 的100%自适应父容器宽度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;css-流体布局下额宽度分离原则&quot;&gt;&lt;a href=&quot;#css-流体布局下额宽度分离原则&quot; class=&quot;headerlink&quot; title=&quot;css 流体布局下额宽度分离原则&quot;&gt;&lt;/a&gt;css 流体布局下额宽度分离原则&lt;/h2&gt;&lt;p&gt;css 中的 width属性
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Css" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Css/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://wiki.haoqiao.me/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Css" scheme="http://wiki.haoqiao.me/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>websocket</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Ecmascript/websocket/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/基础/Ecmascript/websocket/</id>
    <published>2018-03-10T13:20:50.000Z</published>
    <updated>2018-03-10T13:29:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>WebSocket是一种在单个TCP连接上进行全双工通讯的协议</p>
<p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</p>
<p>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</p>
<p>保持连接状态。于HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</p>
<h1 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h1><p>轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。</p>
<p>新的技术去做轮询的效果是Comet。这种技术虽然可以双向通信，但依然需要反复发出请求。而且在Comet中，普遍采用的长链接，也会消耗服务器资源。</p>
<h2 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h2><p>短轮询的基本思路就是浏览器每隔一段时间向浏览器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。</p>
<p>　　这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立http连接，严重浪费了服务器端和客户端的资源。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。</p>
<p>　　因此短轮询不适用于那些同时在线用户数量比较大，并且很注重性能的Web应用。</p>
<h2 id="comet"><a href="#comet" class="headerlink" title="comet"></a>comet</h2><p>　comet指的是，当服务器收到客户端发来的请求后，不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)后关闭连接。
　
　</p>
<h2 id="基于Ajax的长轮询（long-polling）方式"><a href="#基于Ajax的长轮询（long-polling）方式" class="headerlink" title="基于Ajax的长轮询（long-polling）方式"></a>基于Ajax的长轮询（long-polling）方式</h2><p>长轮询是在打开一条连接以后保持，等待服务器推送来数据再关闭的方式。长轮询重点注意以下几点即可：<br>长轮询必须使用长连接<br>长轮询是一种服务器推数据的技术<br>长轮询实现服务器推数据的方法是hold住一个请求(当然你可以设置超时时间)，直到有数据了给客户端响应</p>
<p>浏览器发出XMLHttpRequest 请求，服务器端接收到请求后，会阻塞请求直到有数据或者超时才返回，浏览器JS在处理请求返回信息（超时或有效数据）后再次发出请求，重新建立连接。在此期间服务器端可能已经有新的数据到达，服务器会选择把数据保存，直到重新建立连接，浏览器会把所有数据一次性取回。</p>
<h1 id="长链接"><a href="#长链接" class="headerlink" title="长链接"></a>长链接</h1><p>使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。</p>
<p>在 HTTP 1.0 中, 没有官方的 keepalive 的操作。通常是在现有协议上添加一个指数。如果浏览器支持 keep-alive，它会在请求的包头中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Connection: Keep-Alive</div></pre></td></tr></table></figure>
<p>然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Connection: Keep-Alive</div></pre></td></tr></table></figure>
<p>这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。</p>
<p>在 HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。HTTP 持久连接不使用独立的 keepalive 信息，而是仅仅允许多个请求使用单个连接.</p>
<blockquote>
<p>长连接，主要描述的对象是一个TCP请求连接。当一个TCP通道一直保持着连接状态，即称这个连接为长连接。</p>
</blockquote>
<p>本质上理解，这是一种“多路复用”技术。在通信领域，多路复用技术是为了有效地利用通信线路,希望一个信道同时传输多路信号。可见这种本质上的道理都是相同的。<br>同样的理解，我们可以放到http2.0上。http2.0一个重要改进，其实就是在更加细的粒度上来应用“多路复用”技术。把一次request请求看成是一个“信道”，同时承载多个请求，从而改进了性能。</p>
<p><code>长连接描述的是TCP连接。在一个TCP连接中仍然可以发起多次请求，这个是不冲突的。</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;WebSocket是一种在单个TCP连接上进行全双工通讯的协议&lt;/p&gt;
&lt;p&gt;WebSocket使得客户端和服务器之间的数据交换变得更加简单
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Ecmascript" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Ecmascript/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js 基础" scheme="http://wiki.haoqiao.me/tags/js-%E5%9F%BA%E7%A1%80/"/>
    
      <category term="websocket" scheme="http://wiki.haoqiao.me/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/Vue/Vue/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/框架/Vue/Vue/</id>
    <published>2018-03-08T02:45:34.000Z</published>
    <updated>2018-03-08T02:50:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue构建过程原理"><a href="#vue构建过程原理" class="headerlink" title="vue构建过程原理"></a>vue构建过程原理</h2><h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><h2 id="Vue-1-0-vs-2-0"><a href="#Vue-1-0-vs-2-0" class="headerlink" title="Vue 1.0 vs 2.0"></a>Vue 1.0 vs 2.0</h2><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vue构建过程原理&quot;&gt;&lt;a href=&quot;#vue构建过程原理&quot; class=&quot;headerlink&quot; title=&quot;vue构建过程原理&quot;&gt;&lt;/a&gt;vue构建过程原理&lt;/h2&gt;&lt;h2 id=&quot;具体流程&quot;&gt;&lt;a href=&quot;#具体流程&quot; class=&quot;headerli
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="框架" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Vue" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/Vue/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://wiki.haoqiao.me/tags/vue/"/>
    
      <category term="vue 原理" scheme="http://wiki.haoqiao.me/tags/vue-%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>hash</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Ecmascript/hash/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/基础/Ecmascript/hash/</id>
    <published>2018-03-03T03:37:46.000Z</published>
    <updated>2018-03-03T03:39:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Hash"><a href="#什么是Hash" class="headerlink" title="什么是Hash"></a>什么是Hash</h1><p>hash表是一种二维结构，管理着一对对<key,value>这样的键值对。</key,value></p>
<blockquote>
<p>它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
</blockquote>
<p>　哈希表的做法其实很简单，就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。</p>
<p>而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是Hash&quot;&gt;&lt;a href=&quot;#什么是Hash&quot; class=&quot;headerlink&quot; title=&quot;什么是Hash&quot;&gt;&lt;/a&gt;什么是Hash&lt;/h1&gt;&lt;p&gt;hash表是一种二维结构，管理着一对对&lt;key,value&gt;这样的键值对。&lt;/key,value&gt;&lt;
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Ecmascript" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Ecmascript/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="hash" scheme="http://wiki.haoqiao.me/tags/hash/"/>
    
      <category term="hash 操作" scheme="http://wiki.haoqiao.me/tags/hash-%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>人类简史 - 摘记</title>
    <link href="http://wiki.haoqiao.me/wiki/%E9%98%85%E8%AF%BB/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"/>
    <id>http://wiki.haoqiao.me/wiki/阅读/人类简史/</id>
    <published>2018-03-02T10:27:23.000Z</published>
    <updated>2018-03-04T03:31:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公司过年寄过来的新年礼物中里面有一本&lt;&lt;人类简史&gt;&gt;，当时看到的时候有一种开心爆炸的感觉。因为过年正好要去乡下无网环境待几天。自己的书看的都差不多了，有一本符合自己胃口的书还是很难得的。事实上，这本书超出期待的好。概述就不概述了。直接将划好的摘记下来。然后就是把这本书给读小学的表弟，让他认真看，毕竟我又网购了后续的&lt;&lt;未来简史&gt;&gt;2333</p>
<p>PS: 实体书纯手打摘记简直要命QAQ</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><blockquote>
<p>自然选择让生产提前开始。与其他动物相比，人类可说都是早产儿。许多重要器官都发育不完整。看看小马，出生没多久就能开始小跑步；小猫出生不过几周，也能离开母亲自行觅食。相比较之下，人类的婴儿只能说毫无用处，许多年都得当个啃老族来被抚养、保护和教育。<br>人类之所以会有突出的社交技能，有一大原因正出自于此。独自一人的母亲，如果还得拖着孩子，就很难为自己和小孩取得足够的食物。所有，想养孩子，就需要其他家族成员和邻居持续提供协助。要养活一个小孩，得靠全部落共同的努力。<br>大多数哺乳动物脱离子宫的时候，就像是已经上釉的陶器出了窑。如果还想做什么调整，不是刮伤就是碎裂。然而，人类脱离子宫的时候，却像是从炉里拿出了一团刚融化的玻璃，可以旋转、拉升，可塑性高到令人叹为观止。正因如此，才会有人是基督徒或者佛教徒，有人好战、有人爱好和平。</p>
</blockquote>
<p>每个人可能都没真正意识到每个人都是”早产儿”，我从中读出了后天教育的重要性。当一个婴儿前几年最依赖的人的情况下，如果你未对其进行良好的教导或者说是陪伴，三岁看老并不只是说说而已。</p>
<blockquote>
<p>烹调让人类能吃的食物种类更多，减少所需的进食时间，还能缩小牙齿，减小肠的长度。不论是较长的肠道或者是较大的大脑，都必须消耗大量的能力，因此很难兼而有之。因为烹调的出现，人就能缩短肠道，降低能量消耗，可以说，可以再不经意之间，烹调让智人走上了让大脑更大的道路。</p>
</blockquote>
<p>冷门知识GET</p>
<blockquote>
<p>等到认知革命之后，智人有了八卦的能力，于是部落规模变得更大，也更稳定。然而，八卦也有限制。社会学研究指出，借由八卦来维持最大”自然”团体大约150人。只要超过这个数字，大多数人就无法真正深入了解、八卦所有成员的生活清醒。<br>即使到了今天，人类的团体还是继续受到这个神奇的数字影响。只要在150人之下，不论是社群、公司、社会网络还是军事单位，只要靠着大家认识、彼此互通消息，就能运作顺畅。</p>
</blockquote>
<p>冷门知识GET</p>
<blockquote>
<p>智人发明出了许许多多的想象现实，也因而发展处许许多多的行为模式，而这正是我们所谓”文化”的主要成分。等到文化出现，就再也无法停止改变和发展，这些无法阻挡的变化，就成了我们说的“历史”。</p>
<p>认知革命正是历史从生物学中脱离而独立存在的起点。</p>
<p>认知革命之后，我们要解释智人的发展，依赖的主要工具就不再是生物学理论，而改用历史叙事。就像是要理解为何儒家或共产主义能在中国传播，光知道基因。荷尔蒙和有机体这些还不够，另外也得考虑到各种想法、图像和幻想的互动才行。</p>
</blockquote>
<p>冷门知识GET</p>
<blockquote>
<p>大约15000年前就已经有了家犬，而它们实际加入人类生活的世界可能再往前推数千年。<br>经过这样15000年的相处，人和狗之间的理解和情感远超过人和其他动物的关系。</p>
</blockquote>
<p>之前看猫咪物语的时候，大概知道家猫加入人类的时间不过几千年。所以说🐶是比较聪明的，跟着人类能饿不死。</p>
<blockquote>
<p>农业革命真正的本质:让更多的人却以更糟的状态活下去。</p>
<p>其实人类在历史上一直不断重蹈覆辙，道理都相同：因为我们无法真正了解各种决定最后的结果。</p>
<p>而要怎样才能让人相信这些秩序？第一，对外的说法绝对要坚持他们千真万确，绝非虚构。永远要强调，这种维持社会稳定的秩序是一个客观事实，是由伟大的神或是自然的法则所创造。<br>第二，在教育上也要彻底贯彻同一套原则。从人出生的那一刻起，就要不断提醒他们这套想象建构出来的秩序。要在一切事物中融入于这套原则，不管是童话、戏剧、绘画、歌曲、礼仪、政治宣传、建筑、食谱还是时尚。</p>
</blockquote>
<p>这正是我们所经历的。</p>
<blockquote>
<p>虽然这些符号现在被称为”阿拉伯数字”，但其实是印度人发明的。因为印度人攻打印度时发现了这套实用的系统，再加以改良传到中东。</p>
</blockquote>
<p>知识点。</p>
<blockquote>
<p>这些阶级制度开始时多半只是因为历史上偶发意外，但部分群体取得既得利益之后，世世代代不断加以延续改良，才形成现在的样子。</p>
<p>文化总会说，它只禁止“不自然的事”。但从生物学的角度来看，这世界上根本没有什么是不自然的，只要有可能发生的事，就是自然。</p>
<p>想要确保“平等”，就得限制住那些较突出的人；而要人人都能“自由”，也就必然影响所有人的平等。</p>
<p>公元前的1000年间，出现了三种有可能达到全球一家概念的秩序。第一种是经济上的货币秩序。第二章是政治上的帝国秩序。第三中是宗教上的全球性宗教。</p>
<p>钱指的是概念，而不只是硬币或是钞票。不论任何物品，只要人类愿意使用，能够系统地代表其他物品的价值。以作为物品或服务交换之用。就可以说符合钱的概念。</p>
<p>有了金钱概念，财富的转换，存储和运送都变得更容易也更便宜，后来才能发展处复杂的商业网络以及蓬勃的市场经济。</p>
<p>“信任”正式所有金钱形式最基本的原料。<br>金钱正是有史以来最普遍也最有效的互信系统。</p>
<p>公元前640年，土耳其西部吕底亚铸造出史上第一批硬币。</p>
</blockquote>
<p>冷门知识。</p>
<blockquote>
<p>现代西方认为所谓公义的世界应该是由各个独立的民族国家组成，但古代中国的概念却正好相反，认为政治分裂的时代不仅动荡不安，而且公义不行。<br>中国每一个帝国朝代崩溃，这种政治理论主流就让各方竞逐的势力不安于各自为政，而一心追求统一。而且事实证明，最后总能统一，只是时间早晚问题。</p>
</blockquote>
<p>大一统思想，也有儒家思想的部分。</p>
<blockquote>
<p>释迦牟尼认为，人遇到事情通常就会产生欲念，而欲念总是会造成不满。遇到不喜欢的事，就想躲开，遇到喜欢的事情，就想维持并增加这份愉快。<br>正因为如此，人心永远不满，永远不安。</p>
<p>对某个时代的了解越透彻，反而越难解释为什么发生这个事件而不是那个事件。但如果对某个时代只是一知半解，就很容易受到结果影响，只看到那些最后成真的可能性。</p>
<p>社会上有两种贫穷:1.社会性的贫穷，指的是某些人掌握了机会，却不愿意释出给别人。2.生物性的贫穷，值得是因为缺乏食物和住所，而使人的生存受到威胁。</p>
</blockquote>
<p>现在大家面临的更多是第一种。而且这种差距会越来越大。</p>
<blockquote>
<p>科学并无力决定自己的优先级，也无法决定如何使用其发现。</p>
</blockquote>
<p>工具的使用更多在于人。</p>
<blockquote>
<p>先进后勤物流的贡献甚至更甚胜于武器机枪。</p>
<p>我们常常会把自己限于现状，声称“过去都是这样，未来也是这样”。</p>
</blockquote>
<p>拆掉思维里的墙，改变自我是获得提高的最快方法。不能局限于过去的生活状态，只要你想，你就能做，你就能改变达到想要的状态。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;公司过年寄过来的新年礼物中里面有一本&amp;lt;&amp;lt;人类简史&amp;gt;&amp;gt;，当时看到的时候有一种开心爆炸的感觉。因为过年正好要去乡下无网环
    
    </summary>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="读书笔记" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读后感" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
      <category term="自我提升" scheme="http://wiki.haoqiao.me/tags/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>近期日常与&lt;&lt;深度工作&gt;&gt;</title>
    <link href="http://wiki.haoqiao.me/wiki/%E9%98%85%E8%AF%BB/%E6%B7%B1%E5%BA%A6%E5%B7%A5%E4%BD%9C-%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E4%BD%BF%E7%94%A8%E6%AF%8F%E4%B8%80%E7%82%B9%E8%84%91%E5%8A%9B/"/>
    <id>http://wiki.haoqiao.me/wiki/阅读/深度工作-如何有效使用每一点脑力/</id>
    <published>2018-02-26T01:59:05.000Z</published>
    <updated>2018-02-26T05:12:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>年后回来开始基于之前的一些日常习惯进行了更好的修正。然后碰巧又遇到了几个不错，有意思的APP,然后又心血来潮将去年想要完成的一些计划进行丰富。比如之前毫无目的的学英语这种，我就拖到了今年开始。</p>
<p>其实这是在我去年考完后给自己写了一些来年展望中:</p>
<blockquote>
<p>重新对生活和学习做一些计划和安排，让自己对新的一年有更强的控制。</p>
</blockquote>
<p>虽然17年底实践了一部分，也取得了一些进展，比如毕设大部分难题都解决了。但是会有一种控制程度还是蛮低的情况。</p>
<p>这几天晚上看完了&lt;&lt;睡眠革命&gt;&gt;,&lt;&lt;深度工作-如何有效使用每一点脑力&gt;&gt;，边看边实践修改作息。</p>
<p>现阶段我的作息大概是早上8点多起，因为开窗大概7点就会醒来。然后用一些时间调整一下。<br>之后是看keep训练计划，有的话就喝点热水然后运动，然后早饭。<br>之后是看实体书，用钢笔做些摘抄。这个是为了让自己开始适应深度的工作状态，让注意力开始集中。<br>然后就是花时间去解决一下其它琐碎的事情，比如出门买菜。或者去完成每日的知识点总结。然后刷下咨询。<br>再之后会开始毕设的一些开发，因为每天都会给明天安排好，因此状态进入还算快的。<br>当然当中也会分心去刷刷咨询，聊天什么的。这是需要控制解决的。<br>然后午饭，然后下午回来先继续工作一会。这个是看个人的状态，一般情况下这个点对我来说专注力大概是中等，对毕设来讲也是够用了。<br>然后是2点多睡个午觉，这个看情况，有时候一下子就睡到4点也是有的。。。<br>然后起床搞搞毕设，没心情就开始英语学习，现阶段目标是刷一本英语书，然后把生词导入到百词斩。<br>基本晚饭前也能工作一会。<br>晚饭后状态一般都比较好，能够把大部分的任务完成顺便给明天做计划总结。<br>这个时候搞完其实还有一段时间的空白，在下午到晚饭之前其实会有一些疲惫期，我都通过看看炉石视频或者刷刷咨询渡过。如果switch到手，可以用游戏渡过。<br>基本上9点到十点之前能把每日工作超额完成。<br>然后是躺床上背背单词，然后看英文的演讲视频，这个也不长，对我来讲还是挺享受的。因为我都是看中英文对照2333，现在学习英语不是强制的，因此我都是看兴趣去挑输入的。<br>然后是用Ipad看网易蜗牛屯的书。大概每天阅读时间我能达到2个小时左右(包括实体书和电子书)。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>&lt;&lt;深度工作-如何有效使用每一点脑力&gt;&gt;这本书是我摘记最多的。里面的规则作者本人也从中受益良多。</p>
<blockquote>
<p>想要在社会经济中保持价值，就必须掌握快速学习复杂技能的艺术。这项任务要求深度工作。如果你不培养这项能力，就很可能随着技术的更新而被淘汰</p>
</blockquote>
<p>这重点提出了<code>深度工作</code>重要性，其实举个简单的例子，当人把思绪全投入到工作，你会发现工作起来是真的很顺利，进度biubiu的上涨。</p>
<blockquote>
<p>浮浅工作（Shallow Work）：对认知要求不高的事务性任务，往往在受到干扰的情况下开展。此类工作通常不会为世界创造太多新价值，且容易复制。</p>
</blockquote>
<p>浮浅工作往往就是我们正常分心工作的状态。</p>
<blockquote>
<p>如果在你所处的工作环境下，提出问题能够立刻得到答案，需要某一特定信息能够立刻得到，那么你的生活就会变得更简单，至少在当时是这样的。如果无法得到这样迅速的响应，你就需要做更多的预先工作计划，需要更具条理性，同时还要时刻准备暂时搁置工作，将注意力转移到别处，等待所提要求达成。所有这些都将使你的日常工作生活更加艰难.</p>
</blockquote>
<p>所以我认为在正式工作之前其实是需要做一些准备来帮助自己排除一些干扰，虽然无法百分百，但是至少让你能够进入状态更加迅速。</p>
<blockquote>
<p>知识工作者之所以远离深度工作，原因显而易见——网络工具。</p>
</blockquote>
<p>对于程序员来讲，网络的影响可能更复杂，因为工作需要依赖但是干扰也随之增多。<br>曾经看过一些文章作者会在工作中把通讯工具关闭，以及通过一些限制来减少干扰。</p>
<blockquote>
<p>如果你不产出，就不会成功，不管你的技艺多么纯熟，天资多么聪颖。</p>
</blockquote>
<p>这里的产出指你你工作之后对整个项目或者公司有什么好的影响，或者是对其他人有什么好的影响。<br>这其实就是我们经常会造成的误差，认为我们工作了就是产出。这其实还是有很大区别。如果你想成为领域中的翘楚，掌握相关技能是必需的，但并不够。之后你必须将潜能转化成人们珍视的实在成果。</p>
<blockquote>
<p>如果你无法学习，就无法成功。</p>
<p>（1）你的注意力全情投入到某个你希望提升的技能或想要掌握的理念上；（2）你能得到反馈意见，这样你就可以调整自己的方法，保持注意力的投入有最佳产出。第一个要素对于我们的探讨尤为重要，因其强调了刻意练习不能在有干扰的情况下进行，要求在无干扰状态下保持专注。恰如艾利克森所强调的：“注意力涣散基本上与刻意练习要求的聚精会神是相对立的。”</p>
</blockquote>
<p>进入深度工作，或者让自己变得更容易进入专注状态，那么我们需要刻意去练习实践。</p>
<blockquote>
<p>要达到个人巅峰的产出效率，你需要长时间、无干扰地高度专注于单一任务。换一种说法，使你的表现最优化的做法是深度工作。如果你无法做到长时间深度工作，就很难使你的表现达到质量和数量的巅峰，而这种巅峰状态对于你的职业成功越来越重要。</p>
<p>当你从某项任务 A 转移到任务 B 时，你的注意力并没有即时转移，你的注意力残留仍然在思考原始任务。如果在转移工作之前，你对任务 A 缺乏控制且关注度较低，残留会尤其浓厚，但即使你在转移工作之前已经完成了任务 A，你的注意力还是会有一段分散的时间。</p>
</blockquote>
<p>这其实深有体会，这就是切换工作会有一种粘稠感，比如你在进入深度工作状态，突然一些其它工作需要你处理，那个时候状态其实是最差的。因为心思无法迅速转移，当然也无法再回到刚刚的状态。</p>
<blockquote>
<p>在长时间无干扰的状态下，批量解决困难却重要的智力工作。</p>
</blockquote>
<p>这就属于个人的任务安排，将自己最好的时间状态拿来处理最紧要的事情，这样即使无法解决问题，但至少能够留下不少解决思路。</p>
<blockquote>
<p>节奏日程安排者通过雷打不动的惯例支持深度工作，确保能够定期完成一定的工作，在一年的时间里往往能够累积更多的深度工作时长。</p>
</blockquote>
<p>这其实很像细水长流法，不管做多少，总归需要去完成一部分。这样日积月累，效果可观。回想我过去几年的学习习惯，其实也带有一点这个节奏的感觉。因为开发编程其实也是能够成为一种节奏化的日常。刻意训练往往在日积月累下就能有一定的突破机会。</p>
<blockquote>
<p>轻松启动深度工作的最好方法就是将其转化成一种简单的常规习惯。换言之，其目标是创造一种工作节奏，让你不需要你投入精力便可以决定是否需要以及何时需要进入深度状态。</p>
<p>双峰哲学的深度工作。这种哲学要求你将个人时间分成两块，将某一段明确的时间用于深度追求，余下的时间做其他所有事情。</p>
<p>所谓的禁欲主义哲学的深度工作日程安排。这种哲学通过摒弃或最小化浮浅职责，从而实现深度工作的最大化。禁欲主义哲学的实践者往往有明确且价值极高的职业目标追求，而且他们在职业上取得的大部分成就都是由于工作表现特别突出。这种清晰的状态使他们能够排除纷杂的浮浅关注点，而这些浮浅关注点恰恰是那些在工作世界中价值定位复杂化之人的梦魇。</p>
<p>这些举动推动你的深度目标占据心理优先的地位，有助于你解锁必要的心理资源。</p>
<p>对周围惯常环境做出巨大改变，辅以可观的精力或金钱投入，都只为支持一项深度工作任务，由此你也提升了这项任务的外现重要性。这种重要性的提升，降低了你的大脑继续拖延的本能，并注入了激励和能量。</p>
</blockquote>
<p>这其实很像花钱去买自己的专注力，这有时候还是有必要的，因为当你无法让你自己通过主观能动性调动自己进入深度状态，那么你至少可以借助一些外物帮你。只要付出值得。</p>
<blockquote>
<p>有时想要做到深入，必须要先做大。</p>
<p>每周回顾自己的计分板，庆贺表现好的一周，理清是什么导致了表现糟糕的一周，而且最重要的是找出能够确保未来几天得到好分数的方法。此举使我不断调整日程计划，以满足引领性指标的要求，大幅增加深度工作时间。</p>
</blockquote>
<p>这其实就是古话常说的吾日三省吾身。</p>
<p>我现在每天都有做类似日报的东西，这是在公司实习留下来的。我感觉用到日常工作中也蛮好。<br>我不会写很复杂的东西，一般就是今天做了什么？一些思考。明日计划。</p>
<p>这三者能帮助我定位到今天的工作和作息。</p>
<p>但是没有进行一些量化的操作。比如我进入深入工作的时间等等。</p>
<p>我觉得在这方面可以加强一下。</p>
<blockquote>
<p>你想做的事情越多，完成的事情反而越少<br>执行需要专注于少量“极端重要的目标”。这样简化选择，有助于组织和集中足够的精力来达成实在的成果</p>
</blockquote>
<p>这其实就是做事情不要贪多，而是优先级最高的最先完成。</p>
<blockquote>
<p>培养深度工作的习惯，关键在于越过良好的意图，在工作生活中加入一些特别设计的惯例和固定程序，使得进入并保持高度专注状态消耗的意志力最小化。<br>如果你能够布置一些精妙的惯例和固定程序，比如每天下午安排特定的时间或安静的场所用于完成深度任务，就只需很少的意志力便能启动工作并保持下去。从长远看，你会因此更成功地实现深度工作。</p>
</blockquote>
<p>我的做法是通过一些白噪音来帮助自己进入状态。</p>
<blockquote>
<p>你的意志力是有限的，它在使用的过程中会被不断消耗。<br>你的意志力并非性格的展现，可以无限制地使用；相反，它恰如肌肉一般，会疲劳。<br>我们需要更深入地探究深度工作的主要障碍之一：将注意力转移到某种肤浅事物上的冲动。大多数人都能意识到这种冲动会使专注于困难工作的努力变得无效，但是大多数人低估了这种冲动出现的频率及其力量</p>
</blockquote>
<p>这要求人们将自己的意志力作为一种游戏中的魔法值，它是会消耗的，只有通过时间自动恢复或者隔一段时间放松一下，让其能够回到正常值。不然任意消耗，等下连个小事情都无法完成。</p>
<blockquote>
<p>深度工作需要专注的强度远远超出了大部分知识工作者的舒适区。<br>当你发现某个想法偷走了你的注意力时，温柔地提醒自己可以稍后再回到这个想法上，现在先把你的注意力收回来。</p>
</blockquote>
<p>这个方法对我还是比较有用的，我自己每每劝住自己都是这个想法可以等会做，先把正在进行的一波流带走，这样等会就会心情愉悦的完成这个想法。</p>
<blockquote>
<p>一旦你的大脑习惯了随时分心，即使在你想要专注的时候，也很难摆脱这种积习。更具体地说：如果你生活中潜在的每一刻无聊时光——比如说，需要排队等 5 分钟或者是在餐厅坐等朋友——都是用浏览智能手机来打发，那么你的大脑就可能已经被重新编排，从某种程度上说，就像是纳斯研究所里说的“心智残疾”。这时你的大脑已经不能够胜任深度工作，即使你也会经常安排时间来训练专注的能力。</p>
</blockquote>
<p>其实大部分人已经“心智残疾”，碎片化阅读，无法停止的即时聊天。这些都是对我们影响较大的。这才让我们去训练自己深度工作。这样你对自己的思维掌握程度会更高，对自己的生活和工作安排有更好计划和执行力。</p>
<blockquote>
<p>你知道如何去做，也知道它对你有益，但是因为缺少动力，你经常会忽视它。这种定式思维十分流行。它暗示：只要你获得足够的动力，就可以瞬间转变自己散乱的工作生活，变得专注起来。然而，这种想法忽视了做到专注的难度，忽视了增强“心智力量”需要一定时间的练习。</p>
</blockquote>
<p>这就是做和想的区别。只有完成的计划叫做计划，其它叫做梦。</p>
<blockquote>
<p>人的智力系统可以进行长时间的高强度活动：它不像人的手脚一样会疲倦。除睡觉以外，它只需要变化，而不是停止。</p>
</blockquote>
<p>这点真的令我震惊，因为回顾一下以往的生活，其实你明明可以去用来提升自己的工作后时间，比如健身或者阅读。却被自己用我的精力耗尽了，我需要休息玩一下。我的大脑已经用完今天的智力了。这其实都是借口，但是这种借口却很难去打破。因为自己想骗自己，多烂的借口自己都会相信。</p>
<blockquote>
<p>你应该也能够主动利用自己工作外的时间和精力——直到今天仍不过时，尤其是对于本准则背后的目标而言。这个目标就是减少网络工具对你深度工作能力的干扰。<br>职业和个人生活中决定成功与幸福的核心因素。只有一种工具对这些因素的实际益处大于实际害处时才选择这种工具。<br>任何益处思维定式认为任何潜在的益处都可以成为使用此工具的借口，手艺人方法要求这些益处能够影响到核心因素，并且益处大于害处。</p>
</blockquote>
<p>摆脱令自己分心沉迷的事情，它可能是一些小习惯，或者是一些干扰。当你能够像清理灰尘一样用一定的时间去清理后再去无干扰的工作。你会发现自己的效率其实已经变得完全不同。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;年后回来开始基于之前的一些日常习惯进行了更好的修正。然后碰巧又遇到了几个不错，有意思的APP,然后又心血来潮将去年想要完成的一些计划进行丰富
    
    </summary>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="读书笔记" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读后感" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
      <category term="自我提升" scheme="http://wiki.haoqiao.me/tags/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://wiki.haoqiao.me/wiki/%E8%BF%9B%E9%98%B6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://wiki.haoqiao.me/wiki/进阶/设计模式/设计模式/</id>
    <published>2018-02-25T01:48:04.000Z</published>
    <updated>2018-03-02T02:27:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计一个订阅者发布者的基类"><a href="#设计一个订阅者发布者的基类" class="headerlink" title="设计一个订阅者发布者的基类"></a>设计一个订阅者发布者的基类</h1><blockquote>
<p>观察者模式（Observer）：<br>又叫发布-订阅者模式（Publish/Subscribe）或消息机制，<br>它定义了一种一对多的关系，让多个观察者对象同时监听某一个主体对象，<br>这个主体对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</p>
</blockquote>
<h2 id="模式起源"><a href="#模式起源" class="headerlink" title="模式起源"></a>模式起源</h2><p><code>建立一种对象与对象之间的依赖关系</code>，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。</p>
<p><img src="http://haoqiao.qiniudn.com/fabudingyuemoishi.png" alt="imgn"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 背景：评论+消息通知</div><div class="line"></div><div class="line">/*</div><div class="line"> * 观察者模式</div><div class="line"> *</div><div class="line"> * 将观察者放在闭包中，当页面加载就立即执行</div><div class="line"> */</div><div class="line">var Observer = (function() &#123;</div><div class="line">  // 防止消息队列暴漏而被篡改，故将消息容器作为静态私有变量保存。</div><div class="line">  var __message = &#123;&#125;;</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    // 订阅</div><div class="line">    subscribe: function(type, fn) &#123;</div><div class="line">      // 如果消息不存在则创建一个消息类型</div><div class="line">      if (!__message[type]) &#123;</div><div class="line">        __message[type] = [fn];</div><div class="line">      &#125; else &#123;</div><div class="line">        // 将动作方法推送到消息对应的动作执行序列中</div><div class="line">        __message[type].push(fn);</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // 取消订阅</div><div class="line">    unsubscribe: function(type, fn) &#123;</div><div class="line">      if (!__message[type] || Object.prototype.toString.call(__message[type]) !== &apos;[object Array]&apos;) return;</div><div class="line"></div><div class="line">      for (var i = __message[type].length - 1; i &gt;= 0; i--) &#123;</div><div class="line">        __message[type][i] === fn &amp;&amp; __message[type].splice(i, 1);</div><div class="line">      &#125;;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // 发布信息</div><div class="line">    publish: function(type, args) &#123;</div><div class="line">      if (!__message[type]) return;</div><div class="line"></div><div class="line">      // 定义消息信息</div><div class="line">      var events = &#123;</div><div class="line">        type: type,</div><div class="line">        args: args</div><div class="line">      &#125;;</div><div class="line"></div><div class="line">      // 执行注册的消息所对应的所有动作序列</div><div class="line">      for (var i = 0; i &lt; __message[type].length; i++) &#123;</div><div class="line">        __message[type][i].call(this, events);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line"> * 拉出来溜溜</div><div class="line"> */</div><div class="line"></div><div class="line">// 订阅</div><div class="line">Observer.subscribe(&apos;test&apos;, function(e) &#123;</div><div class="line">  console.log(e);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 发布</div><div class="line">Observer.publish(&apos;test&apos;, &#123;msg: &apos;传递参数&apos;&#125;);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line"> * 观察者模式</div><div class="line"> *</div><div class="line"> * 将观察者放在闭包中，当页面加载就立即执行</div><div class="line"> */</div><div class="line">var Observer = (function() &#123;</div><div class="line">  // 防止消息队列暴漏而被篡改，故将消息容器作为静态私有变量保存。</div><div class="line">  var __message = &#123;&#125;;</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    // 注册信息接口（订阅）</div><div class="line">    subscribe: function(type, fn) &#123;</div><div class="line">      // 如果消息不存在则创建一个消息类型</div><div class="line">      if (!__message[type]) &#123;</div><div class="line">        __message[type] = [fn];</div><div class="line">      &#125; else &#123;</div><div class="line">        // 将动作方法推送到消息对应的动作执行序列中</div><div class="line">        __message[type].push(fn);</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // 发布消息接口（取消订阅）</div><div class="line">    unsubscribe: function(type, fn) &#123;</div><div class="line">      if (!__message[type] || Object.prototype.toString.call(__message[type]) !== &apos;[object Array]&apos;) return;</div><div class="line"></div><div class="line">      for (var i = __message[type].length - 1; i &gt;= 0; i--) &#123;</div><div class="line">        __message[type][i] === fn &amp;&amp; __message[type].splice(i, 1);</div><div class="line">      &#125;;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // 移除信息接口（移除信息接口）</div><div class="line">    publish: function(type, args) &#123;</div><div class="line">      if (!__message[type]) return;</div><div class="line"></div><div class="line">      // 定义消息信息</div><div class="line">      var events = &#123;</div><div class="line">        type: type,</div><div class="line">        args: args</div><div class="line">      &#125;;</div><div class="line"></div><div class="line">      // 执行注册的消息所对应的所有动作序列</div><div class="line">      for (var i = 0; i &lt; __message[type].length; i++) &#123;</div><div class="line">        __message[type][i].call(this, events);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">// 外观模式</div><div class="line">function $(id) &#123;</div><div class="line">  return document.getElementById(id);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 工程师A</div><div class="line">(function() &#123;</div><div class="line"></div><div class="line">  // 新增一条消息</div><div class="line">  function addMsgItem(e) &#123;</div><div class="line">    var text = e.args.text;</div><div class="line">    var ul = $(&apos;msg&apos;);</div><div class="line">    var li = document.createElement(&apos;li&apos;);</div><div class="line">    var span = document.createElement(&apos;span&apos;);</div><div class="line"></div><div class="line">    li.innerHTML = text;</div><div class="line"></div><div class="line">    // 关闭按钮</div><div class="line">    span.onclick = function() &#123;</div><div class="line">      ul.removeChild(li);</div><div class="line"></div><div class="line">      Observer.publish(&apos;removeCommentMessage&apos;, &#123;</div><div class="line">        num: -1</div><div class="line">      &#125;);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    ul.appendChild(span);</div><div class="line">    ul.appendChild(li);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Observer.subscribe(&apos;addCommentMessage&apos;, addMsgItem);</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">// 工程师B</div><div class="line">(function() &#123;</div><div class="line"></div><div class="line">  // 修改用户消息数目</div><div class="line">  function changeMsgNum(e) &#123;</div><div class="line">    var num = e.args.num;</div><div class="line">    $(&apos;msg_num&apos;).innerHTML = parseInt($(&apos;msg_num&apos;).innerHTML || 0) + 1;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 注册添加评论信息</div><div class="line">  Observer.subscribe(&apos;addCommentMessage&apos;, changeMsgNum);</div><div class="line">  Observer.subscribe(&apos;removeCommentMessage&apos;, changeMsgNum);</div><div class="line"></div><div class="line">&#125;)();</div><div class="line"></div><div class="line"></div><div class="line">// 工程师C</div><div class="line">(function() &#123;</div><div class="line"></div><div class="line">  // 用户点击提交按钮</div><div class="line">  $(&apos;user_submit&apos;).onclick = function() &#123;</div><div class="line">    var text = $(&apos;user_input&apos;);</div><div class="line"></div><div class="line">    if (!text.value) return;</div><div class="line"></div><div class="line">    Observer.publish(&apos;addCommentMessage&apos;, &#123;</div><div class="line">      text: text.value,</div><div class="line">      num: 1</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    text.value = &apos;&apos;;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">&#125;)();</div><div class="line"></div><div class="line">/*</div><div class="line"> * 测试HTML</div><div class="line"> *</div><div class="line"> *  &lt;div id=&quot;msg&quot;&gt;&lt;/div&gt;</div><div class="line"> *  &lt;input type=&quot;text&quot; id=&quot;user_input&quot; /&gt;</div><div class="line"> *  &lt;button id=&quot;user_submit&quot;&gt;submite&lt;/button&gt;</div><div class="line"> *  &lt;div id=&quot;msg_num&quot;&gt;&lt;/div&gt;</div><div class="line"> */</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">/*</div><div class="line"> * 观察者模式</div><div class="line"> *</div><div class="line"> * 将观察者放在闭包中，当页面加载就立即执行</div><div class="line"> */</div><div class="line">var Observer = (function() &#123;</div><div class="line">  // 防止消息队列暴漏而被篡改，故将消息容器作为静态私有变量保存。</div><div class="line">  var __message = &#123;&#125;;</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    // 注册信息接口（订阅）</div><div class="line">    subscribe: function(type, fn) &#123;</div><div class="line">      // 如果消息不存在则创建一个消息类型</div><div class="line">      if (!__message[type]) &#123;</div><div class="line">        __message[type] = [fn];</div><div class="line">      &#125; else &#123;</div><div class="line">        // 将动作方法推送到消息对应的动作执行序列中</div><div class="line">        __message[type].push(fn);</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // 发布消息接口（取消订阅）</div><div class="line">    unsubscribe: function(type, fn) &#123;</div><div class="line">      if (!__message[type] || Object.prototype.toString.call(__message[type]) !== &apos;[object Array]&apos;) return;</div><div class="line"></div><div class="line">      for (var i = __message[type].length - 1; i &gt;= 0; i--) &#123;</div><div class="line">        __message[type][i] === fn &amp;&amp; __message[type].splice(i, 1);</div><div class="line">      &#125;;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // 移除信息接口（移除信息接口）</div><div class="line">    publish: function(type, args) &#123;</div><div class="line">      if (!__message[type]) return;</div><div class="line"></div><div class="line">      // 定义消息信息</div><div class="line">      var events = &#123;</div><div class="line">        type: type,</div><div class="line">        args: args</div><div class="line">      &#125;;</div><div class="line"></div><div class="line">      // 执行注册的消息所对应的所有动作序列</div><div class="line">      for (var i = 0; i &lt; __message[type].length; i++) &#123;</div><div class="line">        __message[type][i].call(this, events);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"></div><div class="line">// 学生类</div><div class="line">var Student = function(result) &#123;</div><div class="line">  var self = this;</div><div class="line"></div><div class="line">  // 学生回答结果</div><div class="line">  self.result = result;</div><div class="line"></div><div class="line">  // 学生回答问题动作</div><div class="line">  self.say = function() &#123;</div><div class="line">    console.log(self.result);</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 回答问题方法</div><div class="line">Student.prototype.answer = function(question) &#123;</div><div class="line">  // 注册参数问题</div><div class="line">  Observer.subscribe(question, this.say);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Student.prototype.sleep = function(question) &#123;</div><div class="line">  Observer.unsubscribe(question, this.say);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">// 教师类</div><div class="line">var Teacher = function() &#123;&#125;;</div><div class="line">Teacher.prototype.ask = function(question) &#123;</div><div class="line">  console.log(&apos;问题是：&apos; + question);</div><div class="line">  // 发布提问消息</div><div class="line">  Observer.publish(question);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">// 模拟听课的学生</div><div class="line">var student1 = new Student(&apos;学生1回答问题&apos;);</div><div class="line">var student2 = new Student(&apos;学生2回答问题&apos;);</div><div class="line">var student3 = new Student(&apos;学生3回答问题&apos;);</div><div class="line"></div><div class="line">// 注册一下哪位学生回答什么问题</div><div class="line">student1.answer(&apos;什么是设计模式&apos;);</div><div class="line">student1.answer(&apos;简述观察者模式&apos;);</div><div class="line">student2.answer(&apos;什么是设计模式&apos;);</div><div class="line">student3.answer(&apos;什么是设计模式&apos;);</div><div class="line">student3.answer(&apos;简述观察者模式&apos;);</div><div class="line"></div><div class="line">// 后来第三位同学睡着了。。</div><div class="line">student3.sleep(&apos;简述观察者模式&apos;);</div><div class="line"></div><div class="line"></div><div class="line">var teacher = new Teacher();</div><div class="line"></div><div class="line">// 提问</div><div class="line">teacher.ask(&apos;什么是设计模式&apos;);</div><div class="line">teacher.ask(&apos;简述观察者模式&apos;);</div><div class="line"></div><div class="line">// 最后，两个问题，第一个问题三名同学回答，第二个问题只有第一名同学回答。。。</div></pre></td></tr></table></figure>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li>
<li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li>
<li>观察者模式支持广播通信。</li>
<li>观察者模式符合“开闭原则”的要求。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ul>
<h2 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h2><p>在以下情况下可以使用观察者模式：</p>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
</ul>
<h1 id="手写给出一个工厂方法实现"><a href="#手写给出一个工厂方法实现" class="headerlink" title="手写给出一个工厂方法实现"></a>手写给出一个工厂方法实现</h1><p>工厂方法其实很多种，因为其作用很大，因此变种也比较多。</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><blockquote>
<p>静态工厂方法。由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象</p>
</blockquote>
<p><img src="http://haoqiao.qiniudn.com/jiandangongchan.png" alt="imgn"></p>
<p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//工厂模式</div><div class="line"></div><div class="line">function createFactory(type,text)&#123;</div><div class="line">    var o  = new Object()</div><div class="line">    o.content = text</div><div class="line">    o.show = function()&#123;</div><div class="line">        console.log(o.content)</div><div class="line">    &#125;</div><div class="line">    if(type == &apos;a&apos;)&#123;</div><div class="line">        o.content = text + &quot;666&quot;</div><div class="line">    &#125;</div><div class="line">    if(type == &apos;b&apos;)&#123;</div><div class="line">      o.content = text + &quot;888&quot;</div><div class="line">    &#125;    </div><div class="line">  return o</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">var test = createFactory(&apos;a&apos;,&apos;2333&apos;)</div><div class="line">test.show()</div></pre></td></tr></table></figure>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li>
<li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li>
<li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li>
<li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li>
<li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ul>
<h3 id="适用环境-1"><a href="#适用环境-1" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用简单工厂模式：</p>
<ul>
<li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li>
</ul>
<h2 id="工厂方法模式-Factory-Method-Pattern"><a href="#工厂方法模式-Factory-Method-Pattern" class="headerlink" title="工厂方法模式(Factory Method Pattern)"></a>工厂方法模式(Factory Method Pattern)</h2><p>通过对产品类的抽象使其创建业务主要负责于创建多类产品的实例。不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成，我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例。</p>
<p>工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>
<p><img src="http://haoqiao.qiniudn.com/6C869292-9380-4C95-AF93-521293095D45.png" alt="imgn"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">var Factory = function(type, text) &#123;</div><div class="line">  if (this instanceof Factory) &#123;</div><div class="line">    this[type](text);</div><div class="line">  &#125; else &#123;</div><div class="line">    return new Factory(type, text);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Factory.prototype = &#123;</div><div class="line">  javascript: function(text) &#123;</div><div class="line">    console.log(text + &apos;javascript&apos;);</div><div class="line">  &#125;,</div><div class="line">  nodejs: function(text) &#123;</div><div class="line">    console.log(text + &apos;nodejs&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Factory(&apos;javascript&apos;, &apos;万能的&apos;);</div></pre></td></tr></table></figure>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li>
<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li>
<li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li>
</ul>
<h3 id="适用环境-2"><a href="#适用环境-2" class="headerlink" title="适用环境"></a>适用环境</h3><p>一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</p>
<h2 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式(Abstract Factory)"></a>抽象工厂模式(Abstract Factory)</h2><p>  通过对类的工厂抽象使其业务用于对产品类簇的创建 而不负责创建某一类产品的实例。</p>
<p>  抽象类的作用：定义一个产品簇，声明一些必备的方法，如果子类中没有去重写就会抛出错误。</p>
<p>  抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。<br>  <img src="http://haoqiao.qiniudn.com/83722450-D45D-4386-BA10-9382808B841E.png" alt="imgn"></p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">var VehicleFactory = function(subClass, superType) &#123;</div><div class="line"></div><div class="line">  // 判断抽象工厂中是否有该抽象类</div><div class="line">  if (typeof VehicleFactory[superType] === &apos;function&apos;) &#123;</div><div class="line"></div><div class="line">    // 缓存类</div><div class="line">    function F() &#123;&#125;</div><div class="line"></div><div class="line">    // 继承父类属性和方法</div><div class="line">    F.prototype = new VehicleFactory[superType]();</div><div class="line"></div><div class="line">    // 将子类constructor指向子类</div><div class="line">    F.constructor = subClass;</div><div class="line"></div><div class="line">    // 子类原型继承”父类“</div><div class="line">    subClass.prototype = new F();</div><div class="line">  &#125; else &#123;</div><div class="line">    throw new Error(&apos;未创建该抽象类&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 小汽车抽象类</div><div class="line">VehicleFactory.Car = function() &#123;</div><div class="line">  this.type = &apos;car&apos;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">VehicleFactory.Car.prototype = &#123;</div><div class="line">  getPrice: function() &#123;</div><div class="line">    return new Error(&apos;抽象方法不能调用&apos;);</div><div class="line">  &#125;,</div><div class="line">  getSpeed: function() &#123;</div><div class="line">    return new Error(&apos;抽象方法不能调用&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 公交车抽象类</div><div class="line">VehicleFactory.Bus = function() &#123;</div><div class="line">  this.type = &apos;bus&apos;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">VehicleFactory.Bus.prototype = &#123;</div><div class="line">  getPrice: function() &#123;</div><div class="line">    return new Error(&apos;抽象方法不能调用&apos;);</div><div class="line">  &#125;,</div><div class="line">  getSpeed: function() &#123;</div><div class="line">    return new Error(&apos;抽象方法不能调用&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 货车抽象类</div><div class="line">VehicleFactory.Truck = function() &#123;</div><div class="line">  this.type = &apos;truck&apos;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">VehicleFactory.Truck.prototype = &#123;</div><div class="line">  getPrice: function() &#123;</div><div class="line">    return new Error(&apos;抽象方法不能调用&apos;);</div><div class="line">  &#125;,</div><div class="line">  getSpeed: function() &#123;</div><div class="line">    return new Error(&apos;抽象方法不能调用&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 宝马汽车子类</div><div class="line">var BMW = function(price, speed) &#123;</div><div class="line">  this.price = price;</div><div class="line">  this.speed = speed;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">VehicleFactory(BMW, &apos;Car&apos;);</div><div class="line"></div><div class="line">BMW.prototype.getPrice = function() &#123;</div><div class="line">  return this.price;</div><div class="line">&#125;;</div><div class="line">BMW.prototype.getSpeed = function() &#123;</div><div class="line">  return this.speed;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = new BMW(100, 2);</div><div class="line"></div><div class="line">console.log(a.getPrice());</div><div class="line">console.log(a.type);</div></pre></td></tr></table></figure>
<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul>
<li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li>
<li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。、</li>
</ul>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li>
<li>开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。</li>
</ul>
<h3 id="适用环境-3"><a href="#适用环境-3" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用抽象工厂模式：</p>
<ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<h1 id="手写给出一个策略模式实现"><a href="#手写给出一个策略模式实现" class="headerlink" title="手写给出一个策略模式实现"></a>手写给出一个策略模式实现</h1><p>策略模式（Strategy）：将定义的一组算法封装起来，使其相互之间可以替换。<br>封装的算法具有一定独立性，不会随客户端变化而变化。</p>
<p>策略模式最主要的特色是创建一系列策略算法，每组算法处理的业务都是相同的，<br>只是处理的过程或者处理的结果不一样，所以它们又是可以相互替换的，<br>这样就解决了算法与使用者之间的耦合。在测试层面上讲，由于每组算法相互之间的独立性，<br>该模式更方便与对每组算法进行单元测试，保证算法的质量。</p>
<p><img src="http://haoqiao.qiniudn.com/E08C1EB7-63E9-4001-9FBE-DB7B8936ACFF.png" alt="imgn"></p>
<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><ul>
<li>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。</li>
<li>在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。</li>
<li>在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。</li>
<li>除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</li>
<li>为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。</li>
</ul>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 背景：过节商品打折，一部分商品5折出售，一部分8折出售，一部分商品9折出售，等到元旦，我们要搞一个幸运反馈活动，普通用户满100返30，高级VIP用户满100返50... </div><div class="line"></div><div class="line">// 价格策略对象</div><div class="line">var PriceStrategy = (function() &#123;</div><div class="line">  // 内部算法对象</div><div class="line">  var stragtegy = &#123;</div><div class="line"></div><div class="line">    // 100返30</div><div class="line">    return30: function(price) &#123;</div><div class="line">      return +price + parseInt(price / 100) * 30;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // 满100返50</div><div class="line">    return50: function(price) &#123;</div><div class="line">      return +price + parseInt(price / 100) * 50;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // 九折</div><div class="line">    percent90: function(price) &#123;</div><div class="line">      return 90 / 100 * +price;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // 八折</div><div class="line">    percent80: function(price) &#123;</div><div class="line">      return 80 / 100 * +price;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // 五折</div><div class="line">    percent50: function(price) &#123;</div><div class="line">      return 50 / 100 * +price;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  // 策略算法调用接口</div><div class="line">  return function(algorithm, price) &#123;</div><div class="line">    // 如果算法存在，则调用算法，否则返回false</div><div class="line">    return stragtegy[algorithm] &amp;&amp; stragtegy[algorithm](price);</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">var price = PriceStrategy(&apos;return50&apos;, &apos;314.67&apos;);</div><div class="line">console.log(price); // 464.67</div><div class="line"></div><div class="line">var InputStrategy = (function() &#123;</div><div class="line">  var strategy = &#123;</div><div class="line">    isNumber: function(value) &#123;</div><div class="line">      return Object.prototype.toString.call(value) === &apos;[object Array]&apos;;</div><div class="line">    &#125;,</div><div class="line">    phone: function(value) &#123;</div><div class="line">      return /^1[3578]\d&#123;9&#125;$/.test(value);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    check: function(type, value) &#123;</div><div class="line">      // 去除首尾空白符</div><div class="line">      value = value.replace(/^\s+|\s+$/g, &apos;&apos;);</div><div class="line"></div><div class="line">      return strategy[type] ? strategy[type](value) : &apos;没有该类型的检测方法&apos;;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // 添加策略</div><div class="line">    addStrategy: function(type, fn) &#123;</div><div class="line">      strategy[type] = fn;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">InputStrategy.addStrategy(&apos;mail&apos;, function(value) &#123;</div><div class="line">  return /^(\w+)(@\w+)(\.\w+)+$/.test(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var is = InputStrategy.check(&apos;mail&apos;, &apos;abc@gmail.com&apos;);</div><div class="line"></div><div class="line">console.log(is);</div></pre></td></tr></table></figure>
<h2 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h2><ol>
<li>策略模式封装了一组代码族，并且封装的代码相互之间独立，便于对算法的重复引用，提高了算法的复用率</li>
<li>策略模式与继承相比，在类的继承中继承的方法是被封装在类中，因此当需求很多算法时，就不得不创建出多种类，<br>这样会导致算法与算法的使用者耦合在一起，不利于算法的独立演化，并且在类的外部改变类的算法难度也是极大的。</li>
<li>同状态模式一样，策略模式也是一种优化分支判断语句的模式，采用策略模式对算法封装使得算法更利于维护。</li>
</ol>
<h2 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h2><p>由于选择哪种算法的决定权在用户，所以对用户来说就必须了解每种算法的实现。<br>这就增加了用户的使用成本。其次，由于每种算法间相互独立，<br>这样对于一些复杂的算法处理相同逻辑的部分无法实现共享，这就会造成一些资源的浪费。</p>
<h2 id="适用环境-4"><a href="#适用环境-4" class="headerlink" title="适用环境"></a>适用环境</h2><p>在以下情况下可以使用策略模式：</p>
<ul>
<li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li>
<li>一个系统需要动态地在几种算法中选择一种。</li>
<li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li>
<li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。</li>
</ul>
<h1 id="手写给出一个装饰者模式实现"><a href="#手写给出一个装饰者模式实现" class="headerlink" title="手写给出一个装饰者模式实现"></a>手写给出一个装饰者模式实现</h1><p>在不改变原对象的基础上，通过对其进行封装扩展（添加属性和方法）使原有对象可以满足用户的更复杂的需求。</p>
<p>同样对原有对象进行扩展的还有适配器模式，所不同的是适配器进行扩展很多时候是对对象内部的重组，<br>因此了解其自身结构是必须的。而装饰者对对象的扩展是一种良性扩展，不用了解其具体实现，<br>只是在外部进行了一次封装扩展，这又是对原有功能完整性的一种保护。</p>
<p><img src="http://haoqiao.qiniudn.com/ECF534D1-2ABC-471B-9FAC-6DA7D4D38C85.png" alt="imgn"></p>
<h2 id="模式动机-1"><a href="#模式动机-1" class="headerlink" title="模式动机"></a>模式动机</h2><p>一般有两种方式可以实现给一个类或对象增加行为：</p>
<ul>
<li>继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li>
<li>关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)<br>装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机。</li>
</ul>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">// 装饰者</div><div class="line">var decorate = function(id, fn) &#123;</div><div class="line">  // 获取事件源</div><div class="line">  var dom = document.getElementById(id);</div><div class="line"></div><div class="line">  // 若事件源已绑定事件</div><div class="line">  if (typeof dom.onclick === &apos;function&apos;) &#123;</div><div class="line"></div><div class="line">    // 缓存事件源原有事件</div><div class="line">    var oldClickFn = dom.onclick;</div><div class="line"></div><div class="line">    // 为事件源定义新的事件</div><div class="line">    dom.onclick = function() &#123;</div><div class="line">      // 事件源原有回调函数</div><div class="line">      oldClickFn();</div><div class="line">      // 执行事件源新增回调函数</div><div class="line">      fn();</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">  &#125; else &#123;</div><div class="line">    // 如果未绑定事件，直接为事件源添加事件</div><div class="line">    dom.onclick = fn;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 电话输入框功能装饰</div><div class="line">decorate(&apos;tel_input&apos;, function() &#123;</div><div class="line">  document.getElementById(&apos;tel_demo_text&apos;).style.display = &apos;none&apos;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line">// 与适配器模式的区别：</div><div class="line">// 适配器方法使对原有对象适配，添加的方法与原有方法功能上大致相似。但是装饰者提供的方法与原来的方法功能项是有一定区别的。</div><div class="line">// 在装饰者模式中，不需要了解对象原有的功能，而且对象原有的方法照样可以原封不动的使用</div><div class="line">// 在适配器中增加的方法要调用原有的方法，</div><div class="line">// 需要了解原有方法实现的具体细节，</div><div class="line">// 而在装饰者中原封不动的使用，不需要知道原有方法实现的具体细节。</div><div class="line">//</div></pre></td></tr></table></figure>
<h2 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h2><ul>
<li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。</li>
<li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li>
<li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li>
<li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”</li>
</ul>
<h2 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</li>
<li>这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li>
</ul>
<h2 id="适用环境-5"><a href="#适用环境-5" class="headerlink" title="适用环境"></a>适用环境</h2><ul>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
<li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li>
<li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）.</li>
</ul>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>将一个复杂对象的构件层与其表示层相互分离，同样的构建过程可以用不同的表示。</p>
<p>对整体对象的拆分增加了结构的复杂性，如果对象粒度很小，或者模块间复用率很低还是直接创建整体对象比较好。</p>
<h2 id="模式动机-2"><a href="#模式动机-2" class="headerlink" title="模式动机"></a>模式动机</h2><p>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。</p>
<p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。</p>
<p><img src="http://haoqiao.qiniudn.com/36D71B0F-1F0B-42EA-A050-9F87A40FA333.png" alt="imgn"></p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var Human = function(param) &#123;</div><div class="line"></div><div class="line">  // 技能</div><div class="line">  this.skill = param &amp;&amp; param.skill || &apos;保密&apos;;</div><div class="line"></div><div class="line">  // 兴趣爱好</div><div class="line">  this.hobby = param &amp;&amp; param.hobby || &apos;保密&apos;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Human.prototype = &#123;</div><div class="line">  getSkill: function() &#123;</div><div class="line">    return this.skill;</div><div class="line">  &#125;,</div><div class="line">  getHobby: function() &#123;</div><div class="line">    return this.hobby;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 实例化姓名类</div><div class="line">var Named = function(name) &#123;</div><div class="line">  var that = this;</div><div class="line"></div><div class="line">  // 构造器</div><div class="line">  // 构造函数解析姓名的姓与名</div><div class="line">  (function(name, that) &#123;</div><div class="line">    that.wholeName = name;</div><div class="line"></div><div class="line">    if (name.indexOf(&apos; &apos;) &gt; -1) &#123;</div><div class="line">      that.firstName = name.slice(0, name.indexOf(&apos; &apos;));</div><div class="line">      that.secondName = name.slice(name.indexOf(&apos; &apos;));</div><div class="line">    &#125;</div><div class="line">  &#125;)(name, that)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 实例化职位类</div><div class="line">var Work = function(work) &#123;</div><div class="line">  var that = this;</div><div class="line"></div><div class="line">  // 构造器</div><div class="line">  // 构造函数中通过传入的职位特征来设置相应职位以及描述</div><div class="line">  (function(work, that) &#123;</div><div class="line">    switch(work) &#123;</div><div class="line">      case &apos;code&apos;:</div><div class="line">        that.work = &apos;工程师&apos;;</div><div class="line">        that.workDescript = &apos;每天沉醉于编程&apos;;</div><div class="line">        break;</div><div class="line">      case &apos;UI&apos;:</div><div class="line">      case &apos;UE&apos;:</div><div class="line">        that.work = &apos;设计师&apos;;</div><div class="line">        that.workDescript = &apos;设计更似一种艺术&apos;;</div><div class="line">        break;</div><div class="line">      case &apos;teach&apos;:</div><div class="line">        that.work = &apos;教师&apos;;</div><div class="line">        that.workDescript = &apos;分享也是一种快乐&apos;;</div><div class="line">        break;</div><div class="line">      default:</div><div class="line">        that.work = work;</div><div class="line">        that.workDescript = &apos;对不起，我们还不清楚您所选择职位的相关描述&apos;;</div><div class="line">    &#125;</div><div class="line">  &#125;)(work, that);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 更换期望的职位</div><div class="line">Work.prototype.changeWork = function(work) &#123;</div><div class="line">  this.work = work;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 添加对职位的描述</div><div class="line">Work.prototype.changeDescript = function(des) &#123;</div><div class="line">  this.workDescript = des;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * 应聘者建造者</div><div class="line"> *</div><div class="line"> * @param name 姓名（全名）</div><div class="line"> * @param work 期望职位</div><div class="line"> */</div><div class="line">var Person = function(name, work) &#123;</div><div class="line">  // 创建应聘者缓存对象</div><div class="line">  var _person = new Human();</div><div class="line"></div><div class="line">  // 创建应聘者姓名解析对象</div><div class="line">  _person.name = new Named(name);</div><div class="line"></div><div class="line">  // 创建应聘者期望职位</div><div class="line">  _person.work = new Work(work);</div><div class="line"></div><div class="line">  return _person;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person = new Person(&apos;xiao ming&apos;, &apos;code&apos;);</div><div class="line">console.log(person)</div></pre></td></tr></table></figure>
<h2 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h2><ul>
<li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li>
<li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</li>
</ul>
<h2 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>
</ul>
<h2 id="适用环境-6"><a href="#适用环境-6" class="headerlink" title="适用环境"></a>适用环境</h2><ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li>
<li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li>
</ul>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>只允许实例化一次对象类。有时也用一个对象来规划一个命名空间。井井有条管理对象上的属性和方法。</p>
<p>单例模式的要点有三个：</p>
<p>一是某个类只能有一个实例；</p>
<p>二是它必须自行创建这个实例；</p>
<p>三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p>
<h2 id="模式动机-3"><a href="#模式动机-3" class="headerlink" title="模式动机"></a>模式动机</h2><p>一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。</p>
<p><img src="http://haoqiao.qiniudn.com/02466658-43C2-40E1-932D-E84C9ABC41B7.png" alt="imgn"></p>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function $(id)&#123;</div><div class="line">    return document.getElementById(id)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//  单例模式（创建命名空间）</div><div class="line">var A = &#123;</div><div class="line">  Util: &#123;</div><div class="line">    util_method1: function() &#123;&#125;,</div><div class="line">    util_method2: function() &#123;&#125;</div><div class="line">  &#125;,</div><div class="line">  Tool: &#123;</div><div class="line">    tool_method1: function() &#123;&#125;,</div><div class="line">    tool_method2: function() &#123;&#125;</div><div class="line">  &#125;,</div><div class="line">  Ajax: &#123;</div><div class="line">    get: function() &#123;&#125;,</div><div class="line">    post: function() &#123;&#125;</div><div class="line">  &#125;,</div><div class="line">  others: &#123;</div><div class="line">    // ...</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">A.Util.util_method2();</div><div class="line">A.Tool.tool_method1();</div><div class="line">A.Ajax.get();</div><div class="line"></div><div class="line">//静态变量（无法修改的静态变量）</div><div class="line">var Config = (function() &#123;</div><div class="line">  // 私有变量</div><div class="line">  var config = &#123;</div><div class="line">    MAX_NUM: 100,</div><div class="line">    MIN_NUM: 1,</div><div class="line">    COUNT: 1000</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  // 返回取值器对象</div><div class="line">  return &#123;</div><div class="line">    // 取值器方法</div><div class="line">    get: function(name) &#123;</div><div class="line">      return config[name] ? config[name] : null;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">var count = Config.get(&apos;COUNT&apos;);</div><div class="line"></div><div class="line"></div><div class="line">//惰性单例（有时候对于单例对象需要延迟创建，所以在单例中还存在一种延迟创建的形式，有人也称之为‘惰性创建’）</div><div class="line">//</div><div class="line">// 惰性载入单例</div><div class="line">var LazySingle = (function() &#123;</div><div class="line"></div><div class="line">  // 单例实例引用</div><div class="line">  var _instance = null;</div><div class="line"></div><div class="line">  // 单例</div><div class="line">  function Single() &#123;</div><div class="line">    // 这里定义私有属性和方法</div><div class="line">    return &#123;</div><div class="line">      publicMethod: function() &#123;&#125;,</div><div class="line">      publicProperty: &apos;1.0&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return function() &#123;</div><div class="line"></div><div class="line">    if (!_instance) &#123;</div><div class="line">      _instance = Single();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回单例</div><div class="line">    return _instance;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"></div><div class="line">console.log( LazySingle().publicProperty ); // 1.0</div><div class="line">console.log( LazySingle() === LazySingle() ); // true</div></pre></td></tr></table></figure>
<h2 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h2><ul>
<li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li>
<li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li>
<li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li>
</ul>
<h2 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li>
<li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li>
</ul>
<h2 id="适用环境-7"><a href="#适用环境-7" class="headerlink" title="适用环境"></a>适用环境</h2><ul>
<li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li>
<li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li>
<li>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式</li>
</ul>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>将一个类（对象）的接口（方法或属性）转化成另外一个接口，以满足用户需求。</p>
<p>类（对象）之间接口的不兼容问题可以通过适配器模式解决</p>
<h2 id="模式动机-4"><a href="#模式动机-4" class="headerlink" title="模式动机"></a>模式动机</h2><p>适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。</p>
<p><img src="http://haoqiao.qiniudn.com/BEC864A6-618A-4819-A353-1E6B06C9BA59.png" alt="imgn"></p>
<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">// 定义框架</div><div class="line">var A = A || &#123;&#125;;</div><div class="line"></div><div class="line">// 通过id获取元素</div><div class="line">A.g = function(id) &#123;</div><div class="line">  return document.getElementById(id);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 背景：忽然项目中想把依赖换成jQuery，但总不能所有的方法都用jQuery的语法重新写一遍，那就写个适配器吧~</div><div class="line">A.g = function(id) &#123;</div><div class="line">  // 通过jQuery获取jQuery对象，然后返回第一个成员</div><div class="line">  return $(id).get(0);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 背景：如果方法需要传入很多参数，那么记住这些参数的顺序是很难的，所以我们经常是以一个参数对象方式传入的。</div><div class="line"></div><div class="line">function a(name, title, age, color, size, prize) &#123;&#125;</div><div class="line"></div><div class="line">/*</div><div class="line"> * obj.name: name</div><div class="line"> * obj.title: title</div><div class="line"> * obj.age: age</div><div class="line"> * obj.color: color</div><div class="line"> * obj.size: size</div><div class="line"> * obj.prize: prize</div><div class="line"> */</div><div class="line"></div><div class="line">function a(obj) &#123;&#125;</div><div class="line"></div><div class="line"> // 但是调用它的时候不知道传递的参数是否完整，此时我们通常的做法是用适配器来适配传入的参数对象</div><div class="line"></div><div class="line">function a(obj) &#123;</div><div class="line">  var _default = &#123;</div><div class="line">    name: &apos;雨夜清荷&apos;,</div><div class="line">    title: &apos;设计模式&apos;,</div><div class="line">    age: &apos;20&apos;,</div><div class="line">    color: &apos;pink&apos;,</div><div class="line">    size: 100,</div><div class="line">    prize: 50</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  for (var i in obj) &#123;</div><div class="line">    _default[i] = obj[i] || _default[i];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // code ....</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 数据适配,将无语义的数据构造适配成语义化的数据结构。</div><div class="line"></div><div class="line"></div><div class="line">function arrToObj(arr) &#123;</div><div class="line">  return &#123;</div><div class="line">    name: arr[0],</div><div class="line">    type: arr[1],</div><div class="line">    title: arr[2],</div><div class="line">    data: arr[3]</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [&apos;javascript&apos;, &apos;book&apos;, &apos;前端编程语言&apos;, &apos;12月1日&apos;];</div><div class="line"></div><div class="line">var obj = arrToObj(arr);</div><div class="line"></div><div class="line">console.log(obj);</div></pre></td></tr></table></figure>
<h2 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h2><ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li>
<li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li>
<li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。<br>类适配器模式还具有如下优点：<br>由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。<br>对象适配器模式还具有如下优点：<br>一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。</li>
</ul>
<h2 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h2><p>类适配器模式的缺点如下：<br>对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。<br>对象适配器模式的缺点如下：<br>与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p>
<h2 id="适用环境-8"><a href="#适用环境-8" class="headerlink" title="适用环境"></a>适用环境</h2><ul>
<li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
</ul>
<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦</p>
<p>桥接模式先抽象提取公共部分，然后将实现和抽象通过桥接方法链接在一起，实现解耦的作用。</p>
<p>桥接模式主要的特点是将实现层(如元素绑定的事件)与抽象层(修饰页面UI逻辑)解耦分离，使两部分可以独立编号。</p>
<p>主要对结构之间的解耦。</p>
<p>在javascript更多的利用this的特效，this只接受直接调用者支配。</p>
<h2 id="模式动机-5"><a href="#模式动机-5" class="headerlink" title="模式动机"></a>模式动机</h2><p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p>
<ul>
<li>第一种设计方案是为每一种形状都提供一套各种颜色的版本。</li>
<li>第二种设计方案是根据实际需要对形状和颜色进行组合<br>对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。</li>
</ul>
<p><img src="http://haoqiao.qiniudn.com/607519CD-B44E-488D-B045-C4A340E925FA.png" alt="imgn"></p>
<h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">var spans = document.getElementsByTagName(&apos;span&apos;);</div><div class="line"></div><div class="line">spans[0].onmouseover = function() &#123;</div><div class="line">  this.style.color = &apos;red&apos;;</div><div class="line">  this.style.background = &apos;#ddd&apos;;</div><div class="line">&#125;;</div><div class="line">spans[0].onmouseout = function() &#123;</div><div class="line">  this.style.color = &apos;#333&apos;;</div><div class="line">  this.style.background = &apos;#f5f5f5&apos;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">spans[1].onmouseover = function() &#123;</div><div class="line">  this.getElementsByTagName(&apos;strong&apos;)[0].style.color = &apos;red&apos;;</div><div class="line">  this.getElementsByTagName(&apos;strong&apos;)[0].style.background = &apos;#ddd&apos;;</div><div class="line">&#125;;</div><div class="line">spans[1].onmouseout = function() &#123;</div><div class="line">  this.getElementsByTagName(&apos;strong&apos;)[0].style.color = &apos;#333&apos;;</div><div class="line">  this.getElementsByTagName(&apos;strong&apos;)[0].style.background = &apos;#f5f5f5&apos;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 使用桥接模式后</div><div class="line">function changeColor(dom, color, bg) &#123;</div><div class="line">  dom.style.color = color;</div><div class="line">  this.style.background = bg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 事件与业务逻辑的桥梁</div><div class="line">spans[0].onmouseover = function() &#123;</div><div class="line">  changeColor(this, &apos;red&apos;, &apos;#ddd&apos;);</div><div class="line">&#125;;</div><div class="line">spans[0].onmouseout = function() &#123;</div><div class="line">  changeColor(this, &apos;#333&apos;, &apos;#f5f5f5&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 多维变量类</div><div class="line">// 运动单元</div><div class="line">function Speed(x, y) &#123;</div><div class="line">  this.x = x;</div><div class="line">  this.y = y;</div><div class="line">&#125;</div><div class="line">Speed.prototype.run = function() &#123;</div><div class="line">  console.log(&apos;跑起来&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 着色单元</div><div class="line">function Color(cl) &#123;</div><div class="line">  this.color = cl;</div><div class="line">&#125;</div><div class="line">Color.prototype.draw = function() &#123;</div><div class="line">  console.log(&apos;绘制色彩&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">function Ball(x, y, c) &#123;</div><div class="line">  // 实现运动单元</div><div class="line">  this.speed = new Speed(x, y);</div><div class="line">  // 实现着色单元</div><div class="line">  this.color = new Color(c);</div><div class="line">&#125;;</div><div class="line">Ball.prototype.init = function() &#123;</div><div class="line">  // 实现运动</div><div class="line">  this.speed.run();</div><div class="line">  // 实现着色</div><div class="line">  this.color.draw();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = new Ball(1,2,&apos;red&apos;);</div><div class="line">a.init();</div></pre></td></tr></table></figure>
<h2 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h2><ul>
<li>分离抽象接口及其实现部分。</li>
<li>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。</li>
<li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</li>
<li>实现细节对客户透明，可以对用户隐藏实现细节。</li>
</ul>
<h2 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 </li>
<li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li>
</ul>
<h2 id="适用环境-9"><a href="#适用环境-9" class="headerlink" title="适用环境"></a>适用环境</h2><p>在以下情况下可以使用桥接模式：</p>
<ul>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
<li>抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</li>
<li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li>
<li>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。</li>
<li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li>
</ul>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>为一组复杂的子系统接口提供了一个更高级的统一接口，通过这个接口对子系统接口的访问更容易。</p>
<p>常见是兼容事件的封装。</p>
<h2 id="模式动机-6"><a href="#模式动机-6" class="headerlink" title="模式动机"></a>模式动机</h2><p>外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</p>
<h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 外观模式实现</div><div class="line">function addEvent(dom, type, fn) &#123;</div><div class="line"></div><div class="line">  if (dom.addEventListener) &#123;</div><div class="line">    dom.addEventListener(type, fn, false);</div><div class="line">  &#125; else if (dom.attachEvent) &#123;</div><div class="line">    dom.attachEvent(&apos;on&apos; + type, fn);</div><div class="line">  &#125; else &#123;</div><div class="line">    dom[&apos;on&apos; + type] = fn;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myInput = document.getElementById(&apos;myinput&apos;);</div><div class="line"></div><div class="line">addEvent(myInput, &apos;click&apos;, function() &#123;</div><div class="line">  console.log(&apos;绑定第一个事件&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">addEvent(myInput, &apos;click&apos;, function() &#123;</div><div class="line">  console.log(&apos;绑定第二个事件&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</div><div class="line">* 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</div><div class="line">* 降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</div><div class="line">* 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</div></pre></td></tr></table></figure>
<h2 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</div><div class="line">* 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</div></pre></td></tr></table></figure>
<h2 id="适用环境-10"><a href="#适用环境-10" class="headerlink" title="适用环境"></a>适用环境</h2><ul>
<li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li>
<li>客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li>
<li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li>
</ul>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>享元模式（Flyweight），运行共享技术有效地支持大量细粒度的对象，避免对象拥有相同内容造成多余的开销，<br>使大家共享一个类(元类)。</p>
<p>也是将公共属性/方法抽象出来。谁需要谁去继承。</p>
<p>享元模式的精髓就在于『创建对象的同时，缓存一份对象，日后直接对缓存的对象做操作』</p>
<h2 id="模式动机-7"><a href="#模式动机-7" class="headerlink" title="模式动机"></a>模式动机</h2><p>面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。</p>
<ul>
<li>享元模式正是为解决这一类问题而诞生的。享元模式通过共享技术实现相同或相似对象的重用。</li>
<li>在享元模式中可以共享的相同内容称为内部状态(IntrinsicState)，而那些需要外部环境来设置的不能共享的内容称为外部状态(Extrinsic State)，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。</li>
<li>在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池(Flyweight Pool)用于存储具有相同内部状态的享元对象。</li>
<li>在享元模式中共享的是享元对象的内部状态，外部状态需要通过环境来设置。在实际使用中，能够共享的内部状态是有限的，因此享元对象一般都设计为较小的对象，它所包含的内部状态较少，这种对象也称为细粒度对象。享元模式的目的就是使用共享技术来实现大量细粒度对象的复用。</li>
</ul>
<p><img src="http://haoqiao.qiniudn.com/7951087F-511E-44D1-A00C-5983FD917C7A.png" alt="imgn"></p>
<h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 背景：分页新闻功能</div><div class="line"></div><div class="line">// 享元对象</div><div class="line">var Flyweight = (function() &#123;</div><div class="line">  // 已创建的元素</div><div class="line">  var created = [];</div><div class="line"></div><div class="line">  /*</div><div class="line">   * 创建一个新闻包装容器</div><div class="line">   * 根据我自己对享元模式的理解，享元模式的精髓就在于『创建对象的同时，缓存一份对象，日后直接对缓存的对象做操作』</div><div class="line">   */</div><div class="line">  function create() &#123;</div><div class="line">    var dom = document.createElement(&apos;div&apos;);</div><div class="line">    // 讲容器插入新闻列表容器中</div><div class="line">    document.getElementById(&apos;container&apos;).appendChild(dom);</div><div class="line">    // 缓存新创建的元素</div><div class="line">    created.push(dom);</div><div class="line">    // 返回创建的新元素</div><div class="line">    return dom;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    // 获取创建新闻元素方法</div><div class="line">    getDiv: function() &#123;</div><div class="line">      // 如果已创建的元素小于当前页元素总个数，则创建</div><div class="line">      if (created.length &lt; 5) &#123;</div><div class="line">        return create();</div><div class="line">      &#125; else &#123;</div><div class="line">        // 获取第一个元素并插入到最后面</div><div class="line">        var div = created.shift();</div><div class="line">        created.push(div);</div><div class="line">        return div;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"></div><div class="line">// 实现需求</div><div class="line">var paper = 0;</div><div class="line">var num = 5;</div><div class="line">var article = [&apos;这是第一条新闻&apos;,&apos;这是第二条新闻&apos;,&apos;这是第三条新闻&apos;,&apos;这是第四条新闻&apos;,&apos;这是第五条新闻&apos;,&apos;这是第六条新闻&apos;];</div><div class="line">var len = article.length;</div><div class="line"></div><div class="line">// 添加五条新闻</div><div class="line">for (var i = 0; i &lt; 5; i++) &#123;</div><div class="line">  if (article[i]) &#123;</div><div class="line">    // 通过享元类获取创建的元素并写入新闻内容</div><div class="line">    Flyweight.getDiv().innerHTML = article[i];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 下一页</div><div class="line">document.getElementById(&apos;next&apos;).onclick = function() &#123;</div><div class="line">  // 如果新闻内容不足5条则返回</div><div class="line">  if(article.length &lt; 5) return;</div><div class="line"></div><div class="line">  var n = ++paper * num % len;</div><div class="line"></div><div class="line">  // 插入5条新闻</div><div class="line">  for (var j = 0; j &lt; 5; j++) &#123;</div><div class="line">    // 如果存在第n+j条则插入</div><div class="line">    if (article[n + j]) &#123;</div><div class="line">      Flyweight.getDiv().innerHTML = article[n + j];</div><div class="line">    &#125; else if(article[n + j - len]) &#123;</div><div class="line">      // 否则插入起始位置第n + j - len 条</div><div class="line">      Flyweight.getDiv().innerHTML = article[n + j - len];</div><div class="line">    &#125; else &#123;</div><div class="line">      // 如果都不存在则插入空字符串</div><div class="line">      Flyweight.getDiv().innerHTML = &apos;&apos;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h2><ul>
<li>享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。</li>
<li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</li>
</ul>
<h2 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li>
<li>为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</li>
</ul>
<h2 id="适用环境-11"><a href="#适用环境-11" class="headerlink" title="适用环境"></a>适用环境</h2><ul>
<li>一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li>
<li>使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。</li>
</ul>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>由于一个对象不能直接引用另一个对象，通过代理对象起到中介作用。</p>
<p>// 典型例子如： Jsonp跨域解决方案<br>// 比如延迟加载一些资源。图片的懒加载。用代理方式先加载一张预览图片。等用户需要的时候替换成真实图片。</p>
<h2 id="模式动机-8"><a href="#模式动机-8" class="headerlink" title="模式动机"></a>模式动机</h2><p>在某些情况下，一个客户不想或者不能直接引用一个对 象，此时可以通过一个称之为“代理”的第三者来实现 间接引用。代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。</p>
<p>通过引入一个新的对象（如小图片和远程代理 对象）来实现对真实对象的操作或者将新的对 象作为真实对象的一个替身，这种实现机制即 为代理模式，通过引入代理对象来间接访问一 个对象，这就是代理模式的模式动机。</p>
<p><img src="http://haoqiao.qiniudn.com/4DE945BE-06F1-478F-B58C-2B7CAD637ACB.png" alt="imgn"></p>
<h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><h2 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h2><ul>
<li>代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。</li>
<li>远程代理使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li>
<li>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系 统资源的消耗，对系统进行优化并提高运行速度。</li>
<li>保护代理可以控制对真实对象的使用权限。</li>
</ul>
<h2 id="缺点-12"><a href="#缺点-12" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>由于在客户端和真实主题之间增加了代理对象，因此 有些类型的代理模式可能会造成请求的处理速度变慢。</li>
<li>实现代理模式需要额外的工作，有些代理模式的实现 非常复杂。</li>
</ul>
<h2 id="适用环境-12"><a href="#适用环境-12" class="headerlink" title="适用环境"></a>适用环境</h2><ul>
<li>远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地 的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在 另一台主机中，远程代理又叫做大使(Ambassador)。</li>
<li>虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li>
<li>Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个 开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li>
<li>保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
<li>缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>
<li>防火墙(Firewall)代理：保护目标不让恶意用户接近。</li>
<li>同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。</li>
<li>智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li>
</ul>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>将请求与实现解耦，并封装成独立对象，从而使不同的请求对客户端的实现参数化。</p>
<p>命令模式是将执行的命令封装，解决命令的发起者与命令的执行者之间的耦合。</p>
<p>每一条命令实质上是一个操作。命令的使用者不必要了解命令的执行者（命令对象）的命令接口是如何实现的，命令式如何接收的，命令式如何执行的。所有的命令都被存储在命令对象中。</p>
<p>命令模式的有点自然是解决命令使用者之间的耦合。新的命令很容易加入到命令系统中，供使用者使用。</p>
<p>命令的使用具有一致性，多数的命令在一定程度上是简化操作方法的使用的。</p>
<p>命令模式是对一些操作的封装，这就造成每执行一次操作都要调用一次命令对象，增加了系统的复杂度。</p>
<h2 id="模式动机-9"><a href="#模式动机-9" class="headerlink" title="模式动机"></a>模式动机</h2><p>在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。<br>命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。</p>
<p><img src="http://haoqiao.qiniudn.com/914AD7AE-AD2B-42DB-899B-DF2E1BF66E30.png" alt="imgn"></p>
<h2 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line"> * 实现模块</div><div class="line"> */</div><div class="line">var ViewCommand = (function() &#123;</div><div class="line"></div><div class="line">  // 模板</div><div class="line">  var tpl = &#123;</div><div class="line">    product: [</div><div class="line">      &apos;&lt;div&gt;&apos;,</div><div class="line">        &apos;&lt;img src=&quot;&#123;#src#&#125;&quot; /&gt;&apos;,</div><div class="line">        &apos;&lt;p&gt;&#123;#text#&#125;&lt;/p&gt;&apos;,</div><div class="line">      &apos;&lt;/div&gt;&apos;</div><div class="line">    ].join(&apos;&apos;),</div><div class="line"></div><div class="line">    title: [</div><div class="line">      &apos;&lt;div class=&quot;title&quot;&gt;&apos;,</div><div class="line">        &apos;&lt;div class=&quot;main&quot;&gt;&apos;,</div><div class="line">          &apos;&lt;h2&gt;&#123;#title#&#125;&lt;/h2&gt;&apos;,</div><div class="line">          &apos;&lt;p&gt;&#123;#tips#&#125;&lt;/p&gt;&apos;,</div><div class="line">        &apos;&lt;/div&gt;&apos;,</div><div class="line">      &apos;&lt;/div&gt;&apos;</div><div class="line">    ].join(&apos;&apos;),</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  var html = &apos;&apos;;</div><div class="line"></div><div class="line">  // 替换数据</div><div class="line">  function formatString(str, obj) &#123;</div><div class="line">    return str.replace(/\&#123;#(\w+)#\&#125;/g, function(match, key) &#123;</div><div class="line">      return obj[key];</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 方法集合</div><div class="line">  var Action = &#123;</div><div class="line">    create: function(data, view) &#123;</div><div class="line">      // 如果是数字则把数组中的每一项加进html中</div><div class="line">      if (Object.prototype.toString.call(data) === &apos;[object Array]&apos;) &#123;</div><div class="line">        for (var i = 0; i &lt; data.length; i++) &#123;</div><div class="line">          html += formatString(tpl[view], data[i]);</div><div class="line">        &#125;</div><div class="line">      &#125; else &#123;</div><div class="line">        html += formatString(tpl[view], data);</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    display: function(container, data, view) &#123;</div><div class="line">      // 如果有数据，根据数据创建视图</div><div class="line">      if (data) this.create(data, view);</div><div class="line"></div><div class="line">      document.getElementById(container).innerHTML  = html;</div><div class="line">      html = &apos;&apos;;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  return function excute(command) &#123;</div><div class="line">    command.param = Object.prototype.toString.call(command.param) === &apos;[object Array]&apos; ? command.param : [command.param];</div><div class="line">    Action[command.cd].apply(Action, command.param);</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line"> * 测试</div><div class="line"> */</div><div class="line"></div><div class="line">// 产品展示数据</div><div class="line">var productData = [&#123;</div><div class="line">  src: &apos;command/02.jpg&apos;,</div><div class="line">  text: &apos;绽放的桃花&apos;</div><div class="line">&#125;,&#123;</div><div class="line">  src: &apos;command/03.jpg&apos;,</div><div class="line">  text: &apos;阳光下的温馨&apos;</div><div class="line">&#125;,&#123;</div><div class="line">  src: &apos;command/04.jpg&apos;,</div><div class="line">  text: &apos;镜头前的绿色&apos;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 模块标题数据</div><div class="line">var titleData = &#123;</div><div class="line">  title: &apos;夏日里的一片温馨&apos;,</div><div class="line">  tips: &apos;暖暖的温情带给人们家的感受&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ViewCommand(&#123;</div><div class="line">  cd: &apos;display&apos;,</div><div class="line">  param: [&apos;title&apos;, titleData, &apos;title&apos;]</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ViewCommand(&#123;</div><div class="line">  cd: &apos;create&apos;,</div><div class="line">  param: [&#123;</div><div class="line">    src: &apos;command/01.jpg&apos;,</div><div class="line">    text: &apos;迎着朝阳的野菊花&apos;</div><div class="line">  &#125;, &apos;product&apos;]</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ViewCommand(&#123;</div><div class="line">  cd: &apos;display&apos;,</div><div class="line">  param: [&apos;product&apos;, productData, &apos;product&apos;]</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line"> * 测试HTML</div><div class="line"> *</div><div class="line"> * &lt;div id=&quot;title&quot;&gt;&lt;/div&gt;</div><div class="line"> * &lt;div id=&quot;product&quot;&gt;&lt;/div&gt;</div><div class="line"> */</div></pre></td></tr></table></figure>
<h2 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h2><ul>
<li>降低系统的耦合度。</li>
<li>新的命令可以很容易地加入到系统中。</li>
<li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li>
<li>可以方便地实现对请求的Undo和Redo。</li>
</ul>
<h2 id="缺点-13"><a href="#缺点-13" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li>
</ul>
<h2 id="适用环境-13"><a href="#适用环境-13" class="headerlink" title="适用环境"></a>适用环境</h2><ul>
<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li>
<li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li>
<li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li>
<li>系统需要将一组操作组合在一起，即支持宏命令</li>
</ul>
<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低它们之间的耦合。有时中介者对象也可改变对象之间的交互。</p>
<p>中介者是单向的，类似于执行某个事件，然后所有订阅过该事件的都会执行。</p>
<h2 id="模式动机-10"><a href="#模式动机-10" class="headerlink" title="模式动机"></a>模式动机</h2><ul>
<li>在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：</li>
<li>系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</li>
<li>对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</li>
<li>系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</li>
<li>在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。</li>
<li>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机。</li>
</ul>
<p><img src="http://haoqiao.qiniudn.com/BD7F86E3-9293-4E5E-BCE0-1C178F55AD6A.png" alt="imgn"></p>
<h2 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">// 中介者对象</div><div class="line">var Mediator = (function() &#123;</div><div class="line">  // 消息对象</div><div class="line">  var _msg = &#123;&#125;;</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    subscribe: function(type, action) &#123;</div><div class="line">      if (_msg[type]) &#123;</div><div class="line">        _msg[type].push(action);</div><div class="line">      &#125; else &#123;</div><div class="line">        _msg[type] = [];</div><div class="line">        _msg[type].push(action);</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    send: function(type) &#123;</div><div class="line">      if (_msg[type]) &#123;</div><div class="line">        for (var i = 0; i &lt; _msg[type].length; i++) &#123;</div><div class="line">          _msg[type][i] &amp;&amp; _msg[type][i]();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">// 单元测试</div><div class="line"></div><div class="line">// 订阅</div><div class="line">Mediator.subscribe(&apos;demo&apos;, function() &#123;</div><div class="line">  console.log(&apos;first&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Mediator.subscribe(&apos;demo&apos;, function() &#123;</div><div class="line">  console.log(&apos;second&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Mediator.send(&apos;demo&apos;);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 中介者对象</div><div class="line">var Mediator = (function() &#123;</div><div class="line">  // 消息对象</div><div class="line">  var _msg = &#123;&#125;;</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    subscribe: function(type, action) &#123;</div><div class="line">      if (_msg[type]) &#123;</div><div class="line">        _msg[type].push(action);</div><div class="line">      &#125; else &#123;</div><div class="line">        _msg[type] = [];</div><div class="line">        _msg[type].push(action);</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    send: function(type) &#123;</div><div class="line">      if (_msg[type]) &#123;</div><div class="line">        for (var i = 0; i &lt; _msg[type].length; i++) &#123;</div><div class="line">          _msg[type][i] &amp;&amp; _msg[type][i]();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">/*</div><div class="line"> * 显示隐藏导航小组件</div><div class="line"> *</div><div class="line"> * mod 模块</div><div class="line"> * tag 标签</div><div class="line"> * showOrHide 显示还是隐藏</div><div class="line"> */</div><div class="line">var showHideNavWidget = function(mod, tag, showOrHide) &#123;</div><div class="line">  var mod = document.getElementById(mod);</div><div class="line">  var tag = mod.getElementsByTagName(tag);</div><div class="line">  var showOrHide = (!showOrHide || showOrHide === &apos;hide&apos;) ? &apos;hidden&apos; : &apos;visible&apos;;</div><div class="line"></div><div class="line">  // 占位隐藏这些标签</div><div class="line">  for (var i = 0; i &lt; tag.length; i ++) &#123;</div><div class="line">    tag[i].style.visibility = showOrHide;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/*</div><div class="line"> * 用户手册导航模块</div><div class="line"> */</div><div class="line">(function() &#123;</div><div class="line">  // 订阅 隐藏用户收藏导航信息提醒消息</div><div class="line">  Mediator.subscribe(&apos;hideAllNavNum&apos;, function() &#123;</div><div class="line">    showHideNavWidget(&apos;collection_nav&apos;, &apos;b&apos;, false);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  // 订阅 显示用户收藏导航信息提醒消息</div><div class="line">  Mediator.subscribe(&apos;showAllNavNum&apos;, function() &#123;</div><div class="line">    showHideNavWidget(&apos;collection_nav&apos;, &apos;b&apos;, true);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  // 订阅 隐藏用户收藏导航网址消息</div><div class="line">  Mediator.subscribe(&apos;hideAllNavUrl&apos;, function() &#123;</div><div class="line">    showHideNavWidget(&apos;collection_nav&apos;, &apos;span&apos;, false);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  // 订阅 显示用户收藏导航网址消息</div><div class="line">  Mediator.subscribe(&apos;showAllNavUrl&apos;, function() &#123;</div><div class="line">    showHideNavWidget(&apos;collection_nav&apos;, &apos;span&apos;, true);</div><div class="line">  &#125;);</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">/*</div><div class="line"> * 推荐用户导航</div><div class="line"> */</div><div class="line">(function() &#123;</div><div class="line">  // 订阅 隐藏推荐用户导航消息提醒消息</div><div class="line">  Mediator.subscribe(&apos;hideAllNavNum&apos;, function() &#123;</div><div class="line">    showHideNavWidget(&apos;recommend_nav&apos;, &apos;b&apos;, false);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  // 订阅 显示推荐用户导航消息提醒消息</div><div class="line">  Mediator.subscribe(&apos;showAllNavNum&apos;, function() &#123;</div><div class="line">    showHideNavWidget(&apos;recommend_nav&apos;, &apos;b&apos;, true);</div><div class="line">  &#125;);</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">/*</div><div class="line"> * 最近常用导航</div><div class="line"> */</div><div class="line">(function() &#123;</div><div class="line">  // 订阅 隐藏最近常用导航网址消息</div><div class="line">  Mediator.subscribe(&apos;hideAllNavUrl&apos;, function() &#123;</div><div class="line">    showHideNavWidget(&apos;recently_nav&apos;, &apos;span&apos;, &apos;hide&apos;);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  // 订阅 显示最近常用导航网址消息</div><div class="line">  Mediator.subscribe(&apos;showAllNavUrl&apos;, function() &#123;</div><div class="line">    showHideNavWidget(&apos;recently_nav&apos;, &apos;span&apos;, &apos;show&apos;);</div><div class="line">  &#125;);</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line"> * 设置层模块</div><div class="line"> */</div><div class="line">(function() &#123;</div><div class="line">  // 消息提醒选框</div><div class="line">  var hideNum = document.getElementById(&apos;hide_num&apos;);</div><div class="line">  var hideUrl = document.getElementById(&apos;hide_url&apos;);</div><div class="line"></div><div class="line">  // 消息提醒选框事件</div><div class="line">  hideNum.onchange = function() &#123;</div><div class="line">    if (hideNum.checked) &#123;</div><div class="line">      Mediator.send(&apos;hideAllNavNum&apos;);</div><div class="line">    &#125; else &#123;</div><div class="line">      Mediator.send(&apos;showAllNavNum&apos;);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  // 网址选框事件</div><div class="line">  hideUrl.onchange = function() &#123;</div><div class="line">    if (hideUrl.checked) &#123;</div><div class="line">      Mediator.send(&apos;hideAllNavUrl&apos;);</div><div class="line">    &#125; else &#123;</div><div class="line">      Mediator.send(&apos;showAllNavUrl&apos;);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line"> * 测试html</div><div class="line"> *</div><div class="line"></div><div class="line">网址 &lt;input type=&quot;checkbox&quot; id=&quot;hide_num&quot;&gt;</div><div class="line">url &lt;input type=&quot;checkbox&quot; id=&quot;hide_url&quot;&gt;</div><div class="line"></div><div class="line">&lt;div id=&quot;collection_nav&quot;&gt;</div><div class="line">    用户手册导航模块</div><div class="line">    &lt;b&gt;b&lt;/b&gt;</div><div class="line">    &lt;span&gt;span&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;div id=&quot;recommend_nav&quot;&gt;</div><div class="line">    推荐用户导航</div><div class="line">    &lt;b&gt;b&lt;/b&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;div id=&quot;recently_nav&quot;&gt;</div><div class="line">    最近常用导航</div><div class="line">    &lt;span&gt;span&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">*/</div></pre></td></tr></table></figure>
<h2 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h2><ul>
<li>简化了对象之间的交互。</li>
<li>将各同事解耦。</li>
<li>减少子类生成。</li>
<li>可以简化各同事类的设计和实现。</li>
</ul>
<h2 id="缺点-14"><a href="#缺点-14" class="headerlink" title="缺点"></a>缺点</h2><p>在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</p>
<h2 id="适用环境-14"><a href="#适用环境-14" class="headerlink" title="适用环境"></a>适用环境</h2><ul>
<li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。</li>
<li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</li>
<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象。</li>
<li>交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li>
</ul>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。</p>
<p>主要是将条件判断的不同结果转为状态对象的内部状态。</p>
<h2 id="模式动机-11"><a href="#模式动机-11" class="headerlink" title="模式动机"></a>模式动机</h2><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p>
<p><img src="http://haoqiao.qiniudn.com/214C85B7-B3BA-4A22-8D03-1A53F0F4BDAC.png" alt="imgn"></p>
<h2 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">// 超级玛丽的例子</div><div class="line"></div><div class="line">// 创建超级玛丽状态类</div><div class="line">var MarryState = function() &#123;</div><div class="line">  var _currentState = &#123;&#125;;</div><div class="line"></div><div class="line">  // 动作与状态方法映射</div><div class="line">  var states = &#123;</div><div class="line">    jump: function() &#123;</div><div class="line">      // 跳跃</div><div class="line">      console.log(&apos;jump&apos;);</div><div class="line">    &#125;,</div><div class="line">    move: function() &#123;</div><div class="line">      // 移动</div><div class="line">      console.log(&apos;move&apos;);</div><div class="line">    &#125;,</div><div class="line">    shoot: function() &#123;</div><div class="line">      // 射击</div><div class="line">      console.log(&apos;shoot&apos;);</div><div class="line">    &#125;,</div><div class="line">    squat: function() &#123;</div><div class="line">      // 蹲下</div><div class="line">      console.log(&apos;squat&apos;);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  // 动作控制类</div><div class="line">  var Action = &#123;</div><div class="line">    changeState: function() &#123;</div><div class="line">      var arg = arguments;</div><div class="line"></div><div class="line">      // 重置内部状态</div><div class="line">      _currentState = &#123;&#125;;</div><div class="line"></div><div class="line">      if (arg.length) &#123;</div><div class="line">        for (var i = 0; i &lt; arg.length; i++) &#123;</div><div class="line">          _currentState[arg[i]] = true;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return this;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    goes: function() &#123;</div><div class="line">      console.log(&apos;触发一次动作&apos;);</div><div class="line"></div><div class="line">      for (var i in _currentState) &#123;</div><div class="line">        states[i] &amp;&amp; states[i]();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return this;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    change: Action.changeState,</div><div class="line">    goes: Action.goes</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">// 两种执行方式，可以直接执行状态类，也可以实例化状态类</div><div class="line">// 直接执行状态类：如果直接使用实例化类就只能自己使用，如果还有另一个人使用，就可能会修改状态类内部的状态</div><div class="line">// 实例化状态类：实例化状态类有一个好处就是 它是对状态类的复制，无论怎么使用，都不会影响我，</div><div class="line">var marry = new MarryState();</div><div class="line"></div><div class="line">marry.change(&apos;jump&apos;, &apos;shoot&apos;).goes().goes().change(&apos;shoot&apos;).goes();</div></pre></td></tr></table></figure>
<h2 id="优点-15"><a href="#优点-15" class="headerlink" title="优点"></a>优点</h2><ul>
<li>封装了转换规则。</li>
<li>枚举可能的状态，在枚举状态之前需要确定状态种类。</li>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li>
<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li>
<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li>
</ul>
<h2 id="缺点-15"><a href="#缺点-15" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>状态模式的使用必然会增加系统类和对象的个数。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li>
<li>状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li>
</ul>
<h2 id="适用环境-15"><a href="#适用环境-15" class="headerlink" title="适用环境"></a>适用环境</h2><ul>
<li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li>
<li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计一个订阅者发布者的基类&quot;&gt;&lt;a href=&quot;#设计一个订阅者发布者的基类&quot; class=&quot;headerlink&quot; title=&quot;设计一个订阅者发布者的基类&quot;&gt;&lt;/a&gt;设计一个订阅者发布者的基类&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;观察者模式（Observe
    
    </summary>
    
      <category term="进阶" scheme="http://wiki.haoqiao.me/categories/%E8%BF%9B%E9%98%B6/"/>
    
      <category term="设计模式" scheme="http://wiki.haoqiao.me/categories/%E8%BF%9B%E9%98%B6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="设计模式" scheme="http://wiki.haoqiao.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>cookie</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Ecmascript/cookie/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/基础/Ecmascript/cookie/</id>
    <published>2018-02-25T00:48:04.000Z</published>
    <updated>2018-02-25T01:06:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何实现cookie跨域访问"><a href="#如何实现cookie跨域访问" class="headerlink" title="如何实现cookie跨域访问"></a>如何实现cookie跨域访问</h1><blockquote>
<p>一般情况下<br>Cookie是不可跨域的。域名<a href="http://www.google.com颁发的Cookie不会被提交到域名http://www.baidu.com/去。这是由Cookie的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的Cookie。" rel="external nofollow noopener noreferrer" target="_blank">http://www.google.com颁发的Cookie不会被提交到域名http://www.baidu.com/去。这是由Cookie的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的Cookie。</a><br>正常情况下，同一个一级域名下的两个二级域名如<a href="http://www.helloweenvsfei.com和images.helloweenvsfei.com也不能交互使用Cookie，因为二者的域名并不严格相同。如果想所有helloweenvsfei.com名下的二级域名都可以使用该Cookie，需要设置Cookie的domain参数" rel="external nofollow noopener noreferrer" target="_blank">http://www.helloweenvsfei.com和images.helloweenvsfei.com也不能交互使用Cookie，因为二者的域名并不严格相同。如果想所有helloweenvsfei.com名下的二级域名都可以使用该Cookie，需要设置Cookie的domain参数</a></p>
</blockquote>
<p>因此产生了一些黑科技的做法。</p>
<p>其实说到底这些做法是将 cookie 视为一个字符串数据。然后依靠常规的跨域做法将这个字符串暴露给别的域名。</p>
<h2 id="JS跨域的-JSONP-解决方案"><a href="#JS跨域的-JSONP-解决方案" class="headerlink" title="JS跨域的 JSONP 解决方案"></a>JS跨域的 JSONP 解决方案</h2><h2 id="iframe跨域"><a href="#iframe跨域" class="headerlink" title="iframe跨域"></a>iframe跨域</h2><p>在Ａ系统下成功登录后，利用JS动态创建一个隐藏的iframe，通过iframe的src属性将Ａ域下的cookie值作为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var   _frm   =   document.createElement(&quot;iframe&quot;);  </div><div class="line">_frm.style.display=&quot;none&quot;;  </div><div class="line"> _frm.src=&quot;http://b.com/b.jsp?test_cookie=xxxxx&quot;;  </div><div class="line"> document.body.appendChild(_frm);</div></pre></td></tr></table></figure>
<p>在Ｂ系统的b.jsp页面中来获取Ａ系统中所传过来的cookie值，并将所获取到值写入cookie中，这样就简单的实现了cookie跨域的访问。</p>
<h2 id="Nginx设置反向代理也可实现"><a href="#Nginx设置反向代理也可实现" class="headerlink" title="Nginx设置反向代理也可实现"></a>Nginx设置反向代理也可实现</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何实现cookie跨域访问&quot;&gt;&lt;a href=&quot;#如何实现cookie跨域访问&quot; class=&quot;headerlink&quot; title=&quot;如何实现cookie跨域访问&quot;&gt;&lt;/a&gt;如何实现cookie跨域访问&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;一般情况下&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Ecmascript" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Ecmascript/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="cookie" scheme="http://wiki.haoqiao.me/tags/cookie/"/>
    
      <category term="cookie 操作" scheme="http://wiki.haoqiao.me/tags/cookie-%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>react native</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/React/react%20native/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/框架/React/react native/</id>
    <published>2018-02-23T13:20:40.000Z</published>
    <updated>2018-02-23T13:28:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>React Native使你能够在Javascript和React的基础上获得完全一致的开发体验，构建世界一流的原生APP。</p>
<p>使用React Native，你可以使用标准的平台组件，例如iOS的UITabBar或安卓的Drawer。 这使你的app获得平台一致的视觉效果和体验，并且获得最佳的性能和流畅性。</p>
<h1 id="RN的运行原理"><a href="#RN的运行原理" class="headerlink" title="RN的运行原理"></a>RN的运行原理</h1><p><img src="http://haoqiao.qiniudn.com/6039087-13814ffff21ce4eb.png" alt="Object-C 与 RN"></p>
<p><code>JavaScript 是一种单线程的语言，它不具备自运行的能力，因此总是被动调用，Objective-C 创建了一个单独的线程，这个线程只用于执行 JavaScript 代码，而且 JavaScript 代码只会在这个线程中执行。</code></p>
<blockquote>
<p>在 React Native 中，Objective-C 和 JavaScript 的交互都是通过传递 ModuleId、MethodId 和 Arguments 进行的。Objective-C 和 JavaScript 两端都保存了一份配置表，里面标记了所有 Objective-C 暴露给 JavaScript 的模块和方法。这样，无论是哪一方调用另一方的方法，实际上传递的数据只有 ModuleId、MethodId 和 Arguments 这三个元素，它们分别表示类、方法和方法参数，当 Objective-C 接收到这三个值后，就可以通过 runtime 唯一确定要调用的是哪个函数，然后调用这个函数。Objective-C 和 JavaScript 的交互总是由Objective-C发起的。Object-C与js的交互是通过各端的Bridge和ModuleConfig来进行的，实际过程可分为两个阶段：初始化阶段和方法调用阶段。</p>
</blockquote>
<p>一般情况下，Objective-C 会定时、主动的调用JS放到MessageQueue 中的方法，实际上（由于卡顿或某些特殊原因），JavaScript 也可以主动调用 Objective-C 的方法，目前，React Native 的逻辑是，如果消息队列中有等待 Objective-C 处理的逻辑，而且 Objective-C 超过 5ms 都没有来取走，那么 JavaScript 就会主动调用 Objective-C 的方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;React Native使你能够在Javascript和React的基础上获得完全一致的开发体验，构建世界一流的原生APP。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="框架" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="React" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/React/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react native" scheme="http://wiki.haoqiao.me/tags/react-native/"/>
    
      <category term="RN" scheme="http://wiki.haoqiao.me/tags/RN/"/>
    
  </entry>
  
  <entry>
    <title>睡眠革命:如何让睡眠更高效</title>
    <link href="http://wiki.haoqiao.me/wiki/%E9%98%85%E8%AF%BB/%E7%9D%A1%E7%9C%A0%E9%9D%A9%E5%91%BD:%E5%A6%82%E4%BD%95%E8%AE%A9%E7%9D%A1%E7%9C%A0%E6%9B%B4%E9%AB%98%E6%95%88/"/>
    <id>http://wiki.haoqiao.me/wiki/阅读/睡眠革命:如何让睡眠更高效/</id>
    <published>2018-02-23T03:56:40.000Z</published>
    <updated>2018-02-23T06:00:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间对睡眠质量不太满意，因此在看到书的时候果断加入到阅读序列。</p>
<p>除去睡眠常识，这本书最重要的其实是做出了一些科学的设定。</p>
<h1 id="睡眠周期了解一下"><a href="#睡眠周期了解一下" class="headerlink" title="睡眠周期了解一下"></a>睡眠周期了解一下</h1><p>书中有个设定就是R90，他将人类睡眠时间以90分钟为周期划分。</p>
<p>也就是你可以选择睡几个完整的睡眠周期。</p>
<p>如果睡眠时间不足你可以在午后，对应晚上的时间去补一个睡眠周期或者 30分钟的休息时间。</p>
<p><img src="http://haoqiao.qiniudn.com/WechatIMG160.jpeg" alt="imgn"></p>
<p><img src="http://haoqiao.qiniudn.com/WechatIMG161.jpeg" alt="imgn"></p>
<h1 id="睡眠习惯了解一下"><a href="#睡眠习惯了解一下" class="headerlink" title="睡眠习惯了解一下"></a>睡眠习惯了解一下</h1><p>常见的睡眠手段包括老生常谈的禁止玩手机：</p>
<p>在天黑以后，蓝光就成了一种不良光线。如果你在入夜之后使用一些电子产品，或者在夜深人静时还对着一片蓝光，就会引发各种健康问题。它将导致克里斯·艾德辛科斯基教授所称的“垃圾睡眠”——受干扰和不充足的睡眠。这是因为，我们的生活方式和各种小玩意儿的出现，妨碍了褪黑素的分泌，并推迟了我们的生物钟。</p>
<p>每个人根据自己情况分为早睡星人和晚睡星人。</p>
<p>感觉这和生活环境与习惯其实有很大关系。现代年轻人大部分都是晚睡党。</p>
<p>对于晚睡星人来说，如果想调整自己的生物钟，让自己能跟上早起星人的节奏，那么早晨的日光极为关键。你可以去买一台模拟日出自然唤醒灯，它能在卧室中模拟日出，从而把你从睡梦中唤醒。这点实测真的可以。晚上12点睡。早睡7点多，房间朝阳，阳光把你唤醒。同理可以想想学校的宿舍其实也是这样。</p>
<p>少喝咖啡：</p>
<p>咖啡因是一种容易让人上瘾的药物，如果每天大量摄入咖啡因，就会对咖啡因产生耐受力。你会需要越来越多的咖啡因才能达到想要的效果。一旦过量摄入咖啡因成为一种常规，那么，当你以为你在超常发挥时，实际情况往往并非如此。你会经常落后那几步，兴奋过度，变成自己的一个影子。因为，你虽然摄入了咖啡因，却只能达到你平时的水平。</p>
<p>也就是在不是很必要的情况下不要喝咖啡。<br>真的困可以调整自己的作息。比如多加30分钟的休息时间。</p>
<p>工作状态中可能在不该困的时间犯困：</p>
<p>每隔90分钟一次的“大脑休息”，能让你再度回到办公桌后的表现大幅提升，并让你的压力水平大幅降低。</p>
<p>当然最关键的是：如果你没有睡好，你的身体会嗜恋甜食。<br>也就是你会胖。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间对睡眠质量不太满意，因此在看到书的时候果断加入到阅读序列。&lt;/p&gt;
&lt;p&gt;除去睡眠常识，这本书最重要的其实是做出了一些科学的设定。&lt;
    
    </summary>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="读书笔记" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读后感" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
      <category term="自我提升" scheme="http://wiki.haoqiao.me/tags/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>CSRF</title>
    <link href="http://wiki.haoqiao.me/wiki/%E8%BF%9B%E9%98%B6/%E5%AE%89%E5%85%A8/csrf/"/>
    <id>http://wiki.haoqiao.me/wiki/进阶/安全/csrf/</id>
    <published>2017-11-25T02:35:12.000Z</published>
    <updated>2017-11-26T14:25:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSRF-简介"><a href="#CSRF-简介" class="headerlink" title="CSRF 简介"></a>CSRF 简介</h1><p><code>Cross Site Request Forgery，跨站域请求伪造</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">假设 abc 用户登录银行的网站进行操作，同时也访问了攻击者预先设置好的网站。</div><div class="line">abc 点击了攻击者网站的某一个链接，这个链接是 http://www.bank.com/xxxx 指向银行，银行服务器会根据这个链接携带的参数会进行转账操作。</div><div class="line">银行服务器在执行转账操作之前会进行 session 验证是否登录，但是由于 abc 已经登录了银行网站，攻击者的链接也是 www.bank.com。所以攻击的链接就会携带 session id 到银行服务器。</div><div class="line">由于 session id 是正确的，所以银行会判断操作是由本人发起的，执行转账操作。</div></pre></td></tr></table></figure>
<p>要完成一次 CSRF 攻击，受害者必须一次完成两个步骤</p>
<ol>
<li>登陆受信任网站 A，并在本地生成 cookie</li>
<li>在不退出 A 的情况下，访问了危险网站 B</li>
</ol>
<p>到这里，你也许会说：如果我不满足以上条件的中的任何一个，就不会受到攻击。但是你不能保证以下条件不会发生：</p>
<ol>
<li>你不能保证你登陆了一个网站后，不再打开一个 tab 页面并访问另外的网站</li>
<li>你不能保证你关闭浏览器后，你本地的 cookie 马上过期，你上次的会话已经结束</li>
<li>存在其他漏洞的可信任的经常被人访问的网站</li>
</ol>
<h1 id="防止-CSRF-的几种方法"><a href="#防止-CSRF-的几种方法" class="headerlink" title="防止 CSRF 的几种方法"></a>防止 CSRF 的几种方法</h1><h2 id="服务器端进行-CSRF-防御"><a href="#服务器端进行-CSRF-防御" class="headerlink" title="服务器端进行 CSRF 防御"></a>服务器端进行 CSRF 防御</h2><ol>
<li>Cookie Hashing（所有表单都包含同一个伪随机值）：</li>
</ol>
<blockquote>
<p>可以在表单中嵌入一个随机的 token。当真正的用户提交表单的时，你就会收到表单的随机 token，这样你就可以通过之前嵌入的那个随机 token 来校验了。在 CSRF 攻击场景中，攻击者永远都不可能拿到这个值甚至在攻击者可以请求到页面的情况也无法拿到，因为同源策略（SOP）会阻止攻击者从包含 token 的响应中读取内容。这个方法在实际运用中很不错，但是它需要网站追踪每一个请求并且返回 Anti-CSRF tokens。还有一个类似的在表单中嵌入 token 的方法是给浏览器一个包含相同值的 cookie 来实现的。当网站收到真正的用户提交他们的表单时，cookie 中的值和表单中的值将会相匹配。攻击者通过没有 CSRF cookie 的浏览器发送伪造的请求将会失败。</p>
</blockquote>
<ol>
<li>One-Time Tokens（不同的表单包含一个不同的伪随机值）：</li>
</ol>
<blockquote>
<p>如果用户在一个站点上同时打开了两个不同的表单，CSRF 保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保 CSRF 保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。</p>
<p>令牌同步模式（Synchronizer token pattern，简称 STP）是在用户请求的页面中的所有表单中嵌入一个 token，在服务端验证这个 token 的技术。token 可以是任意的内容，但是一定要保证无法被攻击者猜测到或者查询到。攻击者在请求中无法使用正确的 token，因此可以判断出未授权的请求。</p>
</blockquote>
<h1 id="验证了-origin-和-refer-是否能完全避免"><a href="#验证了-origin-和-refer-是否能完全避免" class="headerlink" title="验证了 origin 和 refer 是否能完全避免?"></a>验证了 origin 和 refer 是否能完全避免?</h1><blockquote>
<p>根据 HTTP 协议，在 HTTP 请求头中包含一个 referer 的字段，这个字段记录了该 HTTP 请求的原地址。通常情况下，执行转账操作的 POST 请求 www.bank.com/transfer.php 应该是点击 www.bank.com 网页的按钮来触发的操作，这个时候转账请求的 referer 应该是 www.bank.com。而如果黑客要进行 CSRF 攻击，只能在自己的网站 www.hacker.com 上伪造请求。伪造请求的 referer 是 www.hacker.com。所以我们通过对比 POST 请求的 referer 是不是 www.bank.com 就可以判断请求是否合法。</p>
</blockquote>
<p><code>黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</code></p>
<blockquote>
<p>为了防止 CSRF 的攻击，可以浏览器在发送 POST 请求的时候加上一个 Origin 字段，这个 Origin 字段主要是用来标识出最初请求是从哪里发起的。如果浏览器不能确定源在哪里，那么在发送的请求里面 Origin 字段的值就为空。</p>
</blockquote>
<p><code>如果攻击者如果直接通过假页面提交 Form，则不能在 header 里设置 X-From 属性；而如果攻击者也用 Ajax 提交，则 header 里的 Origin 因为不能伪造，也不能达到攻击的目的。从而达到了预防 CSRF 的目的。</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSRF-简介&quot;&gt;&lt;a href=&quot;#CSRF-简介&quot; class=&quot;headerlink&quot; title=&quot;CSRF 简介&quot;&gt;&lt;/a&gt;CSRF 简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Cross Site Request Forgery，跨站域请求伪造&lt;/code&gt;&lt;/p
    
    </summary>
    
      <category term="进阶" scheme="http://wiki.haoqiao.me/categories/%E8%BF%9B%E9%98%B6/"/>
    
      <category term="安全" scheme="http://wiki.haoqiao.me/categories/%E8%BF%9B%E9%98%B6/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSRF" scheme="http://wiki.haoqiao.me/tags/CSRF/"/>
    
      <category term="js 基础" scheme="http://wiki.haoqiao.me/tags/js-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>electron</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Ecmascript/electron/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/基础/Ecmascript/electron/</id>
    <published>2017-10-30T02:56:50.000Z</published>
    <updated>2017-11-26T14:25:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="electron"><a href="#electron" class="headerlink" title="electron"></a>electron</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>electron</p>
<h3 id="背景资料"><a href="#背景资料" class="headerlink" title="背景资料"></a>背景资料</h3><blockquote>
<p>使用 JavaScript，HTML 和 CSS 构建跨平台桌面应用程序。基于 Node.js 和 Chromium 开发的，Atom editor 以及很多其他的 apps 就是使用 electron 编写的</p>
<p>集成 Node 来授予网页访问底层系统的权限</p>
</blockquote>
<h3 id="electron-入门"><a href="#electron-入门" class="headerlink" title="electron 入门"></a>electron 入门</h3><p>全局安装 electron</p>
<p><code>npm install electron -g</code></p>
<p><code>yarn add electron -g</code></p>
<h5 id="主进程"><a href="#主进程" class="headerlink" title="主进程"></a>主进程</h5><p>主进程，通常是一个命名为 main.js 的文件，该文件是每个 electron 应用的入口。它控制了应用的生命周期（从打开到关闭）。它既能调用原生元素，也能创建新的（多个）渲染进程。另外，Node API 是内置其中的。</p>
<p><img src="http://haoqiao.qiniudn.com/1460000007503499.png" alt="imgn"></p>
<h4 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h4><blockquote>
<p>由于 electron 使用 Chromium 来展示页面，所以 Chromium 的多进程结构也被充分利用。每个 electron 的页面都在运行着自己的进程，这样的进程我们称之为渲染进程。在一般浏览器中，网页通常会在沙盒环境下运行，并且不允许访问原生资源。然而，electron 用户拥有在网页中调用 io.js 的 APIs 的能力，可以与底层操作系统直接交互。</p>
</blockquote>
<p>渲染进程是应用的一个浏览器窗口。与主进程不同，它能存在多个（注：一个 electron 应用只能存在一个主进程）并且相互独立（它也能是隐藏的）。主窗口通常被命名为 index.html。它们就像典型的 HTML 文件，但 electron 赋予了它们完整的 Node API。因此，这也是它与浏览器的区别。</p>
<p><img src="http://haoqiao.qiniudn.com/1460000007503500.png" alt="imgn"></p>
<h4 id="主进程与渲染进程的区别"><a href="#主进程与渲染进程的区别" class="headerlink" title="主进程与渲染进程的区别"></a>主进程与渲染进程的区别</h4><p>主进程使用 BroswerWindow 实例创建网页。每个 BroswerWindow 实例都在自己的渲染进程里运行着一个网页。当一个 BroswerWindow 实例被销毁后，相应的渲染进程也会被终止。主进程管理所有页面和与之对应的渲染进程。每个渲染进程都是相互独立的，并且只关心他们自己的网页。由于在网页里管理原生 GUI 资源是非常危险而且容易造成资源泄露，所以在网页面调用 GUI 相关的 APIs 是不被允许的。如果你想在网页里使用 GUI 操作，其对应的渲染进程必须与主进程进行通讯，请求主进程进行相关的 GUI 操作。</p>
<p><img src="http://haoqiao.qiniudn.com/1460000007503501.png" alt="imgn"></p>
<h4 id="相互通讯"><a href="#相互通讯" class="headerlink" title="相互通讯"></a>相互通讯</h4><blockquote>
<p>由于主进程和渲染进程各自负责不同的任务，而对于需要协同完成的任务，它们需要相互通讯。IPC 就为此而生，它提供了进程间的通讯。但它只能在主进程与渲染进程之间传递信息，即渲染进程之间不能进行。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;electron&quot;&gt;&lt;a href=&quot;#electron&quot; class=&quot;headerlink&quot; title=&quot;electron&quot;&gt;&lt;/a&gt;electron&lt;/h2&gt;&lt;h3 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Ecmascript" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/Ecmascript/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js 基础" scheme="http://wiki.haoqiao.me/tags/js-%E5%9F%BA%E7%A1%80/"/>
    
      <category term="electron" scheme="http://wiki.haoqiao.me/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>明朝那些事儿-上</title>
    <link href="http://wiki.haoqiao.me/wiki/%E9%98%85%E8%AF%BB/%E6%98%8E%E6%9C%9D%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-%E4%B8%8A/"/>
    <id>http://wiki.haoqiao.me/wiki/阅读/明朝那些事儿-上/</id>
    <published>2017-10-27T11:14:30.000Z</published>
    <updated>2017-10-27T12:17:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很早以前就知道《明朝那些事儿》挺火，从头火到现在，但那个时候呢，对唐朝比较感兴趣.因为有千古一帝-唐太宗。而且风云人物特别多，八卦也多~对明朝的印象好像就是以前那部穿越电视剧,对朱元璋的印象就是来人，把xxx拉出去砍了(然而历史上朱元璋还真的是和秦始皇有点像，万般难题只有一解:杀)。</p>
<p>《明朝那些事儿》还是很长的，一周看了大概二分之一,整体感官就是作者做到了大部分的不偏不倚,将明朝从朱元璋到朱棣再到后来者,每个人物都有血有肉，尤其是对历史上名不见传却起到重要作用的人物描述的很到位~</p>
<p>基本上可以作为一本有考据的历史读物.</p>
<p>之所以从小说读物入手，而不去直接读史记，读正史，是因为我觉得历史需要有趣，只有当你觉得足够有趣才会去深究，这到底是不是这样。不然很容易有倦怠性。因此我给自己列的书单都是从小说到正史。</p>
<h2 id="朱元璋"><a href="#朱元璋" class="headerlink" title="朱元璋"></a>朱元璋</h2><blockquote>
<p>长期的困难生活，最能磨练一个人的意志，有很多人在遇到困难后，只能怨天尤人，得过且过，而另外一些人虽然也不得不在困难面前低头，但他们的心从未屈服，他们不断的努力，相信一定能够取得最后的胜利</p>
<p>对于我们很多人来说，心是最柔弱的地方，它特别容易被伤害，爱情的背叛，亲情的失去，友情的丢失，都将是重重的一击。然而对于朱重八来说，还有什么不可承受的呢？他已经失去一切，还有什么比亲眼看着父母死去而无能为力，为了活下去和狗抢饭吃、被人唾骂，鄙视更让人痛苦！我们有理由相信，就在某一个痛苦思考的夜晚，朱重八把这个最脆弱的地方变成了最强大的力量的来源。</p>
</blockquote>
<p>朱元璋是从最底层出身，这非常励志。但这励志的背后是无人走过的艰辛。</p>
<p>从一个只想活着好好种地的农民，到只想避开战争好好活下去的和尚，再到起义的将领。</p>
<p>可以看到逼上梁山的无奈，水浒还可能是设计让人为贼，而朱元璋是真的硬生生被民不聊生的统治给逼迫造反。</p>
<blockquote>
<p>朱重八将他的名字改成了朱元璋，所谓璋，是一种尖锐的玉器，这个朱元璋实际上就是诛元璋，朱重八把他自己比成诛灭元朝的利器，而这一利器正是元朝的统治者自己铸造出来的。在今后的二十年里，他们都将畏惧这个名字。</p>
</blockquote>
<p>我觉得这个典故很有意思，改名朱元璋。灭元是朱元璋一生心愿，也是他活下去的动力。可以说元朝一手打造出来的造反皇帝。</p>
<blockquote>
<p>朱元璋从小就被官府欺压，自己的悲惨遭遇很大程度上是贪官污吏造成的，这也使得他很不喜欢这些当官的，即使官员们为他干活，在他的内心中对这些人也存在着极大的不信任感。这种不信任感一旦遇到某些因素的触发，就会迅速扩大，进而蔓延到对整个群体的信心缺失。 正如俗话所说“一朝被蛇咬，十年怕草绳”，朱元璋就是这样一个被蛇咬过的人，他被官吏们欺压了几十年，怎么会信任这些人。所以如空印案、郭桓案这样的案件一发生，朱元璋就会迅速将风潮扩大，在他看来，官员都是不可信的。</p>
</blockquote>
<p>童年的阴影造成不信任，这就造成朱元璋对待官员有一点点不爽都凡事都杀杀杀，杀不干净就继续杀，杀的没人了，戴罪当官。毕竟没几个人对小时候父母兄弟全饿死在自己面前而无动于衷。</p>
<p>可以说历史上如此强势的皇帝没几个，杀官杀的相当多，基本上自从朱元璋当上皇帝，他把功高盖主的，作死的，对后代有威胁的，全部都在他挂掉之前带走，顺便还亲自出征带走了一批不老实的元朝遗留。可以说是杀性最强的一个皇帝，这也看出开国皇帝都有一个特征，强势。一旦新朝建立，从农民翻身作为皇帝，好像就会很自然的代入这个角色，这也是一路马上打天下打出来的个性。因为性格偏软的基本都已经作为垫脚石化为白骨。</p>
<blockquote>
<p>对大臣们来说，朱元璋可能不是个好君主，但是对朱元璋的子孙们来说，朱元璋是个好父亲、好祖父。其实朱元璋的这种行为反差的理由也很简单，就如同今天独生子女的家长，特别是那些当年曾经挨过饿的人，自然不忍心让孩子受自己那样的苦，他们恨不得代替子女去承担来他们将来要经受的苦难。 朱元璋确确实实是一个好父亲，他希望自己的子孙能够团结一致，共同辅佐他选定的继承人朱允炆。但就如今天的所谓“代沟”一样，子孙们有自己的打算，特别是皇族的子孙，他们是无法体会朱元璋这种深厚的父爱的，在他们看来，这个白发苍苍的老者早就应该领退休金走人了。他们关注的只是这个老者所坐的那把椅子.</p>
</blockquote>
<h2 id="朱棣"><a href="#朱棣" class="headerlink" title="朱棣"></a>朱棣</h2><p>在父亲把皇位传给兄长的儿子，以后要向一个小屁孩俯首称臣，朱棣就开始想搞事情了.</p>
<p>在皇位面前，人人<code>平等</code>，这个<code>平等</code>是指没人性，没辈分，没怜悯。</p>
<blockquote>
<p>   这一罕见现象的缔造者正是朱棣的死对头朱允炆，正是他的那道不能伤害朱棣性命的旨意使得朱棣数次死里逃生。而那些打仗的士兵们并不是傻瓜，他们十分了解其中的利害关系。 朱棣和朱允炆是叔侄俩，虽然现在刀兵相见，属于敌我矛盾，但万一哪天两人决定不打了，来一场认亲大会，再来个和解，转化为了人民内部矛盾，那可就大大的不妙了。朱棣没准还能当个王爷，闲来无事的时候写本回忆录，记忆起某年某月某日，某某人在某场战役中砍我一刀或者射我一箭，虽然那时朱棣可能仕途上并不得意，但要整个把小兵还是很容易的。</p>
<p>正是出于士兵们的这种考虑，朱棣才得以在乱军之中得以幸免，朱允炆的这道指令最厉害的地方并不在于所谓不得伤害朱棣的命令本身，而是在于无数的南军的将领和士兵们从此命令中看到了两人和解的可能性，面前的这个敌人将来有一天甚至可能会成为自己的主人，所以动手杀朱棣这种费力不讨好的事情实在是没有多少人会去做的。 </p>
</blockquote>
<p>朱允炆不是一个合格的皇帝就在于他面对其它藩王都下得去手，而面对朱棣却乌龙频繁，一个只许活捉不可伤害犹如给朱棣反向奶了一口，而且还加了无敌buff，最终朱棣这个大流氓就靠这个敌人加的正向Buff在敌军中身先士卒多进多出毫发无损。朱棣的成功就告诉我们，人不要脸真的能无敌~</p>
<p>这里还要提到一个人就是<code>姚广孝</code>,明朝的风风雨雨都逃不过和尚，作为一个不合格的和尚姚广孝一心想搞事情来证明自己，后面的历史也说明了，当一个和尚真心想搞事情的时候谁也拦不住。</p>
<p>而且在朱棣后来开始清洗周围人的时候，姚广孝是不多能善终的。(主要不要钱，不要赏赐，不要房子，一心搞事，搞完就跑。)这也可见其智慧。</p>
<p>之所以对其印象深刻还是因为以前看的《雪中悍刀行》里有个<code>杨太岁</code>角色就是以他为原型。</p>
<blockquote>
<p>“世上怎么会有你这样奇异的和尚！长得一双三角眼，就像生病的老虎，你这样的人天性嗜好杀戮，将来你一定会成为刘秉忠那样的人！”</p>
</blockquote>
<p>历史中有很多看相然后使其出名的，当然不乏一些想搞事情的先自己造假，但是也说明了，历史中想搞点事情，你必须先搞定舆论(封建迷信)，当你把大部分人糊弄住了，你才有搞事情的基础。</p>
<p>而且就有现成的例子:</p>
<blockquote>
<p>张信的母亲帮助他做出了抉择，她老人家一听说要逮捕燕王，立刻制止了张信，并说道：“千万不可以这样做（逮捕燕王），我经常听人说，燕王将来必定会取得天下，他这样的人是不会死的，也不是你能够抓住的。”</p>
<p>   我们可能会觉得纳闷，这位老太太平日大门不出，二门不入，她怎么知道这样的“天机”？综合各种情况分析，这位老太太很可能是受到那些散布街头和菜市场的算命先生们传播的谣言影响，得出了这样一个结论。 如此重大的决策，竟然受一个如此可笑的理由和论据影响并最终做出，实在让人觉得啼笑皆非。</p>
</blockquote>
<p>在上帝视角我们可以觉得这很戏剧性，觉得历史很多都是巧合造成的。虽然巧合有，但是这些算命的也是朱棣自己放出去的。<code>这说明想成做成一件事情，你不光需要运气，你还需要自己去制造运气。</code></p>
<blockquote>
<p>太子的悲哀也就在此，无数太子就是这样被自己的父亲玩残的，自古以来，一把手和二把手的关系始终是处理不好的，在封建社会，皇帝就是一把手，太子就是二把手，自然逃脱不了这个规则的制约。 你积极肯干，说你有野心，你消极怠工，说你没前途。 干多了也不行，干少了也不行，其实只是要告诉你，不服我是不行的。 让你干，你就不得休息，不让你干，你就不得好死。 这似乎是很难理解的，到底是什么使得这一滑稽现象反复发生呢？ 答案很简单：权力。 谁分我的权，我就要谁的命！（儿子也不例外）朱棣很明白，他最终是要将权力交给太子的，而在此之前，太子必须有一定的办事能力，为了帝国的未来，无能的废物是不能成为继承人的，所以必须给太子权力和锻炼的机会，但他更明白，要想得一个善终，权利必须在自己手上。</p>
<p>   儿子是不能相信的，老婆是不能相信的，天下人都是不能相信的。 这就是皇帝的悲哀</p>
</blockquote>
<p>每一个皇帝做上那个位置都开始朝着另一个生物进化，而且只有一个人能进化。当<code>种族</code>不同了，以前的同伴，信任的谋士。甚至是亲人。都成了不同<code>种族</code>的。想要培养下一个能进化的人，一边要防着他背叛，一边还要防止他无能.这是一个自相矛盾却又无解的问题。在皇权没有那么集中的年代，<code>种族</code>划分还没有那么明显，当一个统治者是件辛苦的事情。但是到了后来，权利越大，当统治者变成了一件可以将欲望无限放大的事情。<code>进化</code>的机会就一个，培养继承人如同炼蛊。活下来那个最强，也最残暴。</p>
<h2 id="郑和"><a href="#郑和" class="headerlink" title="郑和"></a>郑和</h2><blockquote>
<p>在经过一番整顿后，逐渐稳住阵脚，开始与北军作战，几十万人奋死拼命厮杀，打得天昏地暗，血流成河。战局陷入僵持状态对朱棣是不利的，因为他并不适合打消耗战，为了能够尽快解决战斗，他向身边的人征求作战意见。 此时一个叫马三保的人明确指出，南军的要害就在于李景隆的中军，只要李景隆移动位置，便可趁其立足未稳之机以奇兵左右夹击，定可获胜。朱棣经过思考，采纳了马三保的意见，并任命马三保为部将，一同参加战斗。此时已经天黑，李景隆果然按捺不住，亲自带领中军前来作战，朱棣立刻派出奇兵从其两翼发动猛烈攻击，李景隆果然抵挡不住，败下阵来</p>
<p>马三保的人也因在此战中的优秀表现为朱棣所重用，并引为心腹，此人出生时父母为世道平和，平安成长之意，曾给他取名为和，又由于他在郑村立下大功，被朱棣赐姓“郑”，此后他便改名为郑和。</p>
<p>郑和是一名虔诚的伊斯兰教徒，他的祖父和父亲都信奉伊斯兰教，而所有的伊斯兰教徒心底都有着一个最大的愿望——去圣城麦加朝圣</p>
</blockquote>
<p>这是觉得有意思的地方，以前觉得郑和下西洋就是奉旨。没想到人家是一个有信仰的人~</p>
<p>他一生最后一次下西洋终于完成他的人生目标，去圣城麦加朝圣，虽然回程一半年老衰死。但是他用一生告诉我们一个人，只要倾尽其一生精力，即使是在那个封建的年代，人也可以完成自己的梦想。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>只简单的记了几个人物，但是从他们的经历中，提炼出来的是坚持。每一个完成自己目标的人，期间可能想过放弃，但是他们没有其他选择，放弃就是死亡。在这种只有一条路的选择中，他们选择了坚持。我们现在能看到的是历史记载一瞥而过的文字，而对他们是几年几十年如一日的浓缩。</p>
<p>我们可以从明朝这些历史中看到非常值得敬佩的人，力挽狂澜的于谦，送人头送经验的李景隆。有品德高尚入圣人，也有无耻刷新人底线的。</p>
<p>我们可以看到不同性格不同样的人在不同的相同的环境下做的不同选择，从而一步步演化成历史上的一幕幕。</p>
<p>这很有意思。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;很早以前就知道《明朝那些事儿》挺火，从头火到现在，但那个时候呢，对唐朝比较感兴趣.因为有千古一帝-唐太宗。而且风云人物特别多，八卦也多~对明
    
    </summary>
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读" scheme="http://wiki.haoqiao.me/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="读书笔记" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读后感" scheme="http://wiki.haoqiao.me/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
      <category term="自我提升" scheme="http://wiki.haoqiao.me/tags/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>框架基础</title>
    <link href="http://wiki.haoqiao.me/wiki/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
    <id>http://wiki.haoqiao.me/wiki/前端/框架/框架基础/</id>
    <published>2017-10-22T02:35:12.000Z</published>
    <updated>2018-03-19T03:37:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="koa源码-与中间件"><a href="#koa源码-与中间件" class="headerlink" title="koa源码 与中间件"></a>koa源码 与中间件</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>koa源码。怎么实现中间件机制。koa2和koa1有什么区别</p>
<h3 id="KOA背景资料"><a href="#KOA背景资料" class="headerlink" title="KOA背景资料"></a>KOA背景资料</h3><blockquote>
<p>koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。 </p>
</blockquote>
<h3 id="KOA2源码剖析"><a href="#KOA2源码剖析" class="headerlink" title="KOA2源码剖析"></a>KOA2源码剖析</h3><p>来一张原理图:</p>
<p><img src="http://haoqiao.qiniudn.com/koa2img1.png" alt="imgn"></p>
<p>Koa 的源码中主要为 lib 目录下的 application.js、context.js、request.js 与 response.js 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">application.js: 框架入口，导出 Application 类，即使用时导入的 Koa 类</div><div class="line"></div><div class="line">context.js: context 对象的原型，代理 request 与 response 对象</div><div class="line"></div><div class="line">request.js: request 对象的原型，提供请求相关的数据与操作</div><div class="line"></div><div class="line">response.js: response 对象的原型，提供响应相关的数据与操作</div></pre></td></tr></table></figure>
<p>我们从核心的<code>application</code>开始读，首先我们会看到加载了一系列的依赖，但最重要的还是<code>Emitter</code></p>
<p>因为<code>module.exports = class Application extends Emitter</code></p>
<p>暴露出来的类就直接是继承自<code>Emitter</code></p>
<p>而<code>Emitter</code>是NodeJS中<code>events</code>模块提供的一个对象，<code>EventEmitter 的核心就是事件触发与事件监听器功能的封装</code></p>
<p>这样我们不难推导出，<code>Application</code>的主要作用就是绑定监听一些事件，等待触发然后处理。</p>
<p>所有的异步 I/O 操作在完成时都会发送一个事件到事件队列.</p>
<p>接着看构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">constructor() &#123;</div><div class="line">  super(); // super 关键字用于调用一个对象的父对象上的函数。(tip 1)</div><div class="line"></div><div class="line">  this.proxy = false; // 默认取消代理</div><div class="line">  this.middleware = []; // 中间件</div><div class="line">  this.subdomainOffset = 2; //子域默认偏移量(tip 2)</div><div class="line">  </div><div class="line">      </div><div class="line">  this.env = process.env.NODE_ENV || &apos;development&apos;; // 环境判断</div><div class="line">  this.context = Object.create(context);</div><div class="line">  // Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象，context是之前加载的本地context.js依赖</div><div class="line">  </div><div class="line">  this.request = Object.create(request);</div><div class="line">  this.response = Object.create(response);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化之后我们看内部的<code>listen函数</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">listen(...args) &#123;</div><div class="line">  debug(&apos;listen&apos;);</div><div class="line">  const server = http.createServer(this.callback());</div><div class="line">  return server.listen(...args);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>http</code>模块创建Server服务。然后调用本地的<code>callback()</code></p>
<p>我们来看<code>callback()</code>做了什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">callback() &#123;</div><div class="line">    const fn = compose(this.middleware);</div><div class="line">// 传入中间件数组作为参数组合生成一个函数</div><div class="line"></div><div class="line">    if (!this.listeners(&apos;error&apos;).length) this.on(&apos;error&apos;, this.onerror);</div><div class="line"></div><div class="line">// callback方法返回http.createServer所需要的回调函数handleRequest</div><div class="line"></div><div class="line">    const handleRequest = (req, res) =&gt; &#123;</div><div class="line">      res.statusCode = 404;</div><div class="line">      // 利用createContext函数把node返回的req和res进行了封装创建出context</div><div class="line">      const ctx = this.createContext(req, res);</div><div class="line">      const onerror = err =&gt; ctx.onerror(err);</div><div class="line">      const handleResponse = () =&gt; respond(ctx); //响应处理</div><div class="line">      </div><div class="line">      onFinished(res, onerror);// 当request对象关闭，完成或者报错的时候会执行回调函数。</div><div class="line">      </div><div class="line">      return fn(ctx).then(handleResponse).catch(onerror); // 依次调用所有中间件，然后执行响应处理函数respond(ctx)</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return handleRequest;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>我们可以看到起手调用了<code>compose</code>,这也是依赖模块<code>koa-compose</code>，但是在源码中没有，我们需要<code>yarn</code>或者<code>npm</code>把依赖下载下来。<code>callback()函数通过 koa-compose 组合所有的中间件，组合成单个函数。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function compose (middleware) &#123;</div><div class="line">  // middleware 必须是数组不然抛出异常</div><div class="line">  if (!Array.isArray(middleware)) throw new TypeError(&apos;Middleware stack must be an array!&apos;)</div><div class="line">  // middleware数组里必须是function不然抛出异常</div><div class="line">  for (const fn of middleware) &#123;</div><div class="line">    if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;Middleware must be composed of functions!&apos;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * @param &#123;Object&#125; context</div><div class="line">   * @return &#123;Promise&#125;</div><div class="line">   * @api public</div><div class="line">   */</div><div class="line">  // 接受上下文，以及next</div><div class="line">  return function (context, next) &#123;</div><div class="line">    // last called middleware #</div><div class="line">    let index = -1</div><div class="line">    return dispatch(0)</div><div class="line">    // dispatch函数的递归调用</div><div class="line">    </div><div class="line">    function dispatch (i) &#123;</div><div class="line">      if (i &lt;= index) return Promise.reject(new Error(&apos;next() called multiple times&apos;))</div><div class="line">      index = i</div><div class="line">      let fn = middleware[i]</div><div class="line">      // 处理最后一个中间件还有next的情况，直接resolve</div><div class="line">      if (i === middleware.length) fn = next</div><div class="line">      if (!fn) return Promise.resolve()</div><div class="line">      try &#123;</div><div class="line">        return Promise.resolve(fn(context, function next () &#123;</div><div class="line">          return dispatch(i + 1)</div><div class="line">        &#125;))</div><div class="line">      &#125; catch (err) &#123;</div><div class="line">        return Promise.reject(err)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Koa处理请求的过程：当请求到来的时候，会通过 req 和 res 来创建一个 context (ctx) ，然后执行中间件。</code></p>
<p>这就要提到自带的<code>createContext</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">createContext(req, res) &#123;</div><div class="line"> // 通过context.js request.js response.js创建context  request  response</div><div class="line">   const context = Object.create(this.context);</div><div class="line">   const request = context.request = Object.create(this.request);</div><div class="line">   const response = context.response = Object.create(this.response);</div><div class="line">   </div><div class="line">   // 参数赋值</div><div class="line">   context.app = request.app = response.app = this;</div><div class="line">   context.req = request.req = response.req = req;</div><div class="line">   context.res = request.res = response.res = res;</div><div class="line">   request.ctx = response.ctx = context;</div><div class="line">   request.response = response;</div><div class="line">   response.request = request;</div><div class="line">   context.originalUrl = request.originalUrl = req.url;</div><div class="line">   context.cookies = new Cookies(req, res, &#123;</div><div class="line">     keys: this.keys,</div><div class="line">     secure: request.secure</div><div class="line">   &#125;);</div><div class="line">   request.ip = request.ips[0] || req.socket.remoteAddress || &apos;&apos;;</div><div class="line">   context.accept = request.accept = accepts(req);</div><div class="line">   context.state = &#123;&#125;;</div><div class="line">   return context;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>然后我们来看响应处理函数<code>respond</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function respond(ctx) &#123;</div><div class="line">  //  koa 中可以通过设置 ctx.respond = false来跳过这个函数</div><div class="line">  if (false === ctx.respond) return;</div><div class="line">  </div><div class="line">  // 当上下文对象不可写时也会退出该函数</div><div class="line">  const res = ctx.res;</div><div class="line">  if (!ctx.writable) return;</div><div class="line"></div><div class="line">  let body = ctx.body;</div><div class="line">  const code = ctx.status;</div><div class="line"></div><div class="line">  // 当返回的状态码表示没有响应主体时，将响应主体置空：</div><div class="line">  if (statuses.empty[code]) &#123;</div><div class="line">    // strip headers</div><div class="line">    ctx.body = null;</div><div class="line">    return res.end();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">//当请求方法为 HEAD 时，判断响应头是否发送以及响应主体是否为 JSON 格式，若满足则设置响应 Content-Length：</div><div class="line">  if (&apos;HEAD&apos; == ctx.method) &#123;</div><div class="line">    if (!res.headersSent &amp;&amp; isJSON(body)) &#123;</div><div class="line">      ctx.length = Buffer.byteLength(JSON.stringify(body));</div><div class="line">    &#125;</div><div class="line">    return res.end();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 当返回的状态码表示有响应主体，但响应主体为空时，将响应主体设置为响应信息或状态码。并当响应头未发送时设置 Content-Type 与 Content-Length：</div><div class="line">  if (null == body) &#123;</div><div class="line">    body = ctx.message || String(code);</div><div class="line">    if (!res.headersSent) &#123;</div><div class="line">      ctx.type = &apos;text&apos;;</div><div class="line">      ctx.length = Buffer.byteLength(body);</div><div class="line">    &#125;</div><div class="line">    return res.end(body);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 对不同的响应主体进行处理</div><div class="line">  if (Buffer.isBuffer(body)) return res.end(body);</div><div class="line">  if (&apos;string&apos; == typeof body) return res.end(body);</div><div class="line">  if (body instanceof Stream) return body.pipe(res);</div><div class="line"></div><div class="line">  // body: json</div><div class="line">  body = JSON.stringify(body);</div><div class="line">  if (!res.headersSent) &#123;</div><div class="line">    ctx.length = Buffer.byteLength(body);</div><div class="line">  &#125;</div><div class="line">  res.end(body);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到处理函数是做了一系列判断，最后是用<code>res.end</code>来输出body.</p>
<p>读完<code>application.js</code>之后回到之前的列表，接下来读<code>context.js</code></p>
<p>原以为<code>context.js</code>有一些处理函数。但是读完发现它里面只做了三件事：</p>
<p>1.暴露一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">const proto = module.exports</div></pre></td></tr></table></figure>
<ol>
<li>错误处理函数,this.app继承自event.emitter，通过error事件触发onerror。onerror方法将取得的error code设置为传入err的status，默认为500，在设置完http相应的长度、状态码及body后，发送该响应至用户。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">onerror(err) &#123;</div><div class="line"></div><div class="line">// 首先对传入的 err 变量进行判断，当 err 为空时退出该函数，或者当 err 不为空且不为 Error 类型时抛出异常。</div><div class="line">    // don&apos;t do anything if there is no error.</div><div class="line">    // this allows you to pass `this.onerror`</div><div class="line">    // to node-style callbacks.</div><div class="line">    if (null == err) return;</div><div class="line"></div><div class="line">    if (!(err instanceof Error)) err = new Error(`non-error thrown: $&#123;err&#125;`);</div><div class="line"></div><div class="line">// 设置 headerSent变量表示响应头是否发送，若响应头以发送，或者不可写（即无法在响应中添加错误信息等），则退出该函数</div><div class="line"></div><div class="line">    let headerSent = false;</div><div class="line">    if (this.headerSent || !this.writable) &#123;</div><div class="line">      headerSent = err.headerSent = true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 触发 app 自身的 error 事件，将错误抛给 app。</div><div class="line">    // delegate</div><div class="line">    this.app.emit(&apos;error&apos;, err, this);</div><div class="line"></div><div class="line">    // nothing we can do here other</div><div class="line">    // than delegate to the app-level</div><div class="line">    // handler and log.</div><div class="line">    if (headerSent) &#123;</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    const &#123; res &#125; = this;</div><div class="line"></div><div class="line">// 因为发生了错误，所以必须将之前的中间设置的响应头信息清空。</div><div class="line"></div><div class="line">    // first unset all headers</div><div class="line">    if (typeof res.getHeaderNames === &apos;function&apos;) &#123;</div><div class="line">      res.getHeaderNames().forEach(name =&gt; res.removeHeader(name));</div><div class="line">    &#125; else &#123;</div><div class="line">      res._headers = &#123;&#125;; // Node &lt; 7.7</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // then set those specified</div><div class="line">    this.set(err.headers);</div><div class="line"></div><div class="line">    // force text/plain</div><div class="line">    this.type = &apos;text&apos;;</div><div class="line"></div><div class="line">    // ENOENT support</div><div class="line">    if (&apos;ENOENT&apos; == err.code) err.status = 404;</div><div class="line"></div><div class="line">    // default to 500</div><div class="line">    if (&apos;number&apos; != typeof err.status || !statuses[err.status]) err.status = 500;</div><div class="line"></div><div class="line">    // respond</div><div class="line">    const code = statuses[err.status];</div><div class="line">    // Koa 使用 http-errors 创建错误对象，expose 属性表示是否像客户端暴露错误信息。</div><div class="line">    const msg = err.expose ? err.message : code;</div><div class="line">    this.status = err.status;</div><div class="line">    this.length = Buffer.byteLength(msg);</div><div class="line">    this.res.end(msg);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>3.将request和response的方法代理到自己身上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">delegate(proto, &apos;response&apos;)</div><div class="line">  .method(&apos;attachment&apos;)</div><div class="line">  .method(&apos;redirect&apos;)</div><div class="line">  .method(&apos;remove&apos;)</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">delegate(proto, &apos;request&apos;)</div><div class="line">  .method(&apos;acceptsLanguages&apos;)</div><div class="line">  .method(&apos;acceptsEncodings&apos;)</div><div class="line">  .method(&apos;acceptsCharsets&apos;)</div><div class="line">  .method(&apos;accepts&apos;)</div><div class="line">  .method(&apos;get&apos;)</div><div class="line">  .method(&apos;is&apos;)</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<p>接下来是<code>request.js</code>, 开头加载了一些依赖模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">const URL = require(&apos;url&apos;).URL;</div><div class="line">const net = require(&apos;net&apos;);</div><div class="line">const contentType = require(&apos;content-type&apos;);</div><div class="line">...</div></pre></td></tr></table></figure>
<p>和之前两者不一样，它是直接暴露了里面的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  get header() &#123;</div><div class="line">    return this.req.headers;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  set header(val) &#123;</div><div class="line">    this.req.headers = val;</div><div class="line">  &#125;,</div><div class="line">  </div><div class="line">  ...</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>request里的方法都是封装了请求相关的属性以及方法。相当于一个代理转发。只是把名称缩写了。</p>
<p>通过 application.js 中的createContext方法，代理对应的 request 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">createContext(req, res) &#123;</div><div class="line">   const context = Object.create(this.context);</div><div class="line">   const request = context.request = Object.create(this.request);</div><div class="line">   const response = context.response = Object.create(this.response);</div><div class="line">   context.app = request.app = response.app = this;</div><div class="line">   context.req = request.req = response.req = req;</div><div class="line">   context.res = request.res = response.res = res;</div><div class="line">   request.ctx = response.ctx = context;</div><div class="line">   request.response = response;</div><div class="line">   response.request = request;</div><div class="line">   context.originalUrl = request.originalUrl = req.url;</div></pre></td></tr></table></figure>
<p>request.req为原生的请求对象，在 request.js 中属性的获取都是通过 ths.req来获取的（即 request.req）。 因为之前context代理了所有事件，</p>
<p><code>const request = context.request = Object.create(this.request)</code></p>
<p><code>context.req = request.req = response.req = req;</code> </p>
<p>同理<code>response</code>也是这么处理的。response.js 封装了响应相关的属性以及方法。与 request 相同，通过createContext方法代理对应的 response 对象。</p>
<p>这里为什么不细讲，因为牵扯到http协议，准备读完<code>RFC 1945(HTTP/1.0)</code> 和 <code>RFC 2616(HTTP/1.1)</code>再回过来补充</p>
<h3 id="koa1-与-koa2-的区别"><a href="#koa1-与-koa2-的区别" class="headerlink" title="koa1 与 koa2 的区别"></a>koa1 与 koa2 的区别</h3><p>koa2.0相对于1.0，区别体现在</p>
<p><code>1.将var换成了let及const</code><br><code>2.使用箭头函数简化书写</code><br><code>3.不再支持generator</code><br><code>4.以及对于中间件的处理上。koa1的中间件使用generator函数，使用yield next进入下一个中间件，koa2中间件使用async函数，使用await next()进入下一个中间件</code></p>
<blockquote>
<p>koa1中间件有一个很形象的比喻，就像一个洋葱，一个请求从最外面那一层进入洋葱，一路上进过一层层的中间件，到达洋葱心之后，请求完成了任务，又派了响应出去，带上需要返回的数据，一层层地返回最外面。而在进入出来的过程中，中间件会对请求和响应做『手脚』，比如对请求检验cookie，对响应加etag。</p>
<p>koa2运用的是递归调用的方式实现中间件的洋葱模型和koa1很不太一样，一般在await next(), 而每次next执行的方法都会返回一个Promsie,await Promise 就是等待该Promise resolve返回，当然也可以通过外层的try catch来捕获Promise的reject信息；这样子只要中间有一个reject的promise直接返回Promise.reject(err)不去执行dispatch(i+1)这样子就不递归下去了；否则会一直递归到最后一个中间件</p>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><code>tip 1</code>:</p>
<blockquote>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。<br>ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
</blockquote>
<p><code>tip 2</code>:</p>
<blockquote>
<p>app.subdomainOffset属性默认为2，则域名“tobi.ferrets.example.com”返回[“ferrets”, “tobi”]，如果app.subdomainOffset设为3，则返回[“tobi”]。</p>
<p><a href="https://github.com/koajs/koa" rel="external nofollow noopener noreferrer" target="_blank">koa github</a></p>
<p><a href="http://www.runoob.com/nodejs/nodejs-event.html" rel="external nofollow noopener noreferrer" target="_blank">nodejs 简易教程</a></p>
<p><a href="http://www.ahonn.me/2017/05/17/koa2-analysis/" rel="external nofollow noopener noreferrer" target="_blank">koa2 源码解析</a></p>
<p><a href="https://github.com/tj/node-delegates/blob/master/index.js" rel="external nofollow noopener noreferrer" target="_blank">node-delegates</a></p>
<p><a href="https://segmentfault.com/a/1190000009875733" rel="external nofollow noopener noreferrer" target="_blank">Koa2源码阅读笔记</a></p>
<p><a href="http://man.chinaunix.net/develop/rfc/RFC1945.txt" rel="external nofollow noopener noreferrer" target="_blank">RFC 1945</a></p>
<p><a href="https://tools.ietf.org/html/rfc2616" rel="external nofollow noopener noreferrer" target="_blank">RFC 2616</a></p>
</blockquote>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><p>React特性、virtual dom、diff 、合成事件、调和等原理</p>
<h3 id="React背景资料"><a href="#React背景资料" class="headerlink" title="React背景资料"></a>React背景资料</h3><blockquote>
<p>React是用于构建用户界面的声明性，高效且灵活的JavaScript库。</p>
<p>React的目的是构建随着时间数据不断变化的大规模应用程序</p>
</blockquote>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li><p>组件化。仅仅是 UI：许多人使用 React 作为 MVC 架构的 V 层。尽管 React 并没有假设过你的其余技术栈，但它仍可以作为一个小特征轻易地在已有项目中使用。</p>
</li>
<li><p>虚拟 DOM：React 为了更高超的性能而使用虚拟 DOM 作为其不同的实现。它同时也可以由服务端 Node.js 渲染——而不需要过重的浏览器DOM支持。</p>
</li>
<li><p>数据流：React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。</p>
</li>
</ul>
<h3 id="virtual-dom"><a href="#virtual-dom" class="headerlink" title="virtual dom"></a>virtual dom</h3><p>virtual dom作为核心概念，了解其原理以及在React中实现方式是必不可少的。</p>
<p>首先我们需要了解<code>真实Dom</code>的构建方式</p>
<p><img src="https://developer.mozilla.org/files/464/Gecko_Overview_9.png" alt="imgn"></p>
<p>配合参考资料可以更详细的了解。</p>
<p>每次操作DOM,DOM中的某些内容都会发生变化。由于DOM被表示为一个树结构，所以DOM的变化非常快，但是更改的元素，而且它的孩子们必须经历Reflow / Layout阶段，然后更改必须重新绘制。</p>
<p><code>Virtual-DOM是什么，它尝试最小化这两个阶段，从而为一个复杂的应用程序获得更好的性能。</code></p>
<p><code>Virtual-DOM</code>就是用 JavaScript 对象<br>表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方。</p>
<h3 id="调和"><a href="#调和" class="headerlink" title="调和"></a>调和</h3><p><code>什么叫调和？</code></p>
<blockquote>
<p>在每次数据更新过后，React 会重新调用 render 渲染出新的组件结构，新的结构应用到 DOM 中的过程就叫做调和过程。</p>
</blockquote>
<p><code>调和：react将Virtual DOM树转成真实dom树最少的操作称之为调和</code></p>
<p><code>为什么需要调和？</code></p>
<blockquote>
<p>想一想，假设我们有一个输入组件，这个时候我们正聚焦在输入框中，当修改值过后触发事件导致了数据改变，数据改变导致了重渲染， 这个时候输入框被替换成了新的 DOM。 这个过程对用户来说应该是无感知的，所以那原来的聚焦状态应该被保存， 那怎么做到的呢？ DOM 都被替换了，输入状态，选择状态为什么还能保存。 我们先不急着知道 How，目前只需要知道这就是调和过程.</p>
</blockquote>
<p><code>diff算法就是调和的具体体现</code></p>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p><code>diff 策略</code></p>
<ul>
<li><p>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</p>
</li>
<li><p>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</p>
</li>
<li><p>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</p>
</li>
</ul>
<p>React 通过分层求异的策略，对 tree diff 进行算法优化；</p>
<p>React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化；</p>
<p>React 通过设置唯一 key的策略，对 element diff 进行算法优化。</p>
<p>具体细节可参考我以前的<a href="http://haoqiao.me/2015/08/16/translate-one.html">翻译文章</a> 和 <a href="https://zhuanlan.zhihu.com/p/20346379" rel="external nofollow noopener noreferrer" target="_blank">diff源码剖析</a></p>
<h3 id="SyntheticEvent-合成事件"><a href="#SyntheticEvent-合成事件" class="headerlink" title="SyntheticEvent (合成事件)"></a>SyntheticEvent (合成事件)</h3><p>React自己实现了一套高效的事件注册，存储，分发和重用逻辑，在DOM事件体系基础上做了很大改进，减少了内存消耗，简化了事件逻辑，并最大化的解决了IE等浏览器的不兼容问题。与DOM事件体系相比，它有如下特点:</p>
<ul>
<li><p>React组件上声明的事件最终绑定到了document这个DOM节点上，而不是React组件对应的DOM节点。故只有document这个节点上面才绑定了DOM原生事件，其他节点没有绑定事件。这样简化了DOM原生事件，减少了内存开销</p>
</li>
<li><p>React以队列的方式，从触发事件的组件向父组件回溯，调用它们在JSX中声明的callback。也就是React自身实现了一套事件冒泡机制。我们没办法用event.stopPropagation()来停止事件传播，应该使用event.preventDefault()</p>
</li>
<li><p>React使用对象池来管理合成事件对象的创建和销毁，这样减少了垃圾的生成和新对象内存的分配，大大提高了性能</p>
</li>
</ul>
<p>原理：</p>
<blockquote>
<p>React并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。</p>
</blockquote>
<p><img src="http://haoqiao.qiniudn.com/react%20event%20.jpg" alt="imgn"></p>
<p>关于源码级别的分析<a href="http://zhenhua-lee.github.io/react/react-event.html" rel="external nofollow noopener noreferrer" target="_blank">戳这里</a></p>
<h3 id="组件热加载方案"><a href="#组件热加载方案" class="headerlink" title="组件热加载方案"></a>组件热加载方案</h3><p>webpack 的 HotModuleReplacement 热加载插件</p>
<h3 id="为啥要给列表类组件设个key"><a href="#为啥要给列表类组件设个key" class="headerlink" title="为啥要给列表类组件设个key?"></a>为啥要给列表类组件设个key?</h3><p>react利用key来识别组件，它是一种身份标识标识，就像我们的身份证用来辨识一个人一样。每个key对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建<br>key相同，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新。<br>key值不同，则react先销毁该组件(有状态组件的componentWillUnmount会执行)，然后重新创建该组件（有状态组件的constructor和componentWillUnmount都会执行）</p>
<p>数组创建子组件的位置并不固定，动态改变的.</p>
<h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote>
<p><a href="https://reactjs.org/docs/react-api.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a><br><a href="https://developer.mozilla.org/en-US/docs/Introduction_to_Layout_in_Mozilla" rel="external nofollow noopener noreferrer" target="_blank">Introduction_to_Layout_in_Mozilla</a><br><a href="https://www.zhihu.com/question/29504639" rel="external nofollow noopener noreferrer" target="_blank">如何理解虚拟DOM</a></p>
</blockquote>
<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><h3 id="Redux-是如何管理React"><a href="#Redux-是如何管理React" class="headerlink" title="Redux 是如何管理React"></a>Redux 是如何管理React</h3><p>Redux 主要分为三个部分 Action、Reducer、及 Store</p>
<p>在 Redux 中，action 主要用来传递操作 State 的信息，以 Javascript Plain Object 的形式存在</p>
<p>Reducer 一般为简单的处理函数，通过传入旧的 state 和指示操作的 action 来更新 state</p>
<p>Store 是单一的。维护着一个全局的 State，并且根据 Action 来进行事件分发处理 State。可以看出 Store 是一个把 Action 和 Reducer 结合起来的对象。</p>
<h2 id="Redux-有哪些优缺点"><a href="#Redux-有哪些优缺点" class="headerlink" title="Redux 有哪些优缺点"></a>Redux 有哪些优缺点</h2><p>一个可预测的状态容器</p>
<ol>
<li><p>单一数据源，Single Source of Truth（也即题干中提到的 「单一的 State 状态树」）</p>
</li>
<li><p>所有数据都是只读的，要想修改数据，必须 dispatch 一个 action 来描述什么发生了改变</p>
</li>
<li><p>当处理 action 时，必须生成一个新的 state，不得直接修改原始对象</p>
</li>
</ol>
<p>开发时可以在不考虑数据修改的情况下，优先完成整体视图逻辑，然后在添加对数据的修改操作等业务逻辑时几乎不用修改视图逻辑代码</p>
<p>缺点：</p>
<p>代码量很大。完成一个动作经历三层修改。</p>
<p>Ajax 等各种异步的副作用，Redux 本身是无能为力。因此大量中间件 redux-thunk，redux-saga，redux-observable 等中间件，非常散乱。</p>
<h2 id="HOC"><a href="#HOC" class="headerlink" title="HOC"></a>HOC</h2><blockquote>
<p> React 高阶组件(React High-Order Component) </p>
</blockquote>
<p>高阶函数接收函数作为函数的参数，返回一个函数；高阶组件接受组件作为函数的参数，返回一个组件</p>
<p>高阶组件属于函数式编程(functional programming)思想，对于被包裹的组件时不会感知到高阶组件的存在，而高阶组件返回的组件会在原来的组件之上具有功能增强的效果。而Mixin这种混入的模式，会给组件不断增加新的方法和属性，组件本身不仅可以感知，甚至需要做相关的处理(例如命名冲突、状态维护)，一旦混入的模块变多时，整个组件就变的难以维护，也就是为什么如此多的React库都采用高阶组件的方式进行开发。</p>
<h3 id="antd是如何实现组件的封装的"><a href="#antd是如何实现组件的封装的" class="headerlink" title="antd是如何实现组件的封装的"></a>antd是如何实现组件的封装的</h3><p>antd是一个表现组件库,它的主要依赖是react-component,react-component是一个行为组件库,很多antd实现起来略复杂的组件是依赖react-component,这个设计思路很好,先定义一个行为组件库,在行为组件库之上可以用各种设计语言实现,ant design自然用的是自己的设计语言</p>
<h3 id="React-Redux的HOC的实现，connect函数的实现"><a href="#React-Redux的HOC的实现，connect函数的实现" class="headerlink" title="React-Redux的HOC的实现，connect函数的实现"></a>React-Redux的HOC的实现，connect函数的实现</h3><blockquote>
<p>connect 方法的函数签名是: connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])(Component) =&gt; EnhancedComponent。这正是高阶组件的标准写法。</p>
</blockquote>
<p>connect 其实是 connectAdvanced 的包装，在设计模式中叫外观（facade）模式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;koa源码-与中间件&quot;&gt;&lt;a href=&quot;#koa源码-与中间件&quot; class=&quot;headerlink&quot; title=&quot;koa源码 与中间件&quot;&gt;&lt;/a&gt;koa源码 与中间件&lt;/h2&gt;&lt;h3 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;header
    
    </summary>
    
      <category term="前端" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="框架" scheme="http://wiki.haoqiao.me/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="前端" scheme="http://wiki.haoqiao.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="KOA" scheme="http://wiki.haoqiao.me/tags/KOA/"/>
    
      <category term="框架基础" scheme="http://wiki.haoqiao.me/tags/%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
